From f5c3997e0292b6f7ef9d7ce6cfc00f42efb16ddd Mon Sep 17 00:00:00 2001
From: Katsuki Tozawa <katsuki.tozawa.wz@renesas.com>
Date: Mon, 3 Feb 2025 16:38:05 +0900
Subject: [PATCH] enable drp driver

Signed-off-by: Katsuki Tozawa <katsuki.tozawa.wz@renesas.com>
Signed-off-by: Tai Huynh <tai.huynh.cp@renesas.com>
---
 drivers/Kconfig          |    2 +
 drivers/Makefile         |    1 +
 drivers/drp/Kconfig      |   29 +
 drivers/drp/Makefile     |   13 +
 drivers/drp/drp-core.c   | 1664 ++++++++++++++++++++++++
 drivers/drp/drp-core.h   |  120 ++
 drivers/drp/drp-if.c     | 2594 ++++++++++++++++++++++++++++++++++++++
 drivers/drp/drp-reg.h    | 1071 ++++++++++++++++
 drivers/drp/lock_drp.c   |  632 ++++++++++
 drivers/drp/lock_drp.h   |   67 +
 include/linux/drp.h      |   22 +
 include/uapi/linux/drp.h |   95 ++
 12 files changed, 6310 insertions(+)
 create mode 100644 drivers/drp/Kconfig
 create mode 100644 drivers/drp/Makefile
 create mode 100644 drivers/drp/drp-core.c
 create mode 100644 drivers/drp/drp-core.h
 create mode 100644 drivers/drp/drp-if.c
 create mode 100644 drivers/drp/drp-reg.h
 create mode 100644 drivers/drp/lock_drp.c
 create mode 100644 drivers/drp/lock_drp.h
 create mode 100644 include/linux/drp.h
 create mode 100644 include/uapi/linux/drp.h

diff --git a/drivers/Kconfig b/drivers/Kconfig
index 04a20db857bab..0ed46ef1228b7 100644
--- a/drivers/Kconfig
+++ b/drivers/Kconfig
@@ -89,6 +89,8 @@ source "drivers/thermal/Kconfig"
 
 source "drivers/watchdog/Kconfig"
 
+source "drivers/drp/Kconfig"
+
 source "drivers/ssb/Kconfig"
 
 source "drivers/bcma/Kconfig"
diff --git a/drivers/Makefile b/drivers/Makefile
index 9fc91d2bbe4c7..a6c27ae23cbd4 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -119,6 +119,7 @@ obj-y				+= power/
 obj-$(CONFIG_HWMON)		+= hwmon/
 obj-$(CONFIG_THERMAL)		+= thermal/
 obj-$(CONFIG_WATCHDOG)		+= watchdog/
+obj-$(CONFIG_DRP)		+= drp/
 obj-$(CONFIG_MD)		+= md/
 obj-$(CONFIG_BT)		+= bluetooth/
 obj-$(CONFIG_ACCESSIBILITY)	+= accessibility/
diff --git a/drivers/drp/Kconfig b/drivers/drp/Kconfig
new file mode 100644
index 0000000000000..2fc4b39a8b678
--- /dev/null
+++ b/drivers/drp/Kconfig
@@ -0,0 +1,29 @@
+#
+# DRP subsystem configuration
+#
+
+menu "DRP/DRP support"
+
+config DRP
+    bool "DRP support"
+    default y
+    help
+      DRP is a peripheral hardware that accelerates image processing.
+      If you want DRP support, you should say Y here.
+
+config DRP_SUPPORT_MULTI_OS
+    bool "Support Multiple OS System"
+    depends on !ARCH_R9A09G056
+    default n
+    help
+        If you want to use multiple OS system (assumed with RTOS), you should say Y here.
+
+config DRP_INIT_SHARED_MEMORY
+    bool "Initialize Shared Memory"
+    depends on !ARCH_R9A09G056
+    default n
+    help
+        If you want to initialize shard memory, you should say Y here.
+        When "Support Multiple OS System" is 'Y', this option is enable.  
+
+endmenu
diff --git a/drivers/drp/Makefile b/drivers/drp/Makefile
new file mode 100644
index 0000000000000..c8570d4faef2f
--- /dev/null
+++ b/drivers/drp/Makefile
@@ -0,0 +1,13 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for DRP-AI/DRP.
+#
+ccflags-y := -Werror
+
+ifdef CONFIG_ARCH_R9A09G056
+CFLAGS_lock_drp.o += -Wall -mno-outline-atomics
+LDFLAGS_lock_drp.o += -lgcc
+obj-$(CONFIG_DRP)	+= drp-core.o drp-if.o lock_drp.o
+else
+obj-$(CONFIG_DRP)	+= drp-core.o drp-if.o
+endif
diff --git a/drivers/drp/drp-core.c b/drivers/drp/drp-core.c
new file mode 100644
index 0000000000000..28af91eaca3c1
--- /dev/null
+++ b/drivers/drp/drp-core.c
@@ -0,0 +1,1664 @@
+/*
+ * Driver for the Renesas RZ/V2H, RZ/V2N DRP unit
+ *
+ * Copyright (C) 2023-2024 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifdef __KERNEL__
+#include <linux/types.h>  /* for stdint */
+#include <asm/io.h>       /* for ioread/iowrite */
+#include <linux/delay.h>  /* for mdelay */
+#include <linux/module.h> /* for MODULE macro */
+#else
+#include <stdint.h>
+#endif
+
+#include "drp-core.h"
+#include "drp-reg.h"
+
+//------------------------------------------------------------------------------------------------------------------
+// Parameter setting
+//------------------------------------------------------------------------------------------------------------------
+#define NUT_VERSION                 "2023.02.24.a"
+
+#define DRP_DFCENA                  (0x1)
+#define DRP_DIVFIX                  (0x02)
+#define DRP_MIN_DIVFIX              (0x02)
+#define DRP_ADDR_RELOCATABLE_ENA    (0x0)
+#define AIMAC_DIVFIX                (0x01)
+#define AIMAC_ADDR_RELOCATABLE_ENA  (0x0)
+#define DRP_ECC_ENA                 (0x1)
+#define DRP_CDCC_PRERE              (0x1)
+#define DRP_CDCC_HFCFGW             (0x1)
+#define INIT_SET_BP_MODE            (0)
+#define INIT_SET_BP_CSTART          (0)
+#define INIT_SET_BP_ITR             (0)
+#define INIT_SET_BP_INST            (0)
+#define STP_ERRINT_STATUS_REG_NUM   (5)
+#define AIMAC_ERRINT_STATUS_REG_NUM (8)
+#define EXDx_ERRINT_STATUS_REG_NUM  (4)
+#define ENABLE_BUILD_SET_DRP_DBGCTRL_FUNC  (0)  // If 0, disable to build set_drp_dbgctrl()
+
+//------------------------------------------------------------------------------------------------------------------
+// Do not change
+//------------------------------------------------------------------------------------------------------------------
+#define DEF_DRP_SIDE                (0)
+#define DEF_AIMAC_SIDE              (1)
+
+
+//------------------------------------------------------------------------------------------------------------------
+// for Linux
+//------------------------------------------------------------------------------------------------------------------
+#ifndef __KERNEL__
+#define ioread32(addr)              (*((volatile uint32_t *)(addr)))
+#define ioread16(addr)              (*((volatile uint16_t *)(addr)))
+#define ioread8(addr)               (*((volatile uint8_t *)(addr)))
+#define iowrite32(value, addr)      (*((volatile uint32_t *)(addr)) = (uint32_t)(value))
+#define iowrite16(value, addr)      (*((volatile uint16_t *)(addr)) = (uint16_t)(value))
+#define iowrite8(value, addr)       (*((volatile uint8_t *)(addr))  = (uint8_t)(value))
+#endif
+
+//------------------------------------------------------------------------------------------------------------------
+// Prototype
+//------------------------------------------------------------------------------------------------------------------
+static void set_drpclkgen_freq(addr_t drp_base_addr, uint32_t bit_divfix, uint32_t bit_dfcena);
+static void start_drp_clk(addr_t drp_base_addr);
+static void stop_drp_clk(addr_t drp_base_addr);
+static void disable_drp_swreset(addr_t drp_base_addr);
+static void enable_drp_swreset(addr_t drp_base_addr);
+static void enable_addr_relocatable_drp(addr_t drp_base_addr, uint64_t* addr);
+static void disable_adrconv_drp(addr_t drp_base_addr);
+static void enable_adrconv_drp(addr_t drp_base_addr);
+#if defined(CONFIG_ARCH_R9A09G056)
+static void disable_addr_relocatable_func(addr_t drp_base_addr, addr_t aimac_base_addr);
+#else
+static void disable_addr_relocatable_func(addr_t drp_base_addr);
+#endif
+static void disable_addr_relocatable(addr_t addr);
+static int32_t stop_desc_prefetch(addr_t dmactl_addr);
+static int32_t dma_stop(addr_t dmactl_addr);
+static void start_drp_dmac(addr_t drp_base_addr);
+static int32_t stop_drp_dmac(addr_t drp_base_addr);
+static int32_t stop_drp_dmacw(addr_t drp_base_addr);
+static void disable_drp_intmask(addr_t drp_base_addr);
+static void enable_drp_intmask(addr_t drp_base_addr);
+static void setdmaoffset_drp(addr_t drp_base_addr);
+static void drp_bootseq_drp(addr_t drp_base_addr, uint32_t *drp_addr_relocatable_tbl);
+static void start_prefetch_drp_drp(addr_t drp_base_addr);
+static int32_t stop_prefetch_drp_drp(addr_t drp_base_addr);
+static void aimac_bootseq(addr_t aimac_base_addr, uint8_t *aimac_addr_relocatable_tbl);
+static void enable_addr_relocatable_aimac(addr_t aimac_base_addr, uint64_t* addr);
+static void disable_adrconv_aimac(addr_t aimac_base_addr);
+static void enable_adrconv_aimac(addr_t aimac_base_addr);
+static void set_drp_desc_drp(addr_t drp_base_addr, uint64_t drp_desc_addr);
+static void set_aimac_desc(addr_t aimac_base_addr, uint64_t cmd_desc_addr, uint64_t param_desc_addr);
+static void start_prefetch_aimac(addr_t aimac_base_addr);
+static int32_t stop_prefetch_aimac(addr_t aimac_base_addr);
+static int32_t aimac_finalize(addr_t aimac_base_addr);
+static void set_aimac_freq(addr_t aimac_base_addr, uint32_t divfix);
+static void start_aimac_dmac(addr_t aimac_base_addr);
+static void disable_aimac_intmask(addr_t aimac_base_addr);
+static int32_t stop_aimac_dmac(addr_t aimac_base_addr);
+static void enable_addr_relocatable(addr_t addr, uint8_t* tbl);
+
+static void set_drp_maxfreq(addr_t drp_base_addr, uint32_t mindiv);
+
+static int32_t loop_w(addr_t raddr, uint32_t exp_data, uint32_t mask);
+static int32_t check_reg(addr_t raddr, uint32_t exp, uint32_t mask0, uint32_t mask1);
+static void cpg_set(addr_t addr, int32_t bit, uint32_t val);
+static int32_t cpg_check(addr_t addr, int32_t bit, uint32_t val);
+#ifndef __KERNEL__
+static void mdelay(uint32_t msecs);
+#endif
+
+const static uint32_t stp_errint_status_reg_tbl[STP_ERRINT_STATUS_REG_NUM] =
+{
+    DRP_ERRINT_STATUS_ADDR, IDIF_EINT_ADDR, ODIF_EINT_ADDR, IDMAC_INTSE_ADDR, ODMAC_INTSE_ADDR,
+};
+
+const static char* stp_errint_status_reg_name_tbl[STP_ERRINT_STATUS_REG_NUM] =
+{
+    "DRP_ERRINT_STATUS","IDIF_EINT", "ODIF_EINT", "IDMAC_INTSE", "ODMAC_INTSE",
+};
+
+//------------------------------------------------------------------------------------------------------------------
+// IF functions
+//------------------------------------------------------------------------------------------------------------------
+int32_t R_DRP_DRP_Open(addr_t drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    drp_bootseq_drp(drp_base_addr, 0);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_AIMAC_Open(addr_t aimac_base_addr, int32_t ch)
+{
+    aimac_bootseq(aimac_base_addr, 0);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_SetAdrConv(addr_t drp_base_addr, int32_t ch, uint64_t* addr)
+{
+
+    disable_adrconv_drp(drp_base_addr);
+    enable_addr_relocatable_drp(drp_base_addr, addr);
+    enable_adrconv_drp(drp_base_addr);
+    
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_AIMAC_SetAdrConv(addr_t aimac_base_addr, int32_t ch, uint64_t* addr)
+{
+
+    disable_adrconv_aimac(aimac_base_addr);
+    enable_addr_relocatable_aimac(aimac_base_addr, addr);
+    enable_adrconv_aimac(aimac_base_addr);
+
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_AIMAC_DisableAdrConv(addr_t aimac_base_addr, int32_t ch, uint64_t* addr)
+{
+    disable_adrconv_aimac(aimac_base_addr);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_ResetDmaoffset(addr_t drp_base_addr, int32_t ch)
+{
+
+    setdmaoffset_drp(drp_base_addr);
+    
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_SetFreq(addr_t drp_base_addr, int32_t ch, uint32_t divfix)
+{
+    set_drp_maxfreq(drp_base_addr, divfix);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_GetLastDescAddr(addr_t drp_base_addr, int32_t page, uint64_t* addr)
+{
+    uint32_t r_data0, addr_conv_en, desc_page, desc_tbl_data;
+    int32_t ret = R_DRP_ERR_REG;
+    /* Check Addr Conv is enabled */
+    addr_conv_en = ioread32(drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL_EN);
+    if( ( addr_conv_en & 0x00000001) == 0x00000001) // Addr conv function is Enabled
+    {
+        /* Get Descriptor address */
+        r_data0 = ioread32(drp_base_addr + STP_DSCC_BADDR + DSCC_DPA_REG);      // Descriptor addr bit0  - 32
+        desc_page = (r_data0 >> 24) & 0xFF;
+        if( desc_page == page ){
+            desc_tbl_data = ioread32(drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL + page * 4);  //'4' means 'sizeof(ADRCONV_TBLn register)'
+            if( (desc_tbl_data & 0x00000071) == 0x00000001)  // Addr conv (each page) is Enabled, and Page size = 16MB
+            {
+                *addr = ((uint64_t)(desc_tbl_data & 0x0000FF00)) << 24 | (desc_tbl_data & 0xFF000000) | (r_data0 & 0x00FFFFFF);
+                ret = R_DRP_SUCCESS;
+            }
+        }
+    }
+
+    return ret;
+}
+
+int32_t R_DRP_DRP_Start(addr_t drp_base_addr, int32_t ch, uint64_t desc)
+{
+    set_drp_desc_drp(drp_base_addr, desc);
+    start_prefetch_drp_drp(drp_base_addr);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_AIMAC_Start(addr_t aimac_base_addr, int32_t ch, uint64_t cmd_desc, uint64_t param_desc)
+{
+    set_aimac_desc(aimac_base_addr, cmd_desc, param_desc);
+    start_prefetch_aimac(aimac_base_addr);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_Stop(addr_t drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    int32_t ret = R_DRP_SUCCESS;
+
+    if (0 != stop_prefetch_drp_drp(drp_base_addr))
+    {
+        ret = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+int32_t R_DRP_AIMAC_Reset(addr_t aimac_base_addr, int32_t ch)
+{
+    int32_t ret = R_DRP_SUCCESS;
+
+    if (0 != stop_prefetch_aimac(aimac_base_addr))
+    {
+        ret = R_DRP_ERR_RESET;
+        goto end;
+    }
+    if (0 != aimac_finalize(aimac_base_addr))
+    {
+        ret = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+int32_t R_DRP_DRP_Nmlint(addr_t drp_base_addr, int32_t ch, drp_odif_intcnto_t *odif_intcnto)
+{
+    uint32_t rdata;
+    rdata = ioread32(drp_base_addr + STP_STPC_BADDR + STPC_INT_STS);
+    
+    if( 1 == ((rdata >> 9) & 1) )
+    {
+        rdata = ioread32(drp_base_addr + STP_ODIF_BADDR + ODIF_INT_REG);
+        iowrite32(rdata,drp_base_addr + STP_ODIF_BADDR + ODIF_INT_REG);
+        rdata = ioread32(drp_base_addr + STP_ODIF_BADDR + ODIF_INT_REG);    //Blank read
+
+        odif_intcnto->ch0 = ioread32(drp_base_addr + STP_ODIF_BADDR + ODIF_INTCNTO0_REG);
+    }
+    else
+    {
+        odif_intcnto->ch0 = 0;
+        odif_intcnto->ch1 = 0;
+        odif_intcnto->ch2 = 0;
+        odif_intcnto->ch3 = 0;
+    }
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_CLR_Nmlint(addr_t drp_base_addr, int32_t ch)
+{
+    return stop_desc_prefetch(drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+void R_DRP_DRP_Errint(addr_t drp_base_addr, int32_t ch)
+{
+    volatile uint32_t dscc_pamon;
+    volatile uint32_t stpc_errint_sts;
+    uint32_t index;
+    volatile uint32_t error_status;
+    volatile uint32_t dummy;
+
+    printk(KERN_ERR "DRP1 Error Interrupt\n");
+
+    dscc_pamon      = ioread32(drp_base_addr   + STP_DSCC_BADDR  + DSCC_PAMON_REG);
+
+    printk(KERN_ERR "DSCC_PAMON : 0x%08X\n",      dscc_pamon);
+
+    stpc_errint_sts = ioread32(drp_base_addr + STP_STPC_ERRINT_STS);
+    printk(KERN_ERR "STPC_ERRINT_STS : 0x%08X\n", stpc_errint_sts);
+
+
+    // Enable interrupt masks to prevent multiple error interrupts.
+    enable_drp_intmask(drp_base_addr);
+
+    /**
+     * 1. Check the processing completion criteria
+     * (1) Identify the interrupt factor and clear the interrupt factor.
+     */
+    for (index = 0; index < STP_ERRINT_STATUS_REG_NUM; index++)
+    {
+        error_status = ioread32(drp_base_addr + stp_errint_status_reg_tbl[index]);
+        iowrite32(error_status, drp_base_addr + stp_errint_status_reg_tbl[index]);
+        dummy = ioread32(drp_base_addr + stp_errint_status_reg_tbl[index]);
+
+        printk(KERN_ERR "%s : 0x%08X\n", stp_errint_status_reg_name_tbl[index], error_status);
+    }
+
+    /**
+     * 2. Stop a prefetch of descriptor
+     * (1) Set the DSCEN field of the DSCC_DCTL register to 0.
+     */
+    iowrite8(0x00, drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+int32_t R_DRP_DRP_RegRead(addr_t drp_base_addr, uint32_t offset, uint32_t* pvalue)
+{
+    int32_t ret;
+
+    if (0 == pvalue)
+    {
+        ret = R_DRP_ERR_INVALID_ARG;
+    }
+    else
+    {
+        *pvalue = ioread32(drp_base_addr + offset);
+        ret = R_DRP_SUCCESS;
+    }
+
+    return ret;
+}
+
+void R_DRP_DRP_RegWrite(addr_t drp_base_addr, uint32_t offset, uint32_t value)
+{
+    iowrite32(value, drp_base_addr + offset);
+}
+
+/** Check whether ACT field of the DSCC_DCTL register is 0.
+ * This function is implemented according to Section 7.2.2 - (2) of UM
+ * `(2) Repeat the reading until the ACT field of the DSCC_DCTL register is 0.`
+ * @param drp_base_addr DRP base address
+ * @return Whether ACT field of the DSCC_DCTL register is 0 or not.
+ * @retval 0 ACT field is 0.
+ * @retval -1 ACT field is not 0.
+ */
+int32_t R_DRP_DRP_IsActFieldOfDsccDctlZero(addr_t drp_base_addr)
+{
+    addr_t dmactl_addr = drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG;
+    uint32_t rdata;
+    uint32_t exp_data = 0x00000000;
+    uint32_t mask = ~(0xFFFFFFFD);
+    int32_t result = -1;
+
+    rdata = ioread32(dmactl_addr);
+    if ((rdata & mask) == (exp_data & mask))
+    {
+        result = 0;
+    }
+
+    return result;
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// CLKGEN module setting
+//------------------------------------------------------------------------------------------------------------------
+
+static void set_drpclkgen_freq(addr_t drp_base_addr, uint32_t bit_divfix, uint32_t bit_dfcena)
+{
+    uint32_t BIT_STBYWT;
+
+    BIT_STBYWT = 0x1;
+    iowrite32(BIT_STBYWT,                       drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_STBYWAIT);
+    iowrite32((bit_divfix << 16) | bit_dfcena,  drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_DIV);
+    BIT_STBYWT = 0x0;
+    iowrite32(BIT_STBYWT,                       drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_STBYWAIT);
+}
+
+static void stop_aimac_clk(addr_t aimac_base_addr)
+{
+    iowrite32(0x00000000, aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + EXD1_STPC_BADDR + STPC_CLKE);
+    iowrite32(0x00000000, aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_CLKE_REG);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Enable/Disable debug function
+//------------------------------------------------------------------------------------------------------------------
+#if ENABLE_BUILD_SET_DRP_DBGCTRL_FUNC
+static void set_drp_dbgctrl(addr_t drp_base_addr)
+{
+    set_drp_maxfreq(drp_base_addr, DRP_MIN_DIVFIX);
+    iowrite32((DRP_CDCC_PRERE << 8) + 0x00000001,   drp_base_addr + DRP_CDCC_DBGCTL);
+    iowrite32(0x00070000 + DRP_CDCC_HFCFGW,         drp_base_addr + DRP_CDCC_CCCTL);
+}
+#endif
+
+static void stop_mclkgen(addr_t aimac_base_addr)
+{
+    uint32_t BIT_MCLKGEN = 0x01;
+
+    iowrite32(0x7F << 16,   aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKSW_CONFIG);
+    iowrite32(BIT_MCLKGEN,  aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKGEN_RST);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Enable/Disable DMA channel clock
+//------------------------------------------------------------------------------------------------------------------
+
+static void start_drp_clk(addr_t drp_base_addr)
+{
+    uint32_t BIT_CMN_CLKE  = 0x1;
+    uint32_t BIT_STBL_CLKE = 0x1;
+    uint32_t BIT_DSCC_CLKE = 0x1;
+    uint32_t BIT_CFGW_CLKE = 0x1;
+    uint32_t BIT_CHOx_CLKE = 0xF;
+    uint32_t BIT_CHIx_CLKE = 0xF;
+
+    iowrite32((BIT_STBL_CLKE << 29) |
+              (BIT_CMN_CLKE  << 28) |
+              (BIT_CHOx_CLKE << 16) |
+              (BIT_DSCC_CLKE <<  9) |
+              (BIT_CFGW_CLKE <<  8) |
+              (BIT_CHIx_CLKE <<  0),    drp_base_addr + STP_STPC_BADDR + STPC_CLKE);
+}
+
+static void stop_drp_clk(addr_t drp_base_addr)
+{
+    uint32_t BIT_CMN_CLKE  = 0x0;
+    uint32_t BIT_STBL_CLKE = 0x0;
+    uint32_t BIT_DSCC_CLKE = 0x0;
+    uint32_t BIT_CFGW_CLKE = 0x0;
+    uint32_t BIT_CHOx_CLKE = 0x0;
+    uint32_t BIT_CHIx_CLKE = 0x0;
+
+    iowrite32(0xFFFFFFFF & ((BIT_STBL_CLKE << 29) |
+                            (BIT_CMN_CLKE  << 28) |
+                            (BIT_CHOx_CLKE << 16) |
+                            (BIT_DSCC_CLKE <<  9) |
+                            (BIT_CFGW_CLKE <<  8) |
+                            (BIT_CHIx_CLKE <<  0)), drp_base_addr + STP_STPC_BADDR + STPC_CLKE);
+}
+
+static void start_aimac_clk(addr_t aimac_base_addr)
+{
+    uint32_t BIT_CMN_CLKE  = 0x1;
+    uint32_t BIT_DSCC_CLKE = 0x1;
+    uint32_t BIT_MCMD_CLKE = 0x1;
+    uint32_t BIT_CHOx_CLKE = 0x3;
+    uint32_t BIT_CHIx_CLKE = 0x3;
+    uint32_t BIT_MCLK_AIM  = 0x1;
+    uint32_t BIT_DCLK_AIM  = 0x1;
+    uint32_t BIT_ACLK_AIM  = 0x1;
+
+    iowrite32((BIT_CMN_CLKE  << 28) |
+              (BIT_CHOx_CLKE << 16) |
+              (BIT_DSCC_CLKE <<  9) |
+              (BIT_MCMD_CLKE <<  2) |
+              (BIT_CHIx_CLKE <<  0),    aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKE);
+
+    iowrite32((BIT_CMN_CLKE  << 28) |
+              (BIT_CHOx_CLKE << 16) |
+              (BIT_CHIx_CLKE <<  0),    aimac_base_addr + EXD1_STPC_BADDR + STPC_CLKE);
+
+    iowrite32((BIT_MCLK_AIM << 2) |
+              (BIT_DCLK_AIM << 1) |
+              (BIT_ACLK_AIM << 0),      aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_CLKE_REG);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Enable/Disable SW reset
+//------------------------------------------------------------------------------------------------------------------
+
+static void disable_drp_swreset(addr_t drp_base_addr)
+{
+    uint32_t BIT_DRP_RST    = 0x0;
+    uint32_t BIT_DRPOIF_RST = 0x0;
+    uint32_t BIT_DRPIIF_RST = 0x0;
+    uint32_t BIT_CMN_RST    = 0x0;
+    uint32_t BIT_STBL_RST   = 0x0;
+    uint32_t BIT_DSCC_RST   = 0x0;
+    uint32_t BIT_CFGW_RST   = 0x0;
+    uint32_t BIT_CHOx_RST   = 0x0;
+    uint32_t BIT_CHIx_RST   = 0x0;
+    
+    iowrite32(0xFFFFFFFF & ((BIT_DRP_RST   << 31) |
+                            (BIT_STBL_RST  << 29) |
+                            (BIT_CMN_RST   << 28) |
+                            (BIT_DRPOIF_RST<< 27) |
+                            (BIT_DRPIIF_RST<< 26) |
+                            (BIT_CHOx_RST  << 16) |
+                            (BIT_DSCC_RST  <<  9) |
+                            (BIT_CFGW_RST  <<  8) |
+                            (BIT_CHIx_RST  <<  0)), drp_base_addr + STP_STPC_BADDR + STPC_SFTRST);
+}
+
+static void enable_drp_swreset(addr_t drp_base_addr)
+{
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_STPC_BADDR + STPC_SFTRST);
+}
+
+static void disable_aimac_swreset(addr_t aimac_base_addr)
+{
+    uint32_t BIT_CMN_RST  = 0x0;
+    uint32_t BIT_DSCC_RST = 0x0;
+    uint32_t BIT_MCMD_RST = 0x0;
+    uint32_t BIT_CHOx_RST = 0x0;
+    uint32_t BIT_CHIx_RST = 0x0;
+    uint32_t BIT_STBL     = 0x1;
+    uint32_t BIT_MAC      = 0x0;
+    uint32_t BIT_PRAM     = 0x0;
+    uint32_t BIT_CMDS     = 0x0;
+    uint32_t BIT_ADMA     = 0x0;
+
+    iowrite32((BIT_CMN_RST  << 28) |
+              (BIT_CHOx_RST << 16) |
+              (BIT_DSCC_RST <<  9) |
+              (BIT_MCMD_RST <<  2) |
+              (BIT_CHIx_RST <<  0), aimac_base_addr + EXD0_STPC_BADDR + STPC_SFTRST);
+    iowrite32((BIT_CMN_RST  << 28) |
+              (BIT_CHOx_RST << 16) |
+              (BIT_CHIx_RST <<  0), aimac_base_addr + EXD1_STPC_BADDR + STPC_SFTRST);
+    iowrite32((BIT_STBL     <<  4) |
+              (BIT_MAC      <<  3) |
+              (BIT_PRAM     <<  2) |
+              (BIT_CMDS     <<  1) |
+              (BIT_ADMA     <<  0), aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_SFTRST_REG);
+}
+
+static void enable_aimac_swreset(addr_t aimac_base_addr)
+{
+    iowrite32(0xB1FF03FF, aimac_base_addr + EXD0_STPC_BADDR + STPC_SFTRST);
+    iowrite32(0xB1FF03FF, aimac_base_addr + EXD1_STPC_BADDR + STPC_SFTRST);
+    iowrite32(0x0000001F, aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_SFTRST_REG);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// AI-MAC individual setting
+//------------------------------------------------------------------------------------------------------------------
+
+static void aimac_inidividual_setting(addr_t aimac_base_addr)
+{
+    uint32_t BIT_EO_CEN = 0x1;
+
+    iowrite32(BIT_EO_CEN << 11, aimac_base_addr + FMBUF_CLK_CTRL);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Address relocatable
+//------------------------------------------------------------------------------------------------------------------
+
+static void enable_addr_relocatable_func(addr_t drp_base_addr, addr_t aimac_base_addr, uint8_t* tbl)
+{
+    if (0 != drp_base_addr)
+    {
+        enable_addr_relocatable(drp_base_addr + STP_ADRCONV_BADDR, tbl);
+    }
+    if (0 != aimac_base_addr)
+    {
+        enable_addr_relocatable(aimac_base_addr + EXD0_ADRCONV_BADDR, tbl);
+    }
+}
+
+static void enable_addr_relocatable(addr_t addr, uint8_t* tbl)
+{
+    if (0 == tbl)
+    {
+        iowrite32(0x00000000, addr + ADRCONV_TBL_EN);
+    }
+    else
+    {
+        uint32_t i;
+        uint32_t BIT_VLD;
+        uint32_t BIT_PG;
+        uint32_t BIT_MAP_ADR_24to31;
+        uint32_t BIT_MAP_ADR_32to39;
+
+        for (i = 0; i < 256; i++)
+        {
+            BIT_VLD            = ((uint32_t)tbl[i * 4 + 0] & 0xFF);
+            BIT_PG             = ((uint32_t)tbl[i * 4 + 1] & 0xFF);
+            BIT_MAP_ADR_24to31 = ((uint32_t)tbl[i * 4 + 2] & 0xFF);
+            BIT_MAP_ADR_32to39 = ((uint32_t)tbl[i * 4 + 3] & 0xFF);
+            iowrite32((BIT_MAP_ADR_24to31 << 24) |
+                      (BIT_MAP_ADR_32to39 <<  8) |
+                      (BIT_PG             <<  4) |
+                      (BIT_VLD            <<  0),   addr + ADRCONV_TBL + i * 4);
+        }
+        iowrite32(0x00000001, addr + ADRCONV_TBL_EN);
+    }
+}
+
+#if defined(CONFIG_ARCH_R9A09G056)
+static void disable_addr_relocatable_func(addr_t drp_base_addr, addr_t aimac_base_addr)
+{
+    if (0 != drp_base_addr)
+    {
+        disable_addr_relocatable(drp_base_addr + STP_ADRCONV_BADDR);
+    }
+    if (0 != aimac_base_addr)
+    {
+        disable_addr_relocatable(aimac_base_addr + EXD0_ADRCONV_BADDR);
+    }
+}
+#else
+static void disable_addr_relocatable_func(addr_t drp_base_addr)
+{
+    if (0 != drp_base_addr)
+    {
+        disable_addr_relocatable(drp_base_addr + STP_ADRCONV_BADDR);
+    }
+}
+#endif
+
+static void disable_addr_relocatable(addr_t addr)
+{
+    iowrite32(0x00000000, addr + ADRCONV_TBL_EN);
+}
+
+static void enable_addr_relocatable_drp(addr_t drp_base_addr, uint64_t* addr)
+{
+    int i;
+
+    for( i=0; i<256; i++ )
+    {
+        uint32_t bit32_24 = (uint32_t)(*addr)       & 0xFF000000;
+        uint32_t bit15_8  = (uint32_t)(*addr >> 24) & 0x0000FF00;
+        uint32_t bit6_4   = 0x00000000;
+        uint32_t bit0     = 0x00000001;
+        iowrite32(bit32_24 | bit15_8 | bit6_4 | bit0, drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL + i*4);
+        addr++;
+    }
+}
+
+static void enable_addr_relocatable_aimac(addr_t aimac_base_addr, uint64_t* addr)
+{
+    int i;
+
+    for( i=0; i<256; i++ )
+    {
+        uint32_t bit32_24 = (uint32_t)(*addr)       & 0xFF000000;
+        uint32_t bit15_8  = (uint32_t)(*addr >> 24) & 0x0000FF00;
+        uint32_t bit6_4   = 0x00000000;
+        uint32_t bit0     = 0x00000001;
+        iowrite32(bit32_24 | bit15_8 | bit6_4 | bit0, aimac_base_addr + EXD0_ADRCONV_BADDR + ADRCONV_TBL + i*4);
+        addr++;
+    }
+}
+
+static void disable_adrconv_drp(addr_t drp_base_addr)
+{
+    iowrite32(0, drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL_EN);
+}
+
+static void disable_adrconv_aimac(addr_t aimac_base_addr)
+{
+    iowrite32(0, aimac_base_addr + EXD0_ADRCONV_BADDR + ADRCONV_TBL_EN);
+}
+
+static void enable_adrconv_drp(addr_t drp_base_addr)
+{
+    iowrite32(1, drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL_EN);
+}
+
+static void enable_adrconv_aimac(addr_t aimac_base_addr)
+{
+    iowrite32(1, aimac_base_addr + EXD0_ADRCONV_BADDR + ADRCONV_TBL_EN);
+}
+
+static void setdmaoffset_drp(addr_t drp_base_addr)
+{
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRCW_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2CW_REG);
+
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRI0_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2I0_REG);
+
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRI1_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2I1_REG);
+
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRI2_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2I2_REG);
+
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRI3_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2I3_REG);
+
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADRO0_REG);
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADR2O0_REG);
+
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADRO1_REG);
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADR2O1_REG);
+
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADRO2_REG);
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADR2O2_REG);
+
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADRO3_REG);
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADR2O3_REG);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Start/Stop prefetch descriptor
+//------------------------------------------------------------------------------------------------------------------
+static int32_t stop_desc_prefetch(addr_t dmactl_addr)
+{
+    iowrite8(0x00, dmactl_addr);
+    return loop_w(dmactl_addr, 0x00000000, 0xFFFFFFFD);
+}
+
+static int32_t dma_stop(addr_t dmactl_addr)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    iowrite8(0x00, dmactl_addr + 0x2);
+    iowrite8(0x00, dmactl_addr + 0x0);
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(dmactl_addr, 0x00080000, 0x00000002, 0x00080000))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(dmactl_addr, 0x00080000, 0x00000002, 0x00080000))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+static void start_drp_dmac(addr_t drp_base_addr)
+{
+    uint32_t BIT_DEN       = 0x1;
+    uint32_t BIT_REQEN     = 0x1;
+    uint32_t BIT_DSEL_DESC = 0x0;
+    uint32_t BIT_DSEL_CMD  = 0x1;
+
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_DESC << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI2_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI3_REG);
+
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO0_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO1_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO2_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO3_REG);
+
+    iowrite32((BIT_REQEN << 18) | (BIT_DEN << 0),                        drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLCW_REG);
+}
+
+static int32_t stop_drp_dmac(addr_t drp_base_addr)
+{
+    int32_t ret = 0;
+
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI2_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI3_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO2_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO3_REG))
+    {
+        goto error_stop;
+    }
+
+    goto end;
+
+error_stop:
+    ret = -1;
+    goto end;
+
+end:
+    return ret;
+}
+
+static int32_t stop_drp_dmacw(addr_t drp_base_addr)
+{
+    addr_t dmactl_addr = drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLCW_REG;
+
+    iowrite8(0x00, dmactl_addr);
+
+    return loop_w(dmactl_addr, 0x00000000, 0xFFFFFFFD);
+}
+
+static void start_aimac_dmac(addr_t aimac_base_addr)
+{
+    uint32_t BIT_DEN   = 0x1;
+    uint32_t BIT_REQEN = 0x1;
+    uint32_t wdata     = (BIT_REQEN << 18) | (BIT_DEN << 0);
+
+    iowrite32(wdata, aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLMCMD_REG);
+    iowrite32(wdata, aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32(wdata, aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32(wdata, aimac_base_addr + EXD1_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32(wdata, aimac_base_addr + EXD1_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32(wdata, aimac_base_addr + EXD0_ODIF_BADDR + ODIF_DMACTLO0_REG);
+    iowrite32(wdata, aimac_base_addr + EXD0_ODIF_BADDR + ODIF_DMACTLO1_REG);
+    iowrite32(wdata, aimac_base_addr + EXD1_ODIF_BADDR + ODIF_DMACTLO0_REG);
+    iowrite32(wdata, aimac_base_addr + EXD1_ODIF_BADDR + ODIF_DMACTLO1_REG);
+
+    iowrite32(wdata, aimac_base_addr + AID0_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32(wdata, aimac_base_addr + AID0_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32(wdata, aimac_base_addr + AID0_IDIF2_BADDR + IDIF_DMACTPCMD_REG);
+    iowrite32(wdata, aimac_base_addr + AID1_IDIF_BADDR + IDIF_DMACTLI0_REG);
+}
+
+static int32_t stop_aimac_dmac(addr_t aimac_base_addr)
+{
+    int32_t ret = 0;
+
+    if (0 != dma_stop(aimac_base_addr + AID0_IDIF2_BADDR + IDIF_DMACTPCMD_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLMCMD_REG))
+    {
+        goto error_stop;
+    }
+
+    if (0 != dma_stop(aimac_base_addr + AID0_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + AID0_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + AID1_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+
+    if (0 != dma_stop(aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD0_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD1_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD1_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD0_ODIF_BADDR + ODIF_DMACTLO0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD0_ODIF_BADDR + ODIF_DMACTLO1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD1_ODIF_BADDR + ODIF_DMACTLO0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(aimac_base_addr + EXD1_ODIF_BADDR + ODIF_DMACTLO1_REG))
+    {
+        goto error_stop;
+    }
+
+    goto end;
+
+error_stop:
+    ret = -1;
+    goto end;
+
+end:
+    return ret;
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// DRP-AI interrupt mask setting
+//------------------------------------------------------------------------------------------------------------------
+static void disable_drp_intmask(addr_t drp_base_addr)
+{
+#if (0 != DRP_ECC_ENA)
+    iowrite32(0x0000073F, drp_base_addr + DRP_ERRINT_ENABLE);
+#else
+    iowrite32(0x00000000, drp_base_addr + DRP_ERRINT_ENABLE);
+    iowrite32(0x00000007, drp_base_addr + DRP_ECC);
+#endif
+
+    iowrite32(0xF8F0F0F0, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFEFEFE, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFF0F0F0, drp_base_addr + STP_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, drp_base_addr + STP_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFC, drp_base_addr + STP_ODMAC_BADDR + ODMAC_INTME_REG);
+
+    iowrite32(0xFFFFFFF0, drp_base_addr + STP_ODIF_BADDR + ODIF_INTMSK_REG);
+
+    // setting ELC0
+    iowrite32(0x0000000F, drp_base_addr + STP_ODIF_BADDR + ODIF_ELCCTL_REG);
+}
+
+static void enable_drp_intmask(addr_t drp_base_addr)
+{
+    // enable normal interrupt
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODIF_BADDR + ODIF_INTMSK_REG);
+
+    // disable DRP error interrupt
+    iowrite32(0x00000000, drp_base_addr + DRP_ERRINT_ENABLE);
+
+    // enable abnormal interrupt
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODMAC_BADDR + ODMAC_INTME_REG);
+
+    // disable ELC0 output
+    iowrite32(0x00000000, drp_base_addr + STP_ODIF_BADDR + ODIF_ELCCTL_REG);
+}
+
+static void disable_aimac_intmask(addr_t aimac_base_addr)
+{
+    // unmask normal interrupt
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_INTMSK_REG);
+    iowrite32(0xFFFFFFFD, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_INTMSK_REG);
+
+    // unmask abnormal interrupt
+    iowrite32(0xFFFCFCFC, aimac_base_addr + AID0_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFEFEFE, aimac_base_addr + AID0_IDIF2_BADDR + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFF8, aimac_base_addr + AID0_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFEFEFE, aimac_base_addr + AID1_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, aimac_base_addr + AID1_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFCFCFC, aimac_base_addr + EXD0_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFBFBFB, aimac_base_addr + EXD0_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFCFCFC, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, aimac_base_addr + EXD0_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFC, aimac_base_addr + EXD0_ODMAC_BADDR + ODMAC_INTME_REG);
+    iowrite32(0xFFFCFCFC, aimac_base_addr + EXD1_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFCFCFC, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, aimac_base_addr + EXD1_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFC, aimac_base_addr + EXD1_ODMAC_BADDR + ODMAC_INTME_REG);
+
+    iowrite32(0xFFFF0FCC, aimac_base_addr + PRAM_INTMSK);
+    iowrite32(0xFFFFFE0C, aimac_base_addr + FMBUF_ERR_MSK);
+    iowrite32(0xFFFFFFF0, aimac_base_addr + MACTOP_MACCTL_ERR_MSK);
+
+    // setup MAC_ELC0 output
+    iowrite32(0x00000003, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_ELCCTL_REG);
+    iowrite32(0x00000003, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_ELCCTL_REG);
+}
+
+static void enable_aimac_intmask(addr_t aimac_base_addr)
+{
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_INTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_INTMSK_REG);
+
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID0_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID0_IDIF2_BADDR + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID0_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID1_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + AID1_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD0_ODMAC_BADDR + ODMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + EXD1_ODMAC_BADDR + ODMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + PRAM_INTMSK);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + FMBUF_ERR_MSK);
+    iowrite32(0xFFFFFFFF, aimac_base_addr + MACTOP_MACCTL_ERR_MSK);
+
+    iowrite32(0x00000000, aimac_base_addr + EXD0_ODIF_BADDR  + ODIF_ELCCTL_REG);
+    iowrite32(0x00000000, aimac_base_addr + EXD1_ODIF_BADDR  + ODIF_ELCCTL_REG);
+}
+
+//==================================================================================================================
+// Initialize (DRP)
+//==================================================================================================================
+static void drp_bootseq_drp(addr_t drp_base_addr, uint32_t *drp_addr_relocatable_tbl)
+{
+    uint32_t BIT_DRPCLKGEN_RST = 0x0;
+
+    // 1. release DRPCLKGEN module reset
+    iowrite32(BIT_DRPCLKGEN_RST, drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_RST);
+
+    // 2. setup DRP clock frequency
+    set_drpclkgen_freq(drp_base_addr, DRP_DIVFIX, DRP_DFCENA);
+
+    // 3. enable DMA channel clock
+    start_drp_clk(drp_base_addr);
+
+    // 4. release soft reset
+    disable_drp_swreset(drp_base_addr);
+
+    // debug on/off
+    // set_drp_dbgctrl(drp_base_addr);
+
+    // 5. initialize SYNCTBL
+    // Not required for V2H
+
+    // 6. setup address relocatable table
+#if defined(CONFIG_ARCH_R9A09G056)
+    disable_addr_relocatable_func(drp_base_addr, 0);
+#else
+    disable_addr_relocatable_func(drp_base_addr);
+#endif
+
+    // 7. setup DMA channel
+    start_drp_dmac(drp_base_addr);
+
+    // 8. unmask interrupt
+    disable_drp_intmask(drp_base_addr);
+}
+
+static void aimac_bootseq(addr_t aimac_base_addr, uint8_t *aimac_addr_relocatable_tbl)
+{
+    uint32_t BIT_MCLKGEN_RST = 0x0;
+
+    // 1. release MCLKGEN module reset
+    iowrite32(BIT_MCLKGEN_RST, aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKGEN_RST);
+
+    // 2. setup AIMAC clock frequency
+    set_aimac_freq(aimac_base_addr, AIMAC_DIVFIX);
+
+    // 3. Supply/Stop clock (initialize multi cycle FF)
+    iowrite32(0x00000007, aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_CLKE_REG);
+    iowrite32(0x00000000, aimac_base_addr + EXD0_DRPIN_M_BADDR + DRPIN_DUMMY); // dummy access
+    iowrite32(0x00000000, aimac_base_addr + CLKRSTCON_BADDR + CLKRSTCON_CLKE_REG);
+
+    // 4. release soft reset
+    disable_aimac_swreset(aimac_base_addr);
+
+    // 5. enable clock
+    start_aimac_clk(aimac_base_addr);
+
+    // 6. AI-MAC version specific setting
+    aimac_inidividual_setting(aimac_base_addr);
+
+    // 7. address relocatable setting
+    enable_addr_relocatable_func(0, aimac_base_addr, aimac_addr_relocatable_tbl);
+
+    // 8. DMA channel setting
+    start_aimac_dmac(aimac_base_addr);
+
+    // 9. unmask interrupt
+    disable_aimac_intmask(aimac_base_addr);
+}
+
+//==================================================================================================================
+// Procedure of DRP/AIMAC
+//==================================================================================================================
+static void set_drp_desc_drp(addr_t drp_base_addr, uint64_t drp_desc_addr)
+{
+    iowrite32(drp_desc_addr & 0xFFFFFFFF, drp_base_addr + STP_DSCC_BADDR + DSCC_DPA_REG);
+    iowrite32(drp_desc_addr >> 32,        drp_base_addr + STP_DSCC_BADDR + DSCC_DPA2_REG);
+}
+
+static void set_aimac_desc(addr_t aimac_base_addr, uint64_t cmd_desc_addr, uint64_t param_desc_addr)
+{
+    iowrite32(cmd_desc_addr   & 0xFFFFFFFF, aimac_base_addr + EXD0_DSCC_BADDR + DSCC_DPA_REG);
+    iowrite32(cmd_desc_addr   >> 32,        aimac_base_addr + EXD0_DSCC_BADDR + DSCC_DPA2_REG);
+    iowrite32(param_desc_addr & 0xFFFFFFFF, aimac_base_addr + AID0_DSCC_BADDR + DSCC_DPA_REG);
+    iowrite32(param_desc_addr >> 32,        aimac_base_addr + AID0_DSCC_BADDR + DSCC_DPA2_REG);
+}
+
+static void start_prefetch_drp_drp(addr_t drp_base_addr)
+{
+    uint32_t BIT_DSCEN = 0x1;
+
+    iowrite32(BIT_DSCEN << 0, drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+static void start_prefetch_aimac(addr_t aimac_base_addr)
+{
+    uint32_t BIT_DSCEN = 0x1;
+
+    iowrite32(BIT_DSCEN << 0, aimac_base_addr + EXD0_DSCC_BADDR + DSCC_DCTLI0_REG);
+    iowrite32(BIT_DSCEN << 0, aimac_base_addr + AID0_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+//==================================================================================================================
+// Stop procedure
+//==================================================================================================================
+static int32_t stop_prefetch_drp_drp(addr_t drp_base_addr)
+{
+    int32_t ret = 0;
+
+    // 1. Stop descriptor prefetch.
+    if( 0 != stop_desc_prefetch(drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 2. Stop writing configuration data.
+    if (0 != stop_drp_dmacw(drp_base_addr))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 3. Mask interrput.
+    enable_drp_intmask(drp_base_addr);
+
+    // 4. Stop data input/output.
+    if (0 != stop_drp_dmac(drp_base_addr))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 5. Disable address relocation table.
+#if defined(CONFIG_ARCH_R9A09G056)
+    disable_addr_relocatable_func(drp_base_addr, 0);
+#else
+    disable_addr_relocatable_func(drp_base_addr);
+#endif
+
+    // 6. Set up DRP core to fixed frequency mode.
+    set_drpclkgen_freq(drp_base_addr, 0x7F, 0x0);
+
+    // 7. Software reset.
+    enable_drp_swreset(drp_base_addr);
+
+    // 8. Stop DMA channel clock.
+    stop_drp_clk(drp_base_addr);
+
+    // 9. Reset DRPCLKGEN module.
+    iowrite32(0x00000001, drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_RST);
+
+    // 10.System reset
+    /* DO NOTHING */
+    goto end;
+
+end:
+    return ret;
+}
+
+static int32_t stop_prefetch_aimac(addr_t aimac_base_addr)
+{
+    int32_t ret = 0;
+
+    // 1. Stop descriptor prefetch.
+    ret = stop_desc_prefetch(aimac_base_addr + AID0_DSCC_BADDR + DSCC_DCTLI0_REG);
+    if (0 != ret)
+    {
+        goto end;
+    }
+    ret = stop_desc_prefetch(aimac_base_addr + EXD0_DSCC_BADDR + DSCC_DCTLI0_REG);
+    if (0 != ret)
+    {
+        goto end;
+    }
+    goto end;
+
+end:
+    return ret;
+}
+
+static int32_t aimac_finalize(addr_t aimac_base_addr)
+{
+    int32_t ret = 0;
+
+    // 2. mask interrupt.
+    enable_aimac_intmask(aimac_base_addr);
+
+    // 3. Stop command input.
+    /* TBD */
+
+    // 4. Stop parameter (weight, bias) input.
+    /* TBD */
+
+    // 5. Forced stop data input/output
+    if (0 != stop_aimac_dmac(aimac_base_addr))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 6. Disable address relocatable table.
+#if defined(CONFIG_ARCH_R9A09G056)
+    disable_addr_relocatable_func(0, aimac_base_addr);
+#else /* This function call has no effect, but it is not called in RZ/V2H. This is a description for common source code. */
+    disable_addr_relocatable_func(0);
+#endif
+
+    // 7. Stop clock.
+    stop_aimac_clk(aimac_base_addr);
+
+    // 8. Software reset.
+    enable_aimac_swreset(aimac_base_addr);
+
+    // 9. Stop MCLKGEN
+    stop_mclkgen(aimac_base_addr);
+
+    goto end;
+
+end:
+    return ret;
+}
+
+int32_t cpg_reset_drp(addr_t cpg_base_addr, int32_t ch)
+{
+    int32_t ret = R_DRP_SUCCESS;
+    int32_t BIT_NUM_RST    = (0 == ch) ? 13 : 12;
+    int32_t BIT_NUM_RSTMON = (0 == ch) ? 14 : 13;
+
+    // Reset on setting.
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, BIT_NUM_RST, 0x0u);
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, BIT_NUM_RSTMON, 0x1u))
+    {
+        ret = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+    // Reset off setting.
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, BIT_NUM_RST, 0x1u);
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, BIT_NUM_RSTMON, 0x0u))
+    {
+        ret = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+//==================================================================================================================
+// Procedure of changing DRP-AI clock (for debug).
+//==================================================================================================================
+static void set_drp_maxfreq(addr_t drp_base_addr, uint32_t mindiv)
+{
+    iowrite32(mindiv, drp_base_addr + DRP_MINDIV);
+}
+
+static void set_aimac_freq(addr_t aimac_base_addr, uint32_t divfix)
+{
+    iowrite32(divfix << 16, aimac_base_addr + EXD0_STPC_BADDR + STPC_CLKSW_CONFIG);
+}
+
+//==================================================================================================================
+// reg check loop
+//==================================================================================================================
+static int32_t loop_w(addr_t raddr, uint32_t exp_data, uint32_t mask)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(raddr, exp_data, ~mask, 0))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(raddr, exp_data, ~mask, 0))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+//==================================================================================================================
+// CPG function
+//==================================================================================================================
+#if defined(CONFIG_ARCH_R9A09G056)
+/* RZ/V2N conditional compilation */
+int32_t initialize_cpg_drp(addr_t cpg_base_addr)
+{
+        int32_t ret = R_DRP_SUCCESS;
+
+    // PLLETH
+    cpg_set(cpg_base_addr + CPG_PLLETH_STBY_REG, 0, 0x1u);
+
+    // PLLETH_MON
+    if (0 != loop_w(cpg_base_addr + CPG_PLLETH_MON_REG, 0x00000010u, 0xFFFFFFEFu))
+    {
+        goto error_init;
+    }
+
+    // MSTOP
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 12, 0x0u);  // DRP_SRAM0
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 13, 0x0u);  // DRP_SRAM1
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 14, 0x0u);  // DRP_SRAM2
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 15, 0x0u);  // DRP_SRAM3
+    cpg_set(cpg_base_addr + CPG_BUS_9_MSTOP_REG,  0, 0x0u);  // DRP_SRAM4
+    cpg_set(cpg_base_addr + CPG_BUS_9_MSTOP_REG,  1, 0x0u);  // DRP_SRAM5
+    cpg_set(cpg_base_addr + CPG_BUS_9_MSTOP_REG,  2, 0x0u);  // DRP_SRAM6
+    cpg_set(cpg_base_addr + CPG_BUS_9_MSTOP_REG,  3, 0x0u);  // DRP_SRAM7
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG,  8, 0x0u);  // AIMAC
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG,  9, 0x0u);  // STP
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 10, 0x0u);  // DRP
+
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 1, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 2, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 3, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 4, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 5, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 6, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 7, 0x0u);
+    cpg_set(cpg_base_addr + CPG_BUS_12_MSTOP_REG, 8, 0x0u);
+
+    // CLK_ON
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG,  8, 0x1u);  // SRAM_0
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG,  9, 0x1u);  // SRAM_1
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 10, 0x1u);  // SRAM_2
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 11, 0x1u);  // SRAM_3
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 12, 0x1u);  // SRAM_4
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 13, 0x1u);  // SRAM_5
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 14, 0x1u);  // SRAM_6
+    cpg_set(cpg_base_addr + CPG_CLKON_1_REG, 15, 0x1u);  // SRAM_7
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 0, 0x1u);  // DRP.DCLKIN
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 1, 0x1u);  // DRP.ACLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 2, 0x1u);  // DRP.INITCLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 3, 0x1u);  // DRPAI.DCLKIN
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 4, 0x1u);  // DRPAI.ACLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 5, 0x1u);  // DRPAI.INITCLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 6, 0x1u);  // DRPAI.MCLK
+
+    // CLK_MON
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 24, 0x1u))  // SRAM_0
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 25, 0x1u))  // SRAM_1
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 26, 0x1u))  // SRAM_2
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 27, 0x1u))  // SRAM_3
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 28, 0x1u))  // SRAM_4
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 29, 0x1u))  // SRAM_5
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 30, 0x1u))  // SRAM_6
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_0_REG, 31, 0x1u))  // SRAM_7
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 16, 0x1u))  // DRP.DCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 17, 0x1u))  // DRP.ACLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 18, 0x1u))  // DRP.INITCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 19, 0x1u))  // DRPAI.DCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 20, 0x1u))  // DRPAI.ACLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 21, 0x1u))  // DRPAI.INITCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 22, 0x1u))  // DRPAI.MCLK
+    {
+        goto error_init;
+    }
+
+    // Reset OFF
+    cpg_set(cpg_base_addr + CPG_RST_3_REG,  14, 0x1u);  // SRAM_0
+    cpg_set(cpg_base_addr + CPG_RST_3_REG,  15, 0x1u);  // SRAM_1
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   0, 0x1u);  // SRAM_2
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   1, 0x1u);  // SRAM_3
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   2, 0x1u);  // SRAM_4
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   3, 0x1u);  // SRAM_5
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   4, 0x1u);  // SRAM_6
+    cpg_set(cpg_base_addr + CPG_RST_4_REG,   5, 0x1u);  // SRAM_7
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, 12, 0x1u);  // DRP.ARESETn
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, 13, 0x1u);  // DRPAI.ARESETn
+
+    // RSTMON
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 15, 0x0u))  // SRAM_0
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 16, 0x0u))  // SRAM_1
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 17, 0x0u))  // SRAM_2
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 18, 0x0u))  // SRAM_3
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 19, 0x0u))  // SRAM_4
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 20, 0x0u))  // SRAM_5
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 21, 0x0u))  // SRAM_6
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_1_REG, 22, 0x0u))  // SRAM_7
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, 13, 0x0u))  // DRP.ARESETn
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, 14, 0x0u))  // DRPAI.ARESETn
+    {
+        goto error_init;
+    }
+
+    goto end;
+
+error_init:
+    ret = R_DRP_ERR_INIT;
+    goto end;
+
+end:
+    return ret;
+}
+#else
+/* RZ/V2H conditional compilation */
+int32_t initialize_cpg_drp(addr_t cpg_base_addr)
+{
+    int32_t ret = R_DRP_SUCCESS;
+
+    // PLLETH
+    cpg_set(cpg_base_addr + CPG_PLLETH_STBY_REG, 0, 0x1u);
+
+    // PLLETH_MON
+    if (0 != loop_w(cpg_base_addr + CPG_PLLETH_MON_REG, 0x00000010u, 0xFFFFFFEFu))
+    {
+        goto error_init;
+    }
+
+    // MSTOP
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 10, 0x0u);  // DRP
+
+    // CLK_ON
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 0, 0x1u);  // DRP.DCLKIN
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 1, 0x1u);  // DRP.ACLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 2, 0x1u);  // DRP.INITCLK
+
+    // CLK_MON
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 16, 0x1u))  // DRP.DCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 17, 0x1u))  // DRP.ACLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 18, 0x1u))  // DRP.INITCLK
+    {
+        goto error_init;
+    }
+                                                       
+    // Reset OFF
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, 12, 0x1u);  // DRP.ARESETn
+
+    // RSTMON
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, 13, 0x0u))  // DRP.ARESETn
+    {
+        goto error_init;
+    }
+
+    goto end;
+
+error_init:
+    ret = R_DRP_ERR_INIT;
+    goto end;
+
+end:
+    return ret;
+
+}
+#endif
+
+static void cpg_set(addr_t addr, int32_t bit, uint32_t val)
+{
+    uint32_t rdata;
+
+    rdata = ioread32(addr);
+    rdata = (rdata >> bit) & 1;
+
+    if (rdata != val)
+    {
+        uint32_t wdata = (1 << (bit + 16)) + (val << bit);
+
+        iowrite32(wdata, addr);
+    }
+}
+
+static int32_t check_reg(addr_t raddr, uint32_t exp, uint32_t mask0, uint32_t mask1)
+{
+    int32_t result = -1;
+    uint32_t rdata = ioread32(raddr);
+
+    if ((0 != mask0) && (0 == mask1))
+    {
+        if ((rdata & mask0) == (exp & mask0))
+        {
+            result = 0;
+        }
+    }
+    else if ((0 == mask0) && (0 != mask1))
+    {
+        if ((rdata & mask1) == (exp & mask1))
+        {
+            result = 0;
+        }
+    }
+    else if ((0 != mask0) && (0 != mask1))
+    {
+        if (((rdata & mask0) == (exp & mask0)) || ((rdata & mask1) == (exp & mask1)))
+        {
+            result = 0;
+        }
+    }
+
+    return result;
+}
+
+static int32_t cpg_check(addr_t addr, int32_t bit, uint32_t val)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(addr, (val << bit), (1 << bit), 0))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(addr, (val << bit), (1 << bit), 0))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+#ifndef __KERNEL__
+/* about 3.9 sec maximum. */
+static void mdelay(uint32_t msecs)
+{
+    volatile uint32_t i;
+
+    for (i = 0; i < msecs * 1100000; i++);
+}
+#endif
+
+#ifdef __KERNEL__
+#if defined(CONFIG_ARCH_R9A09G057)
+/* V2H conditional compilation */
+MODULE_DESCRIPTION("RZ/V2H DRPAI driver");
+#endif
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
+#endif
diff --git a/drivers/drp/drp-core.h b/drivers/drp/drp-core.h
new file mode 100644
index 0000000000000..37f7be375a9f8
--- /dev/null
+++ b/drivers/drp/drp-core.h
@@ -0,0 +1,120 @@
+/*
+ * Driver for the Renesas RZ/V2H, RZ/V2N DRP-AI unit
+ *
+ * Copyright (C) 2023-2024 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef DRP__H
+#define DRP__H
+
+//------------------------------------------------------------------------------------------------------------------
+// include
+//------------------------------------------------------------------------------------------------------------------
+#ifdef __KERNEL__
+#include <linux/types.h>  /* for stdint */
+#else
+#include <stdint.h>
+#endif
+
+//------------------------------------------------------------------------------------------------------------------
+// Macro
+//------------------------------------------------------------------------------------------------------------------
+#define R_DRP_SUCCESS                     (0)
+#define R_DRP_ERR_INVALID_ARG             (-1)
+#define R_DRP_ERR_INIT                    (-2)
+#define R_DRP_ERR_INT                     (-3)
+#define R_DRP_ERR_STOP                    (-4)
+#define R_DRP_ERR_RESET                   (-5)
+#define R_DRP_ERR_REG                     (-6)
+
+/* reserved */
+#define DRP_RESERVED_STP_ODIF_INTCNTO0    (0)
+#define DRP_RESERVED_STP_ODIF_INTCNTO1    (1)
+#define DRP_RESERVED_STP_ODIF_INTCNTO2    (2)
+#define DRP_RESERVED_STP_ODIF_INTCNTO3    (3)
+#define DRP_RESERVED_EXD0_ODIF_INTCNTO0   (4)
+#define DRP_RESERVED_EXD0_ODIF_INTCNTO1   (5)
+#define DRP_RESERVED_EXD1_ODIF_INTCNTO0   (6)
+#define DRP_RESERVED_EXD1_ODIF_INTCNTO1   (7)
+#define DRP_RESERVED_STP_DSCC_PAMON       (8)  /* for debug */
+#define DRP_RESERVED_EXD0_DSCC_PAMON      (9)  /* for debug */
+#define DRP_RESERVED_AID0_DSCC_PAMON      (10) /* for debug */
+#define DRP_RESERVED_STP_ODIF_ELCPLS      (11) /* for debug (initial value) */
+#define DRP_RESERVED_EXD0_ODIF_ELCPLS     (12) /* for debug (initial value) */
+#define DRP_RESERVED_EXD1_ODIF_ELCPLS     (13) /* for debug (initial value) */
+
+/* for CPG reset */
+#define CPG_RESET_SUCCESS                   (0)
+#define RST_MAX_TIMEOUT                     (100)
+
+/* Debug macro (for only kernel) */
+// #define DRP_DRV_DEBUG
+#ifdef DRP_DRV_DEBUG
+#define DRP_DEBUG_PRINT(fmt, ...) \
+            pr_info("[%s: %d](pid: %d) "fmt, \
+                            __func__, __LINE__, current->pid, ##__VA_ARGS__)
+#else
+#define DRP_DEBUG_PRINT(...)
+#endif
+
+//------------------------------------------------------------------------------------------------------------------
+// typedef
+//------------------------------------------------------------------------------------------------------------------
+#ifdef __KERNEL__
+typedef void __iomem* addr_t;
+#else
+typedef uint64_t addr_t;
+#endif
+
+typedef struct drp_odif_intcnto
+{
+    uint32_t    ch0;
+    uint32_t    ch1;
+    uint32_t    ch2;
+    uint32_t    ch3;
+} drp_odif_intcnto_t;
+
+//------------------------------------------------------------------------------------------------------------------
+// Prototype
+//------------------------------------------------------------------------------------------------------------------
+int32_t R_DRP_DRP_Open(addr_t drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRP_DRP_Start(addr_t drp_base_addr, int32_t ch, uint64_t desc);
+int32_t R_DRP_DRP_Stop(addr_t drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRP_DRP_SetMaxFreq(addr_t drp_base_addr, int32_t ch, uint32_t mindiv);
+int32_t R_DRP_DRP_Nmlint(addr_t drp_base_addr, int32_t ch, drp_odif_intcnto_t *odif_intcnto);
+int32_t R_DRP_DRP_CLR_Nmlint(addr_t drp_base_addr, int32_t ch);
+void R_DRP_DRP_Errint(addr_t drp_base_addr, int32_t ch);
+int32_t R_DRP_AIMAC_Open(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_AIMAC_Start(addr_t aimac_base_addr, int32_t ch, uint64_t cmd_desc, uint64_t param_desc);
+int32_t R_DRP_AIMAC_Stop(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_AIMAC_SetFreq(addr_t aimac_base_addr, int32_t ch, uint32_t divfix);
+int32_t R_DRP_AIMAC_Nmlint(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_AIMAC_Errint(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_Status(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch, uint32_t *reserved);
+int32_t R_DRP_AIMAC_Reset(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_DRP_RegRead(addr_t drp_base_addr, uint32_t offset, uint32_t* pvalue);
+void    R_DRP_DRP_RegWrite(addr_t drp_base_addr, uint32_t offset, uint32_t value);
+int32_t R_DRP_AIMAC_RegRead(addr_t aimac_base_addr, uint32_t offset, uint32_t* pvalue);
+void    R_DRP_AIMAC_RegWrite(addr_t aimac_base_addr, uint32_t offset, uint32_t value);
+int32_t R_DRP_DRP_SetAdrConv(addr_t drp_base_addr, int32_t ch, uint64_t* addr);
+int32_t R_DRP_DRP_ResetDmaoffset(addr_t drp_base_addr, int32_t ch);
+int32_t R_DRP_DRP_GetLastDescAddr(addr_t drp_base_addr, int32_t page, uint64_t* addr);
+int32_t R_DRP_SetFreq(addr_t drp_base_addr, int32_t ch, uint32_t divfix);
+int32_t R_DRP_DRP_RegRead(addr_t drp_base_addr, uint32_t offset, uint32_t* pvalue);
+void    R_DRP_DRP_RegWrite(addr_t drp_base_addr, uint32_t offset, uint32_t value);
+int32_t R_DRP_AIMAC_DisableAdrConv(addr_t aimac_base_addr, int32_t ch, uint64_t* addr);
+int32_t R_DRP_AIMAC_SetAdrConv(addr_t aimac_base_addr, int32_t ch, uint64_t* addr);
+int32_t R_DRP_DRP_IsActFieldOfDsccDctlZero(addr_t drp_base_addr);
+int32_t initialize_cpg_drp(addr_t cpg_base_addr);
+
+#endif /* DRP__H */
diff --git a/drivers/drp/drp-if.c b/drivers/drp/drp-if.c
new file mode 100644
index 0000000000000..8abd42e814377
--- /dev/null
+++ b/drivers/drp/drp-if.c
@@ -0,0 +1,2594 @@
+/*
+ * Driver for the Renesas RZ/V2H, RZ/V2N DRP unit
+ *
+ * Copyright (C) 2023-2024 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/cacheflush.h>
+#include <asm/current.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/buffer_head.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/version.h>
+#include <linux/drp.h>    /* Header file for DRP-AI Driver */
+#include "drp-core.h"     /* Header file for DRP-AI Core */
+#include "lock_drp.h"     /* multi OS exclusion control */
+#include <generated/autoconf.h>
+
+// #define DRP_DRV_DEBUG_WAIT
+#ifdef DRP_DRV_DEBUG_WAIT
+#define DRP_DEBUG_WAIT(...) msleep(1100);
+#else
+#define DRP_DEBUG_WAIT(...)
+#endif
+
+#ifdef DRP_DRV_DEBUG
+#define DRP_DRV_DEBUG_MODE        " (Debug Mode ON)"
+#else
+#define DRP_DRV_DEBUG_MODE        ""
+#endif
+
+#ifdef DRP_DRV_DEBUG_WAIT
+#define DRP_DRV_DEBUG_WAIT_MODE   " (Debug Wait Mode ON)"
+#else
+#define DRP_DRV_DEBUG_WAIT_MODE   ""
+#endif
+
+/*Macro definitions*/
+#define SYS_SIZE                    (1024)
+#define SYS_DRP_BANK                (0x38)
+#define SYS_MASK_DRP                (0x00000300)
+#define SYS_SHIFT                   (24)
+
+#define DRP_DRIVER_VERSION        "1.20 rel.4"
+#define DRP_DEV_NUM                (1)
+#define DRP_DRIVER_NAME            "drp"     /* Device name */
+#define DRP_64BYTE_ALIGN           (0x3F)      /* Check 64-byte alignment */
+#define DRP_STATUS_IDLE_RW         (10)
+#define DRP_STATUS_ASSIGN          (11)
+#define DRP_STATUS_READ_MEM        (13)
+#define DRP_STATUS_WRITE           (15)
+
+#define DRP_SGL_DRP_DESC_SIZE      (80)
+#define DRP_DESC_CMD_SIZE          (16)
+#define DRP_SINGLE_DESC_SIZE_BYTE  (64)  // DRP single descriptor size is 64Byte (16byte x 4 descriptor)
+#define DRP_CMA_SIZE               ((DRP_SGL_DRP_DESC_SIZE * DRP_SEQ_NUM) + DRP_DESC_CMD_SIZE + 64)
+
+#define DRP_MAX_PROCESS_CFG        (1)
+#define MAX_SEM_TIMEOUT             (msecs_to_jiffies(1000))
+#define DRP_IRQ_CHECK_ENABLE        (1)
+#define DRP_IRQ_CHECK_DISABLE       (0)
+
+#if 1 /* for CPG direct access (preliminary) */
+#define CPG_SIZE                    (0x10000)
+#define CPG_BASE_ADDRESS            (0x10420000uLL)
+#endif
+
+/* from drp-core.h */
+#define DEVICE_RZV2MA               (0)
+#define DEVICE_RZV2H                (1)
+
+/* preliminary for V2H */
+#undef CONFIG_ARCH_R9A09G011GBG
+#undef CONFIG_ARCH_R9A09G055MA3GBG
+#undef CONFIG_ARCH_R9A07G054
+
+#if defined(CONFIG_ARCH_R9A09G056)
+/* V2N conditional compilation */
+#define DRP_CH_NUM                  (1)
+#define AIMAC_CH_NUM                (1)
+#define ENABLE_DRP_SUPPORT_SHARED_MEMORY
+#undef CONFIG_DRP_SUPPORT_MULTI_OS
+#else
+/* V2H conditional compilation */
+#define DRP_CH_NUM                  (2)
+#endif
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+#define DRP_DRV_USE_SHARED_MEMORY_MODE   " (Use Shared Memory Mode ON)"
+#else
+#define DRP_DRV_USE_SHARED_MEMORY_MODE   ""
+#endif
+
+/* drp device channel no */
+#if defined(CONFIG_ARCH_R9A09G056)
+#define DRP_CH                      (0)     //(V2N) DRP-AI:0
+#else
+#define DRP_CH                      (1)     //(V2H) DRP-AI:0, DRP:1
+#endif
+
+#define VAL_40BIT_OVER  (0x10000000000uLL)
+#define VAL_16M         (0x0000000001000000uLL)
+
+/* A function called from the kernel */
+static int drp_probe(struct platform_device *pdev);
+static int drp_remove(struct platform_device *pdev);
+static int drp_open(struct inode *inode, struct file *file);
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+static void drp_shutdown(struct platform_device *pdev);
+#endif
+static int drp_close(struct inode *inode, struct file *file);
+static int drp_flush(struct file *file, fl_owner_t id);
+static ssize_t  drp_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
+static ssize_t  drp_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+static long drp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg); 
+static unsigned int drp_poll( struct file* filp, poll_table* wait );
+static irqreturn_t irq_drp_nmlint(int irq, void *dev);
+static irqreturn_t irq_drp_errint(int irq, void *dev);
+
+/* Internal function */
+static int drp_regist_driver(void);
+static int drp_regist_device(struct platform_device *pdev);
+static void drp_unregist_driver(void);
+static void drp_unregist_device(void);
+static void drp_init_device(uint32_t ch);
+static int8_t drp_cpg_reset(uint32_t ch);
+static int8_t drp_stop_device(uint32_t ch);
+static long drp_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_get_codec_area(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_get_opencva_area(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_set_drp_freq(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_read_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_write_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+
+static int drp_drp_cpg_init(void);
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+static int drp_flag_test_and_set(unsigned int num);
+static void drp_flag_clear(unsigned int num);
+static int drp_flag_test(unsigned int num);
+#endif
+
+/* Linux device driver initialization */
+static const unsigned int MINOR_BASE = 1;
+static const unsigned int MINOR_NUM  = DRP_DEV_NUM;       /* Minor number */
+static unsigned int drp_major;                    /* Major number (decided dinamically) */
+static struct cdev drp_cdev;                      /* Character device object */
+static struct class *drp_class = NULL;            /* class object */
+struct device *drp_device_array[DRP_DEV_NUM];
+
+/* for 40bit address */
+#define ADR_CONV_MASK   (0x000000FFFF000000uLL)
+#define ADR_LOW_24BIT   (0x00FFFFFFuL)
+#define MAX_IODATA_NUM  (PARAM_ADDRESS_NUM)
+#define ADRCONV_TBL_NUM  (256)
+static uint64_t drp_adrconv_tbl[ADRCONV_TBL_NUM];
+static uint64_t last_drp_config_address = 0;
+
+/* for Config load skip */
+#define LOAD_SKIP_OFFSET    (16)
+
+/* for change DRP frequency */
+#define DRP_DIVFIX_MIN      (2)
+#define DRP_DIVFIX_MAX      (127)
+
+/* for multi OS exclusion control */
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+static unsigned long long *drp_os_exclusion;
+static resource_size_t drp_region_drp_multi_os_base_addr = 0;
+static resource_size_t drp_region_drp_multi_os_size = 0;
+#define DRPFLAG_DRP_USED    (0)
+#define DRPFLAG_DRP_INIT    (1)
+#define DRPFLAG_CLK_STOP    (2)
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+static unsigned long long *drp_shared_exclusion;
+static resource_size_t drp_shared_base_addr = 0;
+static resource_size_t drp_shared_size = 0;
+static DEFINE_SPINLOCK(shared_mem_lock);
+#endif
+static int drp_irqnum_nmlint;
+static int drp_irqnum_errint;
+
+struct drp_priv {
+    struct platform_device *pdev;
+    const char *dev_name;
+    spinlock_t lock;
+    void __iomem *drp_base;
+    struct semaphore sem;
+    uint32_t drp_irq_flag;
+    struct reset_control *rstc;
+    refcount_t count;
+    drp_status_t drp_status;
+    /* Set first proc flag */
+    uint32_t drp_first_proc_after_init;
+};
+
+struct drp_desc_info
+{
+    drp_seq_t seq;
+    char* vaddr;
+    uint64_t phyaddr;
+    uint64_t drp_desc_adr_40bit;
+    uint32_t drp_iodata_num;
+    uint32_t drp_load_force;
+    uint32_t drp_mindiv;
+};
+
+/* Virtual base address of register */
+static void __iomem *drp_base_addr[DRP_CH_NUM];
+#if defined(CONFIG_ARCH_R9A09G056)
+static void __iomem *aimac_base_address[AIMAC_CH_NUM];
+static resource_size_t aimac_size;
+#endif
+
+/* V2H CPG Control */
+#define DRP_CPG_CTL (1)     //for CPG direct access (preliminary)
+#ifdef DRP_CPG_CTL
+static void __iomem *cpg_base_address;
+static resource_size_t cpg_size;
+#endif
+static resource_size_t drp_size;
+
+/* Virtual base address of register */
+static resource_size_t drp_size;
+static resource_size_t drp_region_codec_base_addr = 0;
+static resource_size_t drp_region_codec_size = 0;
+static resource_size_t drp_region_oca_base_addr = 0;
+static resource_size_t drp_region_oca_size = 0;
+
+/* handler table */
+static struct file_operations s_mydevice_fops = {
+    .open           = drp_open,
+    .release        = drp_close,
+    .write          = drp_write,
+    .read           = drp_read,
+    .unlocked_ioctl = drp_ioctl,
+    .compat_ioctl   = drp_ioctl, /* for 32-bit App */
+    .poll           = drp_poll,
+    .flush          = drp_flush,
+};
+
+static const struct of_device_id drp_match[] = {
+
+    { .compatible = "renesas,rzv2ma-drp",},
+    { .compatible = "renesas,rzv2h-drp",},
+    { .compatible = "renesas,rzv2n-drp",},
+    { /* sentinel */ }
+};
+static struct platform_driver drp_platform_driver = {
+    .driver = {
+        .name   = "drp-rz",
+        .of_match_table = drp_match,
+    },
+    .probe      = drp_probe,
+    .remove     = drp_remove,
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    .shutdown   = drp_shutdown,
+#endif
+};
+
+static struct drp_priv *drp_priv;
+static DECLARE_WAIT_QUEUE_HEAD(read_q);
+static DEFINE_SEMAPHORE(rw_sem);
+static drp_data_t drp_data;
+static uint32_t rw_status;
+static uint32_t write_count;
+static uint32_t read_count;
+
+/* DRP single operation */
+static drp_data_t proc[DRP_SEQ_NUM * 2];
+/*DRP Descriptor*/
+// 1. Load drpcfg
+// 2. Set DRP core
+// 3. Read DRP param
+// 4. Start processing of DRP
+// 5. Link descriptor
+// 6. AIMAC descriptor
+static unsigned char drp_single_desc_bin[] =
+{
+  0x00, 0x02, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x07, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x88, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static drp_seq_t seq;
+static drp_odif_intcnto_t odif_intcnto;
+
+static int drp_probe(struct platform_device *pdev)
+{
+    int ret;
+
+    ret = drp_regist_driver();
+    if (0 != ret)
+    {
+        return ret;
+    }
+
+    ret = drp_regist_device(pdev);
+    if (0 != ret)
+    {
+        drp_unregist_driver();
+        return ret;
+    }
+
+    return ret;
+}
+
+static int drp_remove(struct platform_device *pdev)
+{
+    drp_unregist_driver();
+    drp_unregist_device();
+
+    return 0;
+}
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+static void drp_shutdown(struct platform_device *pdev)
+{
+    int flag_ret = 0;
+    DRP_DEBUG_PRINT("start.\n");
+
+    drp_shared_exclusion = phys_to_virt(drp_shared_base_addr);
+    flag_ret = R_DRP_IsSharedMemoryInitialized(drp_shared_exclusion);
+    if(-1 == flag_ret)
+    {
+        // If not cleared shared memory, clear the shared memory
+        if(0 != R_DRP_ClearHashArea(drp_shared_exclusion))
+        {
+            dev_err(&pdev->dev, "Failed to clear the shared memory region. Power off the board to reset the memory and then boot the board again.");
+        }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,1)
+        dcache_clean_inval_poc((unsigned long)drp_shared_exclusion, (unsigned long)drp_shared_exclusion + drp_shared_size);
+#else
+        __flush_dcache_area(drp_shared_exclusion, drp_shared_size);
+#endif
+        dev_info(&pdev->dev, "Shared memory region has cleared.");
+    }
+    else
+    {
+        // If cleared shared memory
+        dev_info(&pdev->dev, "Shared memory region has already cleared.");
+    }
+    
+    DRP_DEBUG_PRINT("end.\n");
+    
+    goto end;
+end:
+    return;
+}
+#endif
+
+static int drp_open(struct inode *inode, struct file *file)
+{
+    int result = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    struct drp_desc_info *desc_info;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    int flag_drp_used = -1;
+    int flag_drp_init = -1;
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    int flag_drp_shared_used = -1;
+    int flag_drp_shared_init = -1;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    DRP_DEBUG_WAIT();
+
+    if(1 == refcount_read(&priv->count))
+    {
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+        /* DRPFLAG_DRP_LOCK is set */
+        flag_drp_shared_used = R_DRP_LockDrpaiContStatus(drp_shared_exclusion,
+                                                         &shared_mem_lock,
+                                                         PROCESS_CONTEXT,
+                                                         DRPFLAG_DRP_LOCK);
+        if(-1 == flag_drp_shared_used)
+        {
+            result = -EINPROGRESS;
+            goto end;
+        }
+        if( 0 != flag_drp_shared_used)
+        {
+            result = -EADDRNOTAVAIL;
+            goto end;
+        }
+#endif
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        flag_drp_used = drp_flag_test_and_set(DRPFLAG_DRP_USED);
+        if( -1 == flag_drp_used)
+        {
+            /* DRPFLAG_DRP_USED is already set */
+            result = -EALREADY;
+            goto end;
+        }
+        if( 0 != flag_drp_used)
+        {
+            /* OS shared memory unavailable */
+            result = -ENODATA;
+            goto end;
+        }
+
+        flag_drp_init = drp_flag_test_and_set(DRPFLAG_DRP_INIT);
+        if( 0 != flag_drp_init)
+        {
+            /* DRPFLAG_DRP_INIT is already set */
+            /* DO NOTHING */
+        }
+        else
+        {
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+        flag_drp_shared_init = R_DRP_IsDrpaiHwStatusActive(drp_shared_exclusion);
+        if(-1 == flag_drp_shared_init)
+        {
+            /* DRP-AI is stopped. therefore, initialize the DRP-AI first */
+#endif
+            /* Initialize CPG (DRP CPG On) */
+            if(R_DRP_SUCCESS != drp_drp_cpg_init())
+            {
+                result = -EIO;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+                drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+                goto end;
+            }
+
+            /* Initialize DRP procedure */
+            drp_init_device(DRP_CH);
+
+            /* Finalize DRP procedure */
+            if(R_DRP_SUCCESS != drp_stop_device(DRP_CH))
+            {
+                result = -EIO;
+                DRP_DEBUG_PRINT("Reset failed\n");
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+                drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+                goto end;
+            }
+            /* Reset DRP (CPG Reset)*/
+            if(R_DRP_SUCCESS != drp_cpg_reset(DRP_CH))
+            {
+                result = -EIO;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+                drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+                goto end;
+            }
+
+            /* Initialize DRP procedure */
+            drp_init_device(DRP_CH);
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+        }
+#endif
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+            drp_flag_clear(DRPFLAG_CLK_STOP);
+        }
+#endif
+
+        /* INIT -> IDLE */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_status.status = DRP_STATUS_IDLE;
+        /* Set first proc flag */
+        priv->drp_first_proc_after_init = 1;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        /* Initialization flag */
+        rw_status = DRP_STATUS_IDLE_RW;
+        
+    }
+
+    desc_info = kzalloc(sizeof(struct drp_desc_info), GFP_KERNEL);
+    if (!desc_info)
+    {
+        result = -ENOMEM;
+        goto end;
+    }
+
+    /* DRP single operation */
+    desc_info->vaddr = NULL;
+    desc_info->phyaddr = 0x0;
+    file->private_data = desc_info;
+    desc_info->drp_mindiv = 2;
+
+    /* Increment reference count */
+    refcount_inc(&priv->count);
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    goto end;
+end:
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    if(0 == result)
+    {
+        R_DRP_RecordDrpaiActiveStatus(drp_shared_exclusion,
+                                      &shared_mem_lock,
+                                      PROCESS_CONTEXT);
+    }
+#endif
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    if( 0 == flag_drp_used)
+    {
+        drp_flag_clear(DRPFLAG_DRP_USED);
+    }
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    if( 0 == flag_drp_shared_used )
+    {
+        R_DRP_UnlockDrpaiContStatus(drp_shared_exclusion,
+                                    &shared_mem_lock,
+                                    PROCESS_CONTEXT,
+                                    DRPFLAG_DRP_LOCK);
+    }
+#endif
+    if((-ETIMEDOUT != result))
+    {
+        up(&priv->sem);
+    }
+
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int drp_close(struct inode *inode, struct file *file)
+{
+    int result = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    int flag_drp_used = -1;
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    int flag_drp_shared_used = -1;
+    int flag_drp_shared_init = -1;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        /* Note: this errno won't be returned to user*/
+        result = -ETIMEDOUT;
+        DRP_DEBUG_PRINT("API semaphore obtained failed\n");
+        goto end;
+    }
+
+    DRP_DEBUG_WAIT();
+
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    if(2 == refcount_read(&priv->count))
+    {
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+        /* DRPFLAG_DRP_LOCK is set */
+        flag_drp_shared_used = R_DRP_LockDrpaiContStatus(drp_shared_exclusion,
+                                                         &shared_mem_lock,
+                                                         PROCESS_CONTEXT,
+                                                         DRPFLAG_DRP_LOCK);
+        if(-1 == flag_drp_shared_used)
+        {
+            result = -EINPROGRESS;
+            goto end;
+        }
+        if( 0 != flag_drp_shared_used)
+        {
+            result = -EADDRNOTAVAIL;
+            goto end;
+        }
+#endif
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        flag_drp_used = drp_flag_test_and_set(DRPFLAG_DRP_USED);
+        if( 0 == flag_drp_used)
+        {
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+        flag_drp_shared_init = R_DRP_IsDrpaiHwStatusActive(drp_shared_exclusion);
+        if(0 == flag_drp_shared_init)
+        {
+            /* The DRP-AI is running. Therefore, stop the DRP-AI first. */
+#endif
+            /* Finalize DRP procedure */
+            if(R_DRP_SUCCESS != drp_stop_device(DRP_CH))
+            {
+                DRP_DEBUG_PRINT("Reset failed\n");
+            }
+            /* Reset DRP (CPG Reset)*/
+            if(R_DRP_SUCCESS != drp_cpg_reset(DRP_CH))
+            {
+                result = -EIO;
+            }
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+            R_DRP_RecordDrpaiInactiveStatus(drp_shared_exclusion,
+                                            &shared_mem_lock,
+                                            PROCESS_CONTEXT);
+        }
+#endif
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+            drp_flag_clear(DRPFLAG_DRP_INIT);
+        }
+#endif
+        /* IDLE -> INIT */
+        /* RUN  -> INIT */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_status.status = DRP_STATUS_INIT;
+        priv->drp_status.err    = DRP_ERRINFO_SUCCESS;
+
+        /* IDLE_RW */
+        rw_status = DRP_STATUS_IDLE_RW;
+        spin_unlock_irqrestore(&priv->lock, flags);
+    }
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    DRP_DEBUG_WAIT();
+
+    goto end;
+end:
+    /* Decrement referenece count */
+    refcount_dec(&priv->count);
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    if( 0 == flag_drp_used)
+    {
+        drp_flag_clear(DRPFLAG_DRP_USED);
+    }
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    if( 0 == flag_drp_shared_used )
+    {
+        R_DRP_UnlockDrpaiContStatus(drp_shared_exclusion,
+                                    &shared_mem_lock,
+                                    PROCESS_CONTEXT,
+                                    DRPFLAG_DRP_LOCK);
+    }
+#endif
+    if((-ETIMEDOUT != result))
+    {
+        up(&priv->sem);
+    if(file->private_data) 
+    {
+        DRP_DEBUG_PRINT("kfree is called\n");
+        kfree(file->private_data);
+        file->private_data = NULL;
+    }
+    }
+
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int drp_flush(struct file *file, fl_owner_t id)
+{
+    DRP_DEBUG_PRINT("start.\n");
+    DRP_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+static ssize_t  drp_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+    ssize_t result = 0;
+    void *p_drp_cma = 0;
+    uint64_t addr;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    DRP_DEBUG_WAIT();
+
+    /* Check status */
+    if (!((DRP_STATUS_ASSIGN == rw_status) || (DRP_STATUS_WRITE == rw_status)))
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check Argument */
+    if (NULL == buf)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if (0 == count)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* DRP_STATUS_ASSIGN -> DRP_STATUS_WRITE */
+    /* DRP_STATUS_WRITE  -> DRP_STATUS_WRITE */
+    rw_status = DRP_STATUS_WRITE;
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    /* Expand to DRP for CMA */
+    addr = (uint64_t)drp_data.address;
+    p_drp_cma = phys_to_virt(addr + (uint64_t)write_count);
+    if (p_drp_cma == 0)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if ( !( drp_data.size >= (write_count + count) ) )
+    {
+        count = drp_data.size - write_count;
+    }
+    if (copy_from_user(p_drp_cma, buf, count))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    write_count = write_count + count;
+
+    /* DRP_STATUS_WRITE -> DRP_STATUS_IDLE_RW */
+    if (drp_data.size <= write_count)
+    {
+        p_drp_cma = phys_to_virt(addr);
+        if (p_drp_cma == 0)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        // Write the data from the cache back to the main memory.
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,1)
+        dcache_clean_inval_poc((unsigned long)p_drp_cma, (unsigned long)p_drp_cma + drp_data.size);
+#else
+        __flush_dcache_area(p_drp_cma, drp_data.size);
+#endif
+        rw_status = DRP_STATUS_IDLE_RW;
+    }
+
+    result = count;
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRP_DEBUG_PRINT("status_rw3:%d\n", rw_status);
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static ssize_t drp_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+    ssize_t result = 0;
+    void *p_drp_cma = 0;
+    uint32_t i;
+    uint64_t addr;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    DRP_DEBUG_WAIT();
+
+    /* Check status */
+    if (!((DRP_STATUS_ASSIGN  == rw_status) ||
+        (DRP_STATUS_READ_MEM  == rw_status)))
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check Argument */
+    if (NULL == buf)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if (0 == count)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* DRP_STATUS_ASSIGN -> DRP_STATUS_READ_MEM */
+    if (DRP_STATUS_ASSIGN == rw_status)
+    {
+        rw_status = DRP_STATUS_READ_MEM;
+    }
+    else
+    {
+        ; /* Do nothing */
+    }
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    /* Read DRP-AI memory */
+    if (DRP_STATUS_READ_MEM == rw_status)
+    {
+        addr = (uint64_t)drp_data.address;
+        p_drp_cma = phys_to_virt(addr + (uint64_t)read_count);
+        if (p_drp_cma == 0)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        if ( !( drp_data.size >= (read_count + count) ) )
+        {
+            count = drp_data.size - read_count;
+        }
+        /* Copy arguments from kernel space to user space */
+        if (copy_to_user(buf, p_drp_cma, count))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        read_count = read_count + count;
+
+        /* DRP_STATUS_READ -> DRP_STATUS_IDLE_RW */
+        if (drp_data.size <= read_count)
+        {
+            rw_status = DRP_STATUS_IDLE_RW;
+        }
+        i = count;
+    }
+    else
+    {
+        ; /* Do nothing */
+    }
+
+    result = i;
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRP_DEBUG_PRINT("status_rw3:%d\n", rw_status);
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+
+    switch (cmd) {
+    case DRP_ASSIGN:
+        DRP_DEBUG_PRINT("ioctl(DRP_ASSIGN)\n");
+        result = drp_ioctl_assign(filp, cmd, arg);
+        break;
+    case DRP_START:
+        DRP_DEBUG_PRINT("ioctl(DRP_START)\n");
+        result = drp_ioctl_start(filp, cmd, arg);
+        break;
+    case DRP_RESET:
+        DRP_DEBUG_PRINT("ioctl(DRP_RESET)\n");
+        result = drp_ioctl_reset(filp, cmd, arg);
+        break;
+    case DRP_GET_STATUS:
+        DRP_DEBUG_PRINT("ioctl(DRP_GET_STATUS)\n");
+        result = drp_ioctl_get_status(filp, cmd, arg);
+        break;
+    case DRP_SET_SEQ:
+        DRP_DEBUG_PRINT("ioctl(DRP_SET_SEQ)\n");
+        result = drp_ioctl_set_seq(filp, cmd, arg);
+        break;
+    case DRP_GET_CODEC_AREA:
+        DRP_DEBUG_PRINT("ioctl(DRP_GET_CODEC_AREA)\n");
+        result = drp_ioctl_get_codec_area(filp, cmd, arg);
+        break;
+    case DRP_GET_OPENCVA_AREA:
+        DRP_DEBUG_PRINT("ioctl(DRP_GET_OPENCVA_AREA)\n");
+        result = drp_ioctl_get_opencva_area(filp, cmd, arg);
+        break;
+    case DRP_SET_DRP_MAX_FREQ:
+        DRP_DEBUG_PRINT("ioctl(DRP_SET_DRP_FREQ)\n");
+        result = drp_ioctl_set_drp_freq(filp, cmd, arg);
+        break;
+    case DRP_READ_DRP_REG:
+        DRP_DEBUG_PRINT("[ioctl(DRP_READ_DRP_REG)]\n");
+        result = drp_ioctl_read_drp_reg(filp, cmd, arg);
+        break;
+    case DRP_WRITE_DRP_REG:
+        DRP_DEBUG_PRINT("[ioctl(DRP_WRITE_DRP_REG)]\n");
+        result = drp_ioctl_write_drp_reg(filp, cmd, arg);
+        break;
+    default:
+        DRP_DEBUG_PRINT("unsupported command %d\n", cmd);
+        result = -EFAULT;
+        break;
+    }
+    goto end;
+
+end:
+    return result;
+}
+
+static unsigned int drp_poll( struct file* filp, poll_table* wait )
+{
+    unsigned int retmask = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    poll_wait( filp, &read_q,  wait );
+
+    if (DRP_IRQ_CHECK_DISABLE == priv->drp_irq_flag)
+    {
+        /* Notify wakeup to user */
+        retmask |= ( POLLIN  | POLLRDNORM );
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("end.\n");
+    return retmask;
+}
+static irqreturn_t irq_drp_nmlint(int irq, void *dev)
+{
+    drp_odif_intcnto_t local_odif_intcnto;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+
+    DRP_DEBUG_PRINT("start.\n");
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+
+    spin_lock_irqsave(&priv->lock, flags);
+
+    /* DRP normal interrupt processing */
+    R_DRP_DRP_Nmlint(drp_base_addr[0], 0, &local_odif_intcnto);
+
+    odif_intcnto.ch0 += local_odif_intcnto.ch0;
+
+    DRP_DEBUG_PRINT("ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
+
+    if (seq.num == odif_intcnto.ch0)
+    {
+        int32_t drp_ret;
+         /* Internal state update */
+        priv->drp_status.status = DRP_STATUS_IDLE;
+        priv->drp_irq_flag  = DRP_IRQ_CHECK_DISABLE;
+
+        /* Wake up the process */
+        drp_ret = R_DRP_DRP_CLR_Nmlint(drp_base_addr[0], 0);
+        if( 0 != drp_ret )
+        {
+            /* Internal state update(ERROR) */
+            priv->drp_status.err    = DRP_ERRINFO_DRP_ERR;
+        }
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        drp_flag_clear(DRPFLAG_DRP_USED);
+#endif
+        wake_up_interruptible( &read_q );
+    }
+    else if(seq.num < odif_intcnto.ch0)
+    {
+        /* Internal state update(ERROR) */
+        priv->drp_status.err    = DRP_ERRINFO_DRP_ERR;
+        priv->drp_status.status = DRP_STATUS_IDLE;
+        priv->drp_irq_flag  = DRP_IRQ_CHECK_DISABLE;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        drp_flag_clear(DRPFLAG_DRP_USED);
+#endif
+        wake_up_interruptible( &read_q );
+    }
+    else
+    {
+        /* DO NOTHING */
+    }
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    R_DRP_UnlockDrpaiContStatus(drp_shared_exclusion,
+                                &shared_mem_lock,
+                                INTERRUPT_CONTEXT,
+                                DRPFLAG_DRP_LOCK);
+#endif
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("end.\n");
+    return IRQ_HANDLED;
+}
+static irqreturn_t irq_drp_errint(int irq, void *dev)
+{
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    irqreturn_t ret = IRQ_HANDLED;
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    int flag_drp_shared_used;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+
+    spin_lock_irqsave(&priv->lock, flags);
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    flag_drp_shared_used = R_DRP_IsDrpaiContStatusLocked(drp_shared_exclusion, DRPFLAG_DRP_LOCK);
+    if(-1 == flag_drp_shared_used)
+    {
+        ret = IRQ_HANDLED;
+        goto end;
+    }
+    if(0 > flag_drp_shared_used)
+    {
+        ret = IRQ_NONE;
+        goto end;
+    }
+#endif
+    /* DRP error interrupt processing */
+    R_DRP_DRP_Errint(drp_base_addr[0], 0);
+
+    /* Internal state update */
+    priv->drp_status.err    = DRP_ERRINFO_DRP_ERR;
+    priv->drp_status.status = DRP_STATUS_IDLE;
+    priv->drp_irq_flag  = DRP_IRQ_CHECK_DISABLE;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    drp_flag_clear(DRPFLAG_DRP_USED);
+#endif
+
+    /* Wake up the process */
+    wake_up_interruptible( &read_q );
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+end:
+    if(0 == flag_drp_shared_used)
+    {
+        R_DRP_UnlockDrpaiContStatus(drp_shared_exclusion,
+                                    &shared_mem_lock,
+                                    INTERRUPT_CONTEXT,
+                                    DRPFLAG_DRP_LOCK);
+    } 
+#endif
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("end.\n");
+    return ret;
+}
+
+static int drp_regist_driver(void)
+{
+    int alloc_ret = 0;
+    int cdev_err = 0;
+    dev_t dev;
+    int minor;
+    int ptr_err;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Get free major number. */
+    alloc_ret = alloc_chrdev_region(&dev, MINOR_BASE, MINOR_NUM, DRP_DRIVER_NAME);
+    if (alloc_ret != 0) {
+        pr_err("DRP Driver: alloc_chrdev_region = %d\n", alloc_ret);
+        return -ENOMEM;
+    }
+
+    /* Save major number. */
+    drp_major = MAJOR(dev);
+    dev = MKDEV(drp_major, MINOR_BASE);
+
+    /* Initialize cdev and registration handler table. */
+    cdev_init(&drp_cdev, &s_mydevice_fops);
+    drp_cdev.owner = THIS_MODULE;
+
+    /* Registration cdev */
+    cdev_err = cdev_add(&drp_cdev, dev, MINOR_NUM);
+    if (cdev_err != 0) {
+        pr_err("DRP Driver: cdev_add = %d\n", cdev_err);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return -ENOMEM;
+    }
+
+    /* Cleate class "/sys/class/drp/" */
+    drp_class = class_create(THIS_MODULE, DRP_DRIVER_NAME);
+    if (IS_ERR(drp_class)) {
+        ptr_err = PTR_ERR(drp_class);
+        pr_err("DRP Driver: class_create = %d\n", ptr_err);
+        cdev_del(&drp_cdev);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return -ENOMEM;
+    }
+
+    /* Make "/sys/class/drp/drp*" */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        drp_device_array[minor - MINOR_BASE] =
+        device_create(drp_class, NULL, MKDEV(drp_major, minor), NULL, DRP_DRIVER_NAME "%d", minor);
+    }
+
+    DRP_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+static int drp_regist_device(struct platform_device *pdev)
+{
+    struct resource *res;
+    struct resource reserved_res;
+    struct device_node *np;
+    int ret;
+    struct drp_priv *priv;
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    int flag_ret;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    priv = devm_kzalloc(&pdev->dev, sizeof(struct drp_priv), GFP_KERNEL);
+    if (!priv) {
+        dev_err(&pdev->dev, "cannot allocate private data\n");
+        return -ENOMEM;
+    }
+
+    /*Initialize DRP private structure*/
+    platform_set_drvdata(pdev, priv);
+    priv->pdev = pdev;
+    priv->dev_name = dev_name(&pdev->dev);
+    spin_lock_init(&priv->lock);
+    sema_init(&priv->sem, DRP_DEV_NUM);
+    priv->drp_irq_flag = DRP_IRQ_CHECK_DISABLE;
+    drp_priv = priv;
+    refcount_set(&priv->count, 1);
+
+    if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2h-drp"))
+    {
+        dev_info(&pdev->dev, "DRP Driver version : %s V2H\n", DRP_DRIVER_VERSION DRP_DRV_DEBUG_MODE DRP_DRV_DEBUG_WAIT_MODE);
+    }
+    else if (of_device_is_compatible(pdev->dev.of_node, "renesas,rzv2n-drp"))
+    {
+        dev_info(&pdev->dev, "DRP Driver version : %s V2N\n", DRP_DRIVER_VERSION DRP_DRV_DEBUG_MODE DRP_DRV_DEBUG_WAIT_MODE DRP_DRV_USE_SHARED_MEMORY_MODE);
+    }
+    else
+    {
+        /* Do Nothing */
+    }
+
+    /* Convert DRP base address from physical to virtual */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+        dev_err(&pdev->dev, "cannot get resources (reg)\n");
+        return -EINVAL;
+    }
+    priv->drp_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!priv->drp_base) {
+        dev_err(&pdev->dev, "cannot ioremap\n");
+        return -EINVAL;
+    }
+    drp_base_addr[0] = priv->drp_base;
+    drp_size = resource_size(res);
+    dev_info(&pdev->dev, "DRP base address 0x%08llX, size 0x%08llX\n", res->start, drp_size);
+
+#if defined(CONFIG_ARCH_R9A09G056)
+    /* Convert AI-MAC base address from physical to virtual */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 1);
+    if (!res) {
+        dev_err(&pdev->dev, "cannot get resources (reg)\n");
+        return -EINVAL;
+    }
+    aimac_base_address[0] = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!aimac_base_address[0]) {
+        dev_err(&pdev->dev, "cannot ioremap\n");
+        return -EINVAL;
+    }
+    aimac_size = resource_size(res);
+    dev_info(&pdev->dev, "AI-MAC base address 0x%016llX, size 0x%016llX\n", res->start, aimac_size);
+#endif
+
+    /* Registering an interrupt handler */
+    drp_irqnum_nmlint = platform_get_irq(pdev, 0);
+    ret = devm_request_irq(&pdev->dev, drp_irqnum_nmlint, irq_drp_nmlint, 0, "drp nmlint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+
+#if defined(CONFIG_ARCH_R9A09G056)
+    /* V2N conditional compilation */
+    drp_irqnum_errint = platform_get_irq(pdev, 1);
+    ret = devm_request_irq(&pdev->dev, drp_irqnum_errint, irq_drp_errint, IRQF_SHARED | IRQF_TRIGGER_HIGH, "drp errint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+#else
+    /* V2H conditional compilation */
+    drp_irqnum_errint = platform_get_irq(pdev, 1);
+    ret = devm_request_irq(&pdev->dev, drp_irqnum_errint, irq_drp_errint, 0, "drp errint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+#endif
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    drp_shared_exclusion = NULL;
+    np = of_parse_phandle(pdev->dev.of_node, "memory-shared-for-drpai-ext-cont", 0);
+    if (!np) 
+    {
+        dev_err(&pdev->dev, "No %s specified\n", "memory-shared-for-drpai-ext-cont");
+        return -ENOMEM;
+    }
+
+    /* Convert memory region to a struct resource */
+    flag_ret = of_address_to_resource(np, 0, &reserved_res);
+    if (flag_ret) 
+    {
+        dev_err(&pdev->dev, "Failed to get shared memory used for DRP-AI exclustion control from device tree\n");
+        return -ENOMEM;
+    }
+
+	drp_shared_base_addr = reserved_res.start;
+    drp_shared_size = resource_size(&reserved_res);
+    dev_info(&pdev->dev, "Shared memory region (DRP-AI exclustion cont.) start 0x%016llX, size 0x%08llX\n", drp_shared_base_addr, drp_shared_size);
+    if(  64 > drp_shared_size )
+    {
+        dev_err(&pdev->dev, "Failed to initialize shared memory region used for DRP-AI exclustion control. It must be greater than or equal to 64byte.\n");
+        return -EINVAL;
+	}
+
+    drp_shared_exclusion = phys_to_virt(drp_shared_base_addr);
+    flag_ret = R_DRP_IsSharedMemoryInitialized(drp_shared_exclusion);
+    if(-1 == flag_ret)
+    {
+        dev_info(&pdev->dev, "Shared memory region has already initialized by another driver.");
+    }
+    else if(0 != flag_ret)
+    {
+        dev_err(&pdev->dev, "Failed to initialize shared memory region used for DRP-AI exclustion control. 'drp_shared_exclusion' variable would be null.\n");
+        return -ENODATA;
+    }
+    else
+    {
+        R_DRP_ClearFlagManagementArea(drp_shared_exclusion);
+        R_DRP_InitializeSharedMemory(drp_shared_exclusion);
+        dev_info(&pdev->dev, "Initilize shared memory region to be used in exclusive control of DRP-AI.");
+    }
+
+#endif
+
+#ifdef DRP_CPG_CTL
+    cpg_size = CPG_SIZE;
+    cpg_base_address = ioremap(CPG_BASE_ADDRESS, cpg_size);
+    if (cpg_base_address == 0)
+    {
+        pr_info("[%s: %d](pid: %d) failed to get cpg_base_address\n", __func__, __LINE__, current->pid);
+        return -EINVAL;
+    }
+#endif
+#ifndef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    /* Get reset controller info */
+    priv->rstc = devm_reset_control_get(&pdev->dev, NULL);
+    if (IS_ERR(priv->rstc))
+    {
+        dev_err(&pdev->dev, "Failed to get DRP CPG reset controller\n");
+#if DRP_CPG_CTL
+        iounmap(cpg_base_address);
+#endif
+        return PTR_ERR(priv->rstc);
+    }
+    else
+    {
+        DRP_DEBUG_PRINT("Get DRP CPG reset controller\n");      
+    } 
+#else
+    flag_ret = R_DRP_LockResetContStatusBit(drp_shared_exclusion, &shared_mem_lock, PROCESS_CONTEXT);
+    if(-1 == flag_ret)
+    {
+        dev_info(&pdev->dev, "Get CPG reset controller which is initilized by another driver.");
+        priv->rstc = R_DRP_GetResetContPointerFromSharedMemory(drp_shared_exclusion);
+    }
+    else if(0 != flag_ret)
+    {
+        dev_info(&pdev->dev, "Failed to lock CPG reset controller bit. 'drp_shared_exclusion' variable is null or 'write control bit' is locked by another driver.");
+#if DRP_CPG_CTL
+        iounmap(cpg_base_address);
+#endif
+        return -EINVAL;
+    }
+    else
+    {
+        /* Get reset controller info */
+        priv->rstc = devm_reset_control_get(&pdev->dev, NULL);
+        if (IS_ERR(priv->rstc))
+        {
+            dev_err(&pdev->dev, "Failed to get DRP CPG reset controller\n");
+            R_DRP_UnlockResetContStatusBit(drp_shared_exclusion, &shared_mem_lock, PROCESS_CONTEXT);
+
+#if DRP_CPG_CTL
+            iounmap(cpg_base_address);
+#endif
+            return PTR_ERR(priv->rstc);
+        }
+
+        dev_info(&pdev->dev, "Set CPG reset controller to shared memory.");
+        R_DRP_SetResetContPointerToSharedMemory(drp_shared_exclusion, priv->rstc);
+    }
+#endif
+
+    /* Status initialization */
+    priv->drp_status.status = DRP_STATUS_INIT;
+
+    {
+
+        drp_region_codec_base_addr = 0;
+        drp_region_codec_size = 0;
+        drp_region_oca_base_addr = 0;
+        drp_region_oca_size = 0;
+
+        np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+        if (!np) 
+        {
+            dev_err(&pdev->dev, "No %s specified\n", "memory-region");
+        }
+        else 
+        {
+           /* Convert memory region to a struct resource */
+            ret = of_address_to_resource(np, 0, &reserved_res);
+            if (ret) 
+            {
+                dev_err(&pdev->dev, "DRP(CODEC) memory was not assigned to the region\n");
+            }
+            else
+            {
+                drp_region_codec_base_addr = reserved_res.start;
+                drp_region_codec_size = resource_size(&reserved_res);
+                dev_info(&pdev->dev, "DRP(CODEC) memory region start 0x%016llX, size 0x%08llX\n", drp_region_codec_base_addr, drp_region_codec_size);
+            }
+        }
+
+        np = of_parse_phandle(pdev->dev.of_node, "memory-oca-region", 0);
+        if (!np) 
+        {
+            dev_err(&pdev->dev, "No %s specified\n", "memory-oca-region");
+        }
+        else 
+        {
+           /* Convert memory region to a struct resource */
+            ret = of_address_to_resource(np, 0, &reserved_res);
+            if (ret) 
+            {
+                dev_err(&pdev->dev, "DRP(OpenCVA) memory was not assigned to the region\n");
+            }
+            else
+            {
+                drp_region_oca_base_addr = reserved_res.start;
+                drp_region_oca_size = resource_size(&reserved_res);
+                dev_info(&pdev->dev, "DRP(OpenCVA) memory region start 0x%016llX, size 0x%08llX\n", drp_region_oca_base_addr, drp_region_oca_size);
+            }
+        }
+        
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        drp_os_exclusion = NULL;
+        np = of_parse_phandle(pdev->dev.of_node, "memory-shared", 0);
+        if (!np) 
+        {
+            dev_err(&pdev->dev, "No %s specified\n", "memory-shared");
+        }
+        else 
+        {
+           /* Convert memory region to a struct resource */
+            ret = of_address_to_resource(np, 0, &reserved_res);
+            if (ret) 
+            {
+                dev_err(&pdev->dev, "DRP(OS shared) memory was not assigned to the region\n");
+            }
+            else
+            {
+                drp_region_drp_multi_os_base_addr = reserved_res.start;
+                drp_region_drp_multi_os_size = resource_size(&reserved_res);
+                dev_info(&pdev->dev, "DRP(OS shared) memory region start 0x%016llX, size 0x%08llX\n", drp_region_drp_multi_os_base_addr, drp_region_drp_multi_os_size);
+                if( drp_region_drp_multi_os_size >= 8 )
+                {
+                    drp_os_exclusion = phys_to_virt(drp_region_drp_multi_os_base_addr);
+#ifdef CONFIG_DRP_INIT_SHARED_MEMORY
+                    *drp_os_exclusion = 0;
+#endif
+                }
+                else
+                {
+                    dev_err(&pdev->dev, "DRP(OS shared) memory is too small\n");
+                }
+            }
+        }
+#endif
+
+    }
+
+    DRP_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+static void drp_unregist_driver(void)
+{
+    dev_t dev = MKDEV(drp_major, MINOR_BASE);
+    int minor;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Delete "/sys/class/mydevice/mydevice*". */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        device_destroy(drp_class, MKDEV(drp_major, minor));
+    }
+
+    /* Destroy "/sys/class/mydevice/". */
+    class_destroy(drp_class);
+
+    /* Delete cdev from kernel. */
+    cdev_del(&drp_cdev);
+
+    /* Unregistration */
+    unregister_chrdev_region(dev, MINOR_NUM);
+    DRP_DEBUG_PRINT("end.\n");
+}
+
+static void drp_unregist_device(void)
+{
+#if DRP_CPG_CTL
+        iounmap(cpg_base_address);
+#endif
+}
+
+static void drp_init_device(uint32_t ch)
+{
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    DRP_DEBUG_PRINT("start.\n");
+
+
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drp_irq_flag = DRP_IRQ_CHECK_DISABLE;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    
+    (void)R_DRP_DRP_Open(drp_base_addr[0], 0, &priv->lock);
+#if defined(CONFIG_ARCH_R9A09G056)
+    (void)R_DRP_AIMAC_Open(aimac_base_address[0], 0);
+#endif
+
+    DRP_DEBUG_PRINT("end.\n");
+}
+
+static long drp_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    void *p_virt_address = 0;
+    uint64_t addr, size;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRP_STATUS_IDLE_RW != rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&drp_data, (void __user *)arg, sizeof(drp_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check Argument */
+    addr = (uint64_t)drp_data.address;
+    size = (uint64_t)drp_data.size;
+    if (0 != (addr & DRP_64BYTE_ALIGN))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    /* Check size over */
+    if (addr >= VAL_40BIT_OVER)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Data cache invalidate. DRP-AI W -> CPU R */
+    addr = (uint64_t)drp_data.address;
+    p_virt_address = phys_to_virt(addr);
+
+    if (p_virt_address == 0)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    // The cache is disabled for the initial access to read from memory.
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,1)
+    dcache_inval_poc((unsigned long)p_virt_address, (unsigned long)p_virt_address + drp_data.size);
+#else
+    __inval_dcache_area(p_virt_address, drp_data.size);
+#endif
+    /* Initialization of read / write processing variables */
+    rw_status   = DRP_STATUS_ASSIGN;
+    write_count = 0;
+    read_count  = 0;
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int result = 0;
+    int i;
+    int j;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    struct drp_desc_info *desc_info = filp->private_data;
+    int adrconv_cnt;
+    char *param_addr;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    int flag_drp_used = -1;
+    int flag_drp_init = -1;
+    int flag_drp_clkstop = -1;
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    int flag_drp_shared_used = -1;
+    int flag_drp_shared_init = -1;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if(NULL == desc_info->vaddr)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRP_STATUS_RUN == priv->drp_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&proc[0], (void __user *)arg, sizeof(proc)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    spin_lock_irqsave(&priv->lock, flags);
+    odif_intcnto.ch0 = 0;
+    odif_intcnto.ch1 = 0;
+    odif_intcnto.ch2 = 0;
+    odif_intcnto.ch3 = 0;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check Argument */
+    for (i = 0; i < (desc_info->seq.num * 2); i++)
+    {
+        if (0 != (proc[i].address & DRP_64BYTE_ALIGN))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if( proc[i].address + proc[i].size >= VAL_40BIT_OVER )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if( proc[i].size > VAL_16M )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if( 0 == proc[i].size )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if( 0 == proc[i].address )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+    }
+
+    /* DRP config address(32bit) and size settings to descriptor */
+    /* (From here on, the code assumes seq.num == 1. It does not support seq.num >= 2.) */
+    *(uint32_t*)(desc_info->vaddr + 4) =  (uint32_t)(proc[0].address & ADR_LOW_24BIT);
+    *(uint32_t*)(desc_info->vaddr + 8) =  proc[0].size;
+
+    /* DRP parameter address(32bit) and size settings to descriptor */
+    *(uint32_t*)(desc_info->vaddr + 20) = (uint32_t)((proc[1].address & ADR_LOW_24BIT) | 0x02000000);
+    *(uint32_t*)(desc_info->vaddr + 24) =  proc[1].size;
+
+    /* LV disable */
+    *(desc_info->vaddr + 51) = 0x0A;
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,1)
+    dcache_clean_inval_poc((unsigned long)desc_info->vaddr, (unsigned long)desc_info->vaddr + DRP_CMA_SIZE);
+#else
+    __flush_dcache_area(desc_info->vaddr, DRP_CMA_SIZE);
+#endif
+
+    /* Set AdrConv Table */
+    /* drp_adrconv_tbl[Page] : 40-bit physical address associated for Page */
+
+    /* Page 00 - 01:For DRP config address */
+    adrconv_cnt = 0;
+    drp_adrconv_tbl[adrconv_cnt++] = proc[0].address & ADR_CONV_MASK;
+    drp_adrconv_tbl[adrconv_cnt++] = drp_adrconv_tbl[0] + VAL_16M;
+
+    /* Page 02 - 03:For DRP parameter address */
+    drp_adrconv_tbl[adrconv_cnt++] = proc[1].address & ADR_CONV_MASK;
+    drp_adrconv_tbl[adrconv_cnt++] = drp_adrconv_tbl[2] + VAL_16M;
+
+    /* Page 04 - 05:For Descriptor address */
+    drp_adrconv_tbl[adrconv_cnt++] = desc_info->drp_desc_adr_40bit & ADR_CONV_MASK;
+    drp_adrconv_tbl[adrconv_cnt++] = drp_adrconv_tbl[4] + VAL_16M;
+
+    /* Page 06 -   :For DRP Input/Output data address in DRP parameters*/
+    param_addr = (char *)phys_to_virt(proc[1].address);
+    for( i = 0; i<desc_info->drp_iodata_num ; i++ )
+    {
+        uint64_t io_adr_start = desc_info->seq.iodata[i].address;
+        uint64_t io_adr_end   = desc_info->seq.iodata[i].address + desc_info->seq.iodata[i].size - 1;
+        uint32_t use_tbl_num  = (io_adr_end >> 24) - (io_adr_start >> 24) + 1;
+        uint32_t set_addr;
+        
+        if( adrconv_cnt + use_tbl_num > ADRCONV_TBL_NUM )
+        {
+            result = -ENOMEM;
+            goto end;
+        }
+        if( desc_info->seq.iodata[i].pos > proc[1].size - 4 )
+        {
+            result = -ENOSPC;
+            goto end;
+        }
+        set_addr = (adrconv_cnt << 24) | (uint32_t)(io_adr_start & ADR_LOW_24BIT);
+        param_addr[desc_info->seq.iodata[i].pos   ] = set_addr         & 0xFF;
+        param_addr[desc_info->seq.iodata[i].pos +1] = (set_addr >> 8)  & 0xFF;
+        param_addr[desc_info->seq.iodata[i].pos +2] = (set_addr >> 16) & 0xFF;
+        param_addr[desc_info->seq.iodata[i].pos +3] = (set_addr >> 24) & 0xFF;
+        for( j = 0; j < use_tbl_num; j++ )
+        {
+            drp_adrconv_tbl[adrconv_cnt++] = (io_adr_start & ADR_CONV_MASK) + j * VAL_16M;
+        }
+    }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,1)
+    dcache_clean_inval_poc((unsigned long)param_addr, (unsigned long)param_addr + proc[1].size);
+#else
+    __flush_dcache_area(param_addr, proc[1].size);
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+        /* DRPFLAG_DRP_LOCK is set */
+        flag_drp_shared_used = R_DRP_LockDrpaiContStatus(drp_shared_exclusion,
+                                                         &shared_mem_lock,
+                                                         PROCESS_CONTEXT,
+                                                         DRPFLAG_DRP_LOCK);
+        if(-1 == flag_drp_shared_used)
+        {
+            result = -EINPROGRESS;
+            goto end;
+        }
+        if( 0 != flag_drp_shared_used)
+        {
+            result = -EADDRNOTAVAIL;
+            goto end;
+        }
+#endif
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    flag_drp_used = drp_flag_test_and_set(DRPFLAG_DRP_USED);
+    if( 0 != flag_drp_used)
+    {
+        /* DRPFLAG_DRP_USED is already set */
+        result = -EALREADY;
+        goto end;
+    }
+
+    flag_drp_init = drp_flag_test_and_set(DRPFLAG_DRP_INIT);
+    if( 0 == flag_drp_init)
+    {
+
+        /* Initialize DRP procedure */
+        drp_init_device(DRP_CH);
+
+        /* Set first proc flag */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_first_proc_after_init = 1;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        drp_flag_clear(DRPFLAG_CLK_STOP);
+    }
+
+    flag_drp_clkstop = drp_flag_test(DRPFLAG_CLK_STOP);
+    if( 0 != flag_drp_clkstop)
+    {
+        /* DRPFLAG_CLK_STOP is already set */
+        result = -EOPNOTSUPP;
+        goto end;
+    }
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    flag_drp_shared_init = R_DRP_IsDrpaiHwStatusActive(drp_shared_exclusion);
+    if(-1 == flag_drp_shared_init)
+    {
+        /* DRP-AI is stopped. Therefore, initialize the DRP-AI first */
+
+        /* Initialize DRP procedure */
+        drp_init_device(DRP_CH);
+
+        /* Set first proc flag */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_first_proc_after_init = 1;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        R_DRP_RecordDrpaiActiveStatus(drp_shared_exclusion,
+                                      &shared_mem_lock,
+                                      PROCESS_CONTEXT);
+    }
+#endif
+
+    /* Check whether DRP-AI is ready or not. */
+    if(0 != R_DRP_DRP_IsActFieldOfDsccDctlZero(drp_base_addr[0]))
+    {
+        result = -EIO;
+        goto end;
+    }
+
+    /* Init drp_status.err */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drp_status.err = DRP_ERRINFO_SUCCESS;
+
+    /* IDLE -> RUN */
+    priv->drp_status.status = DRP_STATUS_RUN;
+    priv->drp_irq_flag  = DRP_IRQ_CHECK_ENABLE;
+    memcpy(&seq, &desc_info->seq, sizeof(drp_seq_t));
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+
+    /* Kick */
+    {
+        uint64_t last_descaddr;
+        uint32_t noload_offset = 0;
+        int32_t drp_ret;
+        uint32_t first_proc;
+        spin_lock_irqsave(&priv->lock, flags);
+        first_proc = priv->drp_first_proc_after_init;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        /* Check first proc */
+        if( first_proc != 0 ){
+            /* LOAD (Executed first time after initialization) */
+        }
+        else if( 0 != desc_info->drp_load_force )
+        {
+            /* LOAD (Forcefully) */
+        }
+        else
+        {
+            /* Get Descriptor Address (from DRP Register) */
+            drp_ret = R_DRP_DRP_GetLastDescAddr(drp_base_addr[0], 4, &last_descaddr);   /* Page 04:Descriptor address page*/
+            if( R_DRP_SUCCESS != drp_ret )
+            {
+                /* LOAD (Descriptor addres could no be obtained) */
+            }
+            else if( ( desc_info->phyaddr == last_descaddr ) || ( desc_info->phyaddr + LOAD_SKIP_OFFSET == last_descaddr ) )
+            {
+                /* Descriptor address matched the last one */
+                if( last_drp_config_address == proc[0].address )
+                {
+                    /* DRP Config address matched the last one */
+                    noload_offset = LOAD_SKIP_OFFSET; /* NOLOAD */
+                }
+            }
+            else
+            {
+                /* LOAD (DRP Config address is not determined) */
+            }
+        }
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        irq_set_affinity( drp_irqnum_nmlint, cpu_online_mask );
+        irq_set_affinity( drp_irqnum_errint, cpu_online_mask );
+        (void)R_DRP_DRP_ResetDmaoffset(drp_base_addr[0], 0);
+#endif
+        (void)R_DRP_DRP_SetAdrConv(drp_base_addr[0], 0, &drp_adrconv_tbl[0]);
+#if defined(CONFIG_ARCH_R9A09G056)
+        (void)R_DRP_AIMAC_DisableAdrConv(aimac_base_address[0], 0, &drp_adrconv_tbl[0]);
+#endif
+
+        (void)R_DRP_SetFreq(drp_base_addr[0], 0, desc_info->drp_mindiv);
+
+        /* Start DRP procedure */
+        (void)R_DRP_DRP_Start(drp_base_addr[0], 0, ((desc_info->phyaddr & ADR_LOW_24BIT) | 0x04000000) + noload_offset);
+#if defined(CONFIG_ARCH_R9A09G056)
+        /* Start AIMAC with dummy descriptor */
+        R_DRP_AIMAC_Start(aimac_base_address[0], 0, 
+                          desc_info->phyaddr + (DRP_SINGLE_DESC_SIZE_BYTE - DRP_DESC_CMD_SIZE), 
+                          desc_info->phyaddr + (DRP_SINGLE_DESC_SIZE_BYTE - DRP_DESC_CMD_SIZE));
+#endif
+
+        /* Clear first proc flag */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_first_proc_after_init = 0;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        /* Backup last config address */
+        last_drp_config_address = proc[0].address;
+    }
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    if( ( 0 == flag_drp_used) && (0 != result) )
+    {
+        drp_flag_clear(DRPFLAG_DRP_USED);
+    }
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    if( ( 0 == flag_drp_shared_used) && (0 != result) )
+    {
+        R_DRP_UnlockDrpaiContStatus(drp_shared_exclusion,
+                                    &shared_mem_lock,
+                                    PROCESS_CONTEXT,
+                                    DRPFLAG_DRP_LOCK);
+    }
+#endif
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    int flag_drp_used = -1;
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    int flag_drp_shared_used = -1;
+    int flag_drp_shared_init = -1;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status1:   %d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    /* DRPFLAG_DRP_LOCK is set */
+    flag_drp_shared_used = R_DRP_LockDrpaiContStatus(drp_shared_exclusion,
+                                                         &shared_mem_lock,
+                                                         PROCESS_CONTEXT,
+                                                         DRPFLAG_DRP_LOCK);
+    if(-1 == flag_drp_shared_used)
+    {
+        result = -EINPROGRESS;
+        goto end;
+    }
+    if( 0 != flag_drp_shared_used)
+    {
+        result = -EADDRNOTAVAIL;
+        goto end;
+    }
+#endif
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    flag_drp_used = drp_flag_test_and_set(DRPFLAG_DRP_USED);
+    if( 0 != flag_drp_used)
+    {
+        /* DRPFLAG_DRP_USED is already set */
+        result = -EALREADY;
+        goto end;
+    }
+    drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    flag_drp_shared_init = R_DRP_IsDrpaiHwStatusActive(drp_shared_exclusion);
+    if(0 == flag_drp_shared_init)
+    {
+        /* The DRP-AI is running. Therefore, stop the DRP-AI first. */
+#endif
+
+    /* Finalize DRP procedure */
+    if(R_DRP_SUCCESS != drp_stop_device(DRP_CH))
+    {
+        result = -EIO;
+        DRP_DEBUG_PRINT("Reset failed\n");
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+        goto end;
+    }
+
+    /* Reset DRP (CPG Reset)*/
+    if(R_DRP_SUCCESS != drp_cpg_reset(DRP_CH))
+    {
+        result = -EIO;
+        goto end;
+    }
+
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+        /* Normally, the DRP-AI status flag in shared memory should be deactivated. 
+           However, for the sake of efficiency, 
+           this function does not perform this deactivation here
+           instead, it remains active. */
+    }
+#endif
+
+    /* Initialize DRP procedure */
+    drp_init_device(DRP_CH);
+
+    /* Set first proc flag */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drp_first_proc_after_init = 1;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    (void)drp_flag_test_and_set(DRPFLAG_DRP_INIT);
+    drp_flag_clear(DRPFLAG_CLK_STOP);
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    R_DRP_RecordDrpaiActiveStatus(drp_shared_exclusion,
+                                  &shared_mem_lock,
+                                  PROCESS_CONTEXT);
+#endif
+    /* Update internal state */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drp_status.err    = DRP_ERRINFO_RESET;
+    priv->drp_status.status = DRP_STATUS_IDLE;
+
+    /* Wake up the process */
+    wake_up_interruptible( &read_q );
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("status2:   %d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    result = 0;
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    if( 0 == flag_drp_used)
+    {
+        drp_flag_clear(DRPFLAG_DRP_USED);
+    }
+#endif
+#ifdef ENABLE_DRP_SUPPORT_SHARED_MEMORY
+    if( 0 == flag_drp_shared_used )
+    {
+        R_DRP_UnlockDrpaiContStatus(drp_shared_exclusion,
+                                    &shared_mem_lock,
+                                    PROCESS_CONTEXT,
+                                    DRPFLAG_DRP_LOCK);
+    }
+#endif
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    drp_status_t local_drp_status;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRP_STATUS_RUN == priv->drp_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+
+    /* Copy arguments from kernel space to user space */
+    local_drp_status = priv->drp_status;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    if (copy_to_user((void __user *)arg, &local_drp_status, sizeof(drp_status_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check DRP H/W error */
+    if (DRP_ERRINFO_DRP_ERR == local_drp_status.err)
+    {
+        result = -EIO;
+        goto end;
+    }
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int8_t drp_cpg_reset(uint32_t ch)
+{
+    int8_t retval = R_DRP_SUCCESS;
+    struct drp_priv *priv = drp_priv;
+    int r_data;
+    int32_t i = 0;
+    bool is_stop = false;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    r_data = reset_control_status(priv->rstc);
+    DRP_DEBUG_PRINT("CPG reset_control_status before %d \n", r_data);
+
+    /* Access reset controller interface */
+    reset_control_reset(priv->rstc);
+
+    /* Check reset status */
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        udelay(1);
+        i++;
+        r_data = reset_control_status(priv->rstc);
+        DRP_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        usleep_range(100, 200);
+        i++;
+        r_data = reset_control_status(priv->rstc);
+        DRP_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    if(true != is_stop)
+    {
+        DRP_DEBUG_PRINT("CPG Reset failed. Reset Control Status: %d\n", r_data);
+        goto err_reset;
+    }
+
+    goto end;
+
+err_reset:
+    retval = R_DRP_ERR_RESET;
+    goto end;
+end:
+    DRP_DEBUG_PRINT("end.\n");
+
+    return retval;
+}
+
+static int8_t drp_stop_device(uint32_t ch)
+{
+    int8_t retval = R_DRP_SUCCESS;
+    struct drp_priv *priv = drp_priv;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Stop DRP */
+    if(R_DRP_SUCCESS != R_DRP_DRP_Stop(drp_base_addr[0], ch, &priv->lock)) 
+    {
+        retval = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+#if defined(CONFIG_ARCH_R9A09G056)
+    /* Stop AIMAC */
+    if(R_DRP_SUCCESS != R_DRP_AIMAC_Reset(aimac_base_address[0], ch))
+    {
+        retval = R_DRP_ERR_RESET;
+        goto end;
+    }
+#endif
+
+    goto end;
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return retval;
+}
+
+static long drp_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    int i;
+    struct drp_priv *priv = drp_priv;
+    struct drp_desc_info *desc_info = filp->private_data;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRP_STATUS_RUN == priv->drp_status.status)
+    {
+        result = -EBUSY;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&desc_info->seq, (void __user *)arg, sizeof(drp_seq_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check Argument DRP Single */
+    if (DRP_MAX_PROCESS_CFG != desc_info->seq.num)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if (0 != (desc_info->seq.address & DRP_64BYTE_ALIGN))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if (desc_info->seq.address >= VAL_40BIT_OVER)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    for (i = 0; i < desc_info->seq.num; i++)
+    {
+        if( (desc_info->seq.order[i] & 0xFF) != DRP_EXE_DRP_40BIT )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+        if( (desc_info->seq.order[i] & DRP_OPMASK_FORCE_LOAD) == 0 )
+        {
+            desc_info->drp_load_force = 0;
+        }
+        else
+        {
+            /* Force Load */
+            desc_info->drp_load_force = 1;
+        }
+    }
+
+    /*Initialize DRPcfg descriptor*/
+    desc_info->phyaddr = (uint64_t)desc_info->seq.address;
+    desc_info->vaddr = (char *)phys_to_virt(desc_info->phyaddr);
+    if (!desc_info->vaddr)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    DRP_DEBUG_PRINT("dmabuf:0x%016llX, dmaphys:0x%016llX\n", desc_info->vaddr, desc_info->phyaddr);
+    /* Deploy drp_single_desc */   
+    for (i = 0; i < DRP_SEQ_NUM; i++)
+    {
+        memcpy(desc_info->vaddr + (DRP_SGL_DRP_DESC_SIZE * i), &drp_single_desc_bin[0], sizeof(drp_single_desc_bin));
+    }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,14,1)
+    dcache_clean_inval_poc((unsigned long)desc_info->vaddr, (unsigned long)desc_info->vaddr + DRP_CMA_SIZE);
+#else
+    __flush_dcache_area(desc_info->vaddr, DRP_CMA_SIZE);
+#endif
+    desc_info->drp_desc_adr_40bit = desc_info->seq.address;
+    desc_info->drp_iodata_num = desc_info->seq.iodata_num;
+    if (desc_info->drp_iodata_num>MAX_IODATA_NUM)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if( desc_info->drp_iodata_num > 0 )
+    {
+        for (i = 0; i < desc_info->drp_iodata_num; i++)
+        {
+            if( desc_info->seq.iodata[i].address + desc_info->seq.iodata[i].size >= VAL_40BIT_OVER )
+            {
+                result = -EINVAL;
+                goto end;
+            }
+            if( desc_info->seq.iodata[i].size == 0 )
+            {
+                result = -EINVAL;
+                goto end;
+            }
+        }
+    }
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+
+    DRP_DEBUG_WAIT();
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+static long drp_ioctl_get_codec_area(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drp_data_t local_drp_data;
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    local_drp_data.address = drp_region_codec_base_addr;
+    local_drp_data.size    = drp_region_codec_size;
+
+    if (copy_to_user((void __user *)arg, &local_drp_data, sizeof(drp_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_get_opencva_area(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drp_data_t local_drp_data;
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    local_drp_data.address = drp_region_oca_base_addr;
+    local_drp_data.size    = drp_region_oca_size;
+
+    if (copy_to_user((void __user *)arg, &local_drp_data, sizeof(drp_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_set_drp_freq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    unsigned int divfix;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    struct drp_desc_info *desc_info = filp->private_data;
+
+    DRP_DEBUG_PRINT("start.\n");
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&divfix, (void __user *)arg, sizeof(unsigned int)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if( (divfix < DRP_DIVFIX_MIN) || (divfix > DRP_DIVFIX_MAX) )
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    /* Get the internal state */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRP_STATUS_RUN == priv->drp_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+    
+    desc_info->drp_mindiv = divfix;
+
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_read_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drp_reg_t drp_reg;
+    int32_t ret;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drp_reg, (void __user *)arg, sizeof(drp_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((drp_size - sizeof(uint32_t)) < drp_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    ret = R_DRP_DRP_RegRead(drp_base_addr[0], drp_reg.offset, &drp_reg.value);
+    if (R_DRP_SUCCESS != ret)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if (copy_to_user((void __user *)arg, &drp_reg, sizeof(drp_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_write_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drp_reg_t drp_reg;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drp_reg, (void __user *)arg, sizeof(drp_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((drp_size - sizeof(uint32_t)) < drp_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    R_DRP_DRP_RegWrite(drp_base_addr[0], drp_reg.offset, drp_reg.value);
+
+    goto end;
+
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int drp_drp_cpg_init(void)
+{
+    int result;
+    DRP_DEBUG_PRINT("start.\n");
+
+    result =  R_DRP_SUCCESS;
+#ifdef DRP_CPG_CTL
+    initialize_cpg_drp(cpg_base_address);
+#else
+    // undefined
+#endif
+    
+    DRP_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+static int drp_flag_test_and_set( unsigned int num )
+{
+    return lock_drp( drp_os_exclusion, num );
+}
+
+static void drp_flag_clear( unsigned int num )
+{
+    unlock_drp( drp_os_exclusion, num );
+}
+
+static int drp_flag_test( unsigned int num )
+{
+    int ret = lock_drp( drp_os_exclusion, num );
+    if( 0 == ret)
+    {
+        unlock_drp( drp_os_exclusion, num );
+    }
+    return ret;
+}
+#endif
+
+module_platform_driver(drp_platform_driver);
+MODULE_DEVICE_TABLE(of, drp_match);
+#if defined(CONFIG_ARCH_R9A09G056)
+/* V2N conditional compilation */
+MODULE_DESCRIPTION("RZ/V2N DRP driver");
+#else
+/* V2H conditional compilation */
+MODULE_DESCRIPTION("RZ/V2H DRP driver");
+#endif
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
+
diff --git a/drivers/drp/drp-reg.h b/drivers/drp/drp-reg.h
new file mode 100644
index 0000000000000..0fff58bffdcf8
--- /dev/null
+++ b/drivers/drp/drp-reg.h
@@ -0,0 +1,1071 @@
+/*
+ * Driver for the Renesas RZ/V2H, RZ/V2N DRP-AI unit
+ *
+ * Copyright (C) 2023-2024 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+//==================================================================================================================
+// DRP-AI
+//==================================================================================================================
+
+#ifndef DRP_REG__H
+#define DRP_REG__H
+
+#define DRP0_BADDR                  (0x17000000uLL)
+#define DRP1_BADDR                  (0x18000000uLL)
+#define AIMAC0_BADDR                (0x16800000uLL)
+
+//==================================================================================================================
+// BaseAddress
+//==================================================================================================================
+// drp core
+#define DRPCORE_BADDR               (0x00000000uLL)
+#define DRPINIF_BADDR               (0x003FE000uLL)
+#define DRPOUTIF_BADDR              (0x003FE800uLL)
+#define CFGLIF_BADDR                (0x003FF000uLL)
+#define DRP_CDCC_BADDR              (0x003FF800uLL)
+
+// spa4dma
+#define STP_DRPIN_BADDR             (0x00F00000uLL)
+#define STP_DRPOUT_BADDR            (0x00F08000uLL)
+#define STP_CFGL_BADDR              (0x00F10000uLL)
+#define STP_DSCC_BADDR              (0x00F18000uLL)
+#define STP_IDIF_BADDR              (0x00F19000uLL)
+#define STP_ODIF_BADDR              (0x00F1A000uLL)
+#define STP_IDMAC_BADDR             (0x00F1B000uLL)
+#define STP_ODMAC_BADDR             (0x00F1C000uLL)
+#define STP_RAC_BADDR               (0x00F1D000uLL)
+#define STP_STPC_BADDR              (0x00F1D800uLL)
+#define STP_SYNCTBL_BADDR           (0x00F1E000uLL)
+#define STP_ADRCONV_BADDR           (0x00F0C000uLL)
+
+// aimac
+#define EXD0_DRPIN_M_BADDR          (0x00000000uLL)
+#define EXD0_DRPOUT_M_BADDR         (0x00008000uLL)
+#define EXD0_ADRCONV_BADDR          (0x0000C000uLL)
+#define EXD0_DSCC_BADDR             (0x00018000uLL)
+#define EXD0_IDIF_BADDR             (0x00019000uLL)
+#define EXD0_ODIF_BADDR             (0x0001A000uLL)
+#define EXD0_IDMAC_BADDR            (0x0001B000uLL)
+#define EXD0_ODMAC_BADDR            (0x0001C000uLL)
+#define EXD0_RAC_BADDR              (0x0001D000uLL)
+#define EXD0_STPC_BADDR             (0x0001D800uLL)
+#define EXD0_DRPIN_A_BADDR          (0x00020000uLL)
+#define EXD0_DRPOUT_A_BADDR         (0x00030000uLL)
+
+#define EXD1_DRPIN_M_BADDR          (0x00040000uLL)
+#define EXD1_DRPOUT_M_BADDR         (0x00048000uLL)
+#define EXD1_IDIF_BADDR             (0x00059000uLL)
+#define EXD1_ODIF_BADDR             (0x0005A000uLL)
+#define EXD1_IDMAC_BADDR            (0x0005B000uLL)
+#define EXD1_ODMAC_BADDR            (0x0005C000uLL)
+#define EXD1_RAC_BADDR              (0x0005D000uLL)
+#define EXD1_STPC_BADDR             (0x0005D800uLL)
+#define EXD1_DRPIN_A_BADDR          (0x00060000uLL)
+#define EXD1_DRPOUT_A_BADDR         (0x00070000uLL)
+
+#define AID0_DRPIN_BADDR            (0x00100000uLL)
+#define AID0_DSCC_BADDR             (0x00118000uLL)
+#define AID0_IDIF_BADDR             (0x00119000uLL)
+#define AID0_IDIF2_BADDR            (0x0011A000uLL)
+#define AID0_IDMAC_BADDR            (0x0011B000uLL)
+#define AID1_DRPIN_BADDR            (0x000C0000uLL)
+#define AID1_DSCC_BADDR             (0x000D8000uLL)
+#define AID1_IDIF_BADDR             (0x000D9000uLL)
+#define AID1_IDIF2_BADDR            (0x000DA000uLL)
+#define AID1_IDMAC_BADDR            (0x000DB000uLL)
+
+#define AID_AREG_BADDR              (0x0011D800uLL)
+#define CMDSEL_BADDR                (0x00140000uLL)
+#define SYNCTBL_BADDR               (0x00140800uLL)
+#define INTMON_BADR                 (0x00141000uLL)
+#define CLKRSTCON_BADDR             (0x00141800uLL)
+#define MAC4K_BASE_ADDRESS          (0x00180000uLL)
+#define MACCTL_BADDR                (0x001C0000uLL)
+#define MACCTL_DCLK_BADDR           (0x001D0000uLL)
+#define FMBUF_BADDR                 (0x001E0000uLL)
+#define PRAM_BADDR                  (0x00200000uLL)
+
+#define EXD0_ODIF_BASE_ADDRESS      (EXD0_ODIF_BADDR)
+#define EXD1_ODIF_BASE_ADDRESS      (EXD1_ODIF_BADDR)
+#define AID0_IDIF_BASE_ADDRESS      (AID0_IDIF_BADDR)
+#define AID0_IDIF2_BASE_ADDRESS     (AID0_IDIF2_BADDR)
+#define AID1_IDIF_BASE_ADDRESS      (AID1_IDIF_BADDR)
+#define AID1_IDIF2_BASE_ADDRESS     (AID1_IDIF2_BADDR)
+
+//==================================================================================================================
+// AreaSize
+//==================================================================================================================
+// drp core
+#define DRPCORE_AREASIZE            (0x3FE000uLL)
+#define DRPINIF_AREASIZE            (0x000800uLL)
+#define DRPOUTIF_AREASIZE           (0x000800uLL)
+#define CFGLIF_AREASIZE             (0x001000uLL)
+// dmac
+#define DRPIN_M_AREASIZE            (0x002000uLL)
+#define DRPOUT_M_AREASIZE           (0x002000uLL)
+#define CFGL_AREASIZE               (0x008000uLL)
+#define DSCC_AREASIZE               (0x001000uLL)
+#define IDIF_AREASIZE               (0x001000uLL)
+#define ODIF_AREASIZE               (0x001000uLL)
+#define IDMAC_AREASIZE              (0x001000uLL)
+#define ODMAC_AREASIZE              (0x001000uLL)
+#define RAC_AREASIZE                (0x000800uLL)
+#define STPC_AREASIZE               (0x000800uLL)
+#define SYNCTBL_AREASIZE            (0x020000uLL)
+#define DRPIN_A_AREASIZE            (0x010000uLL)
+#define DRPOUT_A_AREASIZE           (0x010000uLL)
+
+// aimac
+#define AID_AREG_AREASIZE           (0x000080uLL)
+#define CMDSEL_AREASIZE             (0x000600uLL)
+#define INTMON_AREASIZE             (0x000010uLL)
+#define CLKRSTCON_AREASIZE          (0x000010uLL)
+//#define PRAM_AREASIZE               (0x201000uLL)
+//#define PRAM_AREASIZE               (0x400000uLL)
+#define PRAM_AREASIZE               (0x1000uLL)
+#define MACCTL_AREASIZE             (0x007200uLL)
+
+//==================================================================================================================
+// Address
+//==================================================================================================================
+
+//------------------------------------------------------------------------------------------------------------------
+// DRP
+//------------------------------------------------------------------------------------------------------------------
+#define DRP_MINDIV                  (0x398000uLL)
+#define DRP_ECC                     (0x398038uLL)
+#define DRP_ERRINT_ENABLE           (0x3B0038uLL)
+#define DRP_CDCC_DBGCTL             (0x3FF830uLL)
+#define DRP_CDCC_CCCTL              (0x3FF804uLL)
+
+#define CDCC_CCE                    ((DRP_CDCC_BADDR) + 0x000uLL)
+#define CDCC_CCCTL                  ((DRP_CDCC_BADDR) + 0x004uLL)
+#define CDCC_CFGFWCTL               ((DRP_CDCC_BADDR) + 0x010uLL)
+#define CDCC_DBGCTL                 ((DRP_CDCC_BADDR) + 0x030uLL)
+#define CDCC_DBGCTL2                ((DRP_CDCC_BADDR) + 0x034uLL)
+#define CDCC_PFCNTCTL               ((DRP_CDCC_BADDR) + 0x040uLL)
+#define CDCC_PFCNTCLR               ((DRP_CDCC_BADDR) + 0x044uLL)
+#define CDCC_PFCNTSEL               ((DRP_CDCC_BADDR) + 0x048uLL)
+#define CDCC_PFCNT0                 ((DRP_CDCC_BADDR) + 0x060uLL)
+#define CDCC_PFCNT1                 ((DRP_CDCC_BADDR) + 0x064uLL)
+#define CDCC_PFCNT2                 ((DRP_CDCC_BADDR) + 0x068uLL)
+#define CDCC_PFCNT3                 ((DRP_CDCC_BADDR) + 0x06cuLL)
+#define CDCC_DBGMON                 ((DRP_CDCC_BADDR) + 0x0c0uLL)
+#define CDCC_ECC_MODE               ((DRP_CDCC_BADDR) + 0x0d0uLL)
+#define CDCC_INT_STATUS             ((DRP_CDCC_BADDR) + 0x0e0uLL)
+#define CDCC_ERR_INT_STATUS         ((DRP_CDCC_BADDR) + 0x0e8uLL)
+#define CDCC_INT_MASK               ((DRP_CDCC_BADDR) + 0x0f0uLL)
+#define CDCC_ERR_INT_MASK           ((DRP_CDCC_BADDR) + 0x0f4uLL)
+#define CDCC_CCINFO0                ((DRP_CDCC_BADDR) + 0x100uLL)
+
+#define DRPCORE_REGCLKSEL           (0x3b0018uLL)
+#define DRPCORE_REGPARITYEN         (0x398038uLL)
+#define DRPCORE_REGCFGMREADEN       (0x398040uLL)
+#define DRPCORE_REGCONFIGEN         (0x398048uLL)
+#define DRPCORE_REGRESET            (0x398010uLL)
+#define DRPCORE_REGPRESET           (0x398050uLL)
+#define DRPCORE_REGRUN              (0x398008uLL)
+#define DRPCORE_REGSTATE            (0x398020uLL)
+#define DRPCORE_REGCLEARCOUNT       (0x398060uLL)
+#define DRPCORE_REGCTRLMASK         (0x3b0000uLL)
+#define DRPCORE_REGCODEAWE          (0x3b0010uLL)
+#define DRPCORE_REGINTMODE          (0x3b0028uLL)
+#define DRPCORE_REGINTMASK          (0x3b0030uLL)
+#define DRPCORE_REGERRINTMASK       (0x3b0038uLL)
+#define DRPCORE_INTSTATUS           (0x3b0040uLL)
+#define DRPCORE_ERRINTSTATUS        (0x3b0048uLL)
+#define DRPCORE_REGCHIPMODE         (0x398030uLL)
+#define DRPCORE_VMEMREG             (0x110000uLL)
+#define DRPCORE_REGMINDIV           (0x398000uLL)
+#define DRPCORE_REGFPRND            (0x398058uLL)
+#define DRPCORE_REGCALCERREN        (0x398078uLL)
+
+#define DRPCORE_STCSTATUS           (0x0f8010uLL)  // StcStatus
+#define DRPCORE_STCSTATUS_10        ((DRPCORE_STCSTATUS) + (10uLL << 6)) // StcStatus(Sel=10)
+#define DRPCORE_STCSTATUS_11        ((DRPCORE_STCSTATUS) + (11uLL << 6)) // StcStatus(Sel=11)
+#define DRPCORE_STCSTATUS_12        ((DRPCORE_STCSTATUS) + (12uLL << 6)) // StcStatus(Sel=12)
+#define DRPCORE_STCSTATUS_26        ((DRPCORE_STCSTATUS) + (26uLL << 6)) // StcStatus(Sel=26)
+#define DRPCORE_STCSTATUS_28        ((DRPCORE_STCSTATUS) + (28uLL << 6)) // StcStatus(Sel=28)
+#define DRPCORE_STCSTATUS_34        ((DRPCORE_STCSTATUS) + (34uLL << 6)) // StcStatus(Sel=34)
+
+#define DRPCORE_STCSTBL             (0x280000uLL)  // StcSTbl
+#define DRPCORE_VMEMIU              (0x000000uLL)  // PeIu+VmemIu
+#define DRPCORE_STCIU               (0x0C0000uLL)  // StcIu
+#define DRPCORE_VMEMRFU             (0x100000uLL)  // PeRfu+VmemRfu
+#define DRPCORE_VMEMVMU             (0x120000uLL)  // VmemVmu
+#define DRPCORE_HMEMHMU             (0x180000uLL)  // Hmu
+
+#define DRPCORE_INSEL_RCSIZE        (0x31C500uLL)  // Dout0W0-3_out
+#define DRPCORE_INSEL_RCADDR        (0x31C504uLL)  // Dout0W4-7_out
+#define DRPCORE_INSEL_RCSTRD        (0x31C508uLL)  // Dout1W2-3_out
+#define DRPCORE_INSEL_RCCMD         (0x31C50CuLL)  // Dout1W4-5_out
+
+#define DRPCORE_OUTSEL_DATA0_L      (0x31C700uLL)  // Dout0E0-3_out
+#define DRPCORE_OUTSEL_DATA0_H      (0x31C704uLL)  // Dout0E4-7_out
+#define DRPCORE_OUTSEL_DATA1_L      (0x31C708uLL)  // Dout1E0-3_out
+#define DRPCORE_OUTSEL_DATA1_H      (0x31C70CuLL)  // Dout1E4-7_out
+#define DRPCORE_OUTSEL_STRB         (0x31C714uLL)  // Dout2E4-5_out
+
+//------------------------------------------------------------------------------------------------------------------
+// DSCC
+//------------------------------------------------------------------------------------------------------------------
+#define DSCC_INT_REG                (0x000uLL)
+#define DSCC_DCTLI0_REG             (0x100uLL)
+#define DSCC_DPFC                   (0x104uLL)
+#define DSCC_DPA_REG                (0x108uLL)
+#define DSCC_DPA2_REG               (0x10CuLL)
+#define DSCC_PAMON_REG              (0x118uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// IDMACIF
+//------------------------------------------------------------------------------------------------------------------
+#define IDIF_INT_REG                (0x000uLL)
+#define IDIF_INTMSK_REG             (0x004uLL)
+#define IDIF_EINT_REG               (0x008uLL)
+#define IDIF_EINTMSK_REG            (0x00CuLL)
+#define IDIF_EINT_DSC_REG           (0x010uLL)
+#define IDIF_EINTMSK_DSC_REG        (0x014uLL)
+#define IDIF_DMACTLI0_REG           (0x100uLL)
+#define IDIF_BADRI0_REG             (0x108uLL)
+#define IDIF_BADR2I0_REG            (0x10CuLL)
+#define IDIF_DMACTLI1_REG           (0x200uLL)
+#define IDIF_BADRI1_REG             (0x208uLL)
+#define IDIF_BADR2I1_REG            (0x20CuLL)
+#define IDIF_DMACTLI2_REG           (0x300uLL)
+#define IDIF_BADRI2_REG             (0x308uLL)
+#define IDIF_BADR2I2_REG            (0x30CuLL)
+#define IDIF_DMACTLI3_REG           (0x400uLL)
+#define IDIF_BADRI3_REG             (0x408uLL)
+#define IDIF_BADR2I3_REG            (0x40CuLL)
+#define IDIF_DMACTLI4_REG           (0x500uLL)
+#define IDIF_DMACTLI5_REG           (0x600uLL)
+#define IDIF_DMACTLI6_REG           (0x700uLL)
+#define IDIF_DMACTLI7_REG           (0x800uLL)
+#define IDIF_DMACTLCW_REG           (0x900uLL)
+#define IDIF_BADRCW_REG             (0x908uLL)
+#define IDIF_BADR2CW_REG            (0x90CuLL)
+#define IDIF_DMACTLMCMD_REG         (0x300uLL)
+#define IDIF_DMACTPCMD_REG          (0x100uLL)
+
+#define STP_IDIF_INT_REG            ((STP_IDIF_BADDR) + (IDIF_INT_REG))
+#define STP_IDIF_INTMSK_REG         ((STP_IDIF_BADDR) + (IDIF_INTMSK_REG))
+#define STP_IDIF_EINT_REG           ((STP_IDIF_BADDR) + (IDIF_EINT_REG))
+#define STP_IDIF_EINTMSK_REG        ((STP_IDIF_BADDR) + (IDIF_EINTMSK_REG))
+#define STP_IDIF_EINT_DSC_REG       ((STP_IDIF_BADDR) + (IDIF_EINT_DSC_REG))
+#define STP_IDIF_EINTMSK_DSC_REG    ((STP_IDIF_BADDR) + (IDIF_EINTMSK_DSC_REG))
+#define STP_IDIF_DMACTLI0_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI0_REG))
+#define STP_IDIF_DMACTLI1_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI1_REG))
+#define STP_IDIF_DMACTLI2_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI2_REG))
+#define STP_IDIF_DMACTLI3_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI3_REG))
+#define STP_IDIF_DMACTLI4_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI4_REG))
+#define STP_IDIF_DMACTLI5_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI5_REG))
+#define STP_IDIF_DMACTLI6_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI6_REG))
+#define STP_IDIF_DMACTLI7_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI7_REG))
+#define STP_IDIF_DMACTLCW_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLCW_REG))
+#define STP_IDIF_DMACTLMCMD_REG     ((STP_IDIF_BADDR) + (IDIF_DMACTLMCMD_REG))
+#define STP_IDIF_DMACTPCMD_REG      ((STP_IDIF_BADDR) + (IDIF_DMACTPCMD_REG))
+
+//------------------------------------------------------------------------------------------------------------------
+// ODMACIF
+//------------------------------------------------------------------------------------------------------------------
+#define ODIF_INT_REG                (0x000uLL)
+#define ODIF_INTMSK_REG             (0x004uLL)
+#define ODIF_EINT_REG               (0x008uLL)
+#define ODIF_EINTMSK_REG            (0x00CuLL)
+#define ODIF_DMACTLO0_REG           (0x100uLL)
+#define ODIF_BADRO0_REG             (0x108uLL)
+#define ODIF_BADR2O0_REG            (0x10CuLL)
+#define ODIF_DMACTLO1_REG           (0x200uLL)
+#define ODIF_BADRO1_REG             (0x208uLL)
+#define ODIF_BADR2O1_REG            (0x20CuLL)
+#define ODIF_DMACTLO2_REG           (0x300uLL)
+#define ODIF_BADRO2_REG             (0x308uLL)
+#define ODIF_BADR2O2_REG            (0x30CuLL)
+#define ODIF_DMACTLO3_REG           (0x400uLL)
+#define ODIF_BADRO3_REG             (0x408uLL)
+#define ODIF_BADR2O3_REG            (0x40CuLL)
+#define ODIF_INTCNTO0_REG           (0x118uLL)
+#define ODIF_INTCNTO1_REG           (0x218uLL)
+#define ODIF_INTCNTO2_REG           (0x318uLL)
+#define ODIF_INTCNTO3_REG           (0x418uLL)
+#define ODIF_INTCNTO4_REG           (0x518uLL)
+#define ODIF_INTCNTO5_REG           (0x618uLL)
+#define ODIF_INTCNTO6_REG           (0x718uLL)
+#define ODIF_INTCNTO7_REG           (0x818uLL)
+#define ODIF_INTCNTCR_REG           (0x918uLL)
+#define ODIF_ELCCTL_REG             (0x060uLL)
+#define ODIF_ELCPLS_REG             (0x064uLL)
+#define ODIF_ELCDBG_REG             (0x070uLL)
+#define ODIF_ELCCNT_REG             (0x074uLL)
+#define ODIF_ELCOUT_REG             (0x078uLL)
+
+#define STP_ODIF_INT_REG            ((STP_ODIF_BADDR) + (ODIF_INT_REG))
+#define STP_ODIF_INTMSK_REG         ((STP_ODIF_BADDR) + (ODIF_INTMSK_REG))
+#define STP_ODIF_EINT_REG           ((STP_ODIF_BADDR) + (ODIF_EINT_REG))
+#define STP_ODIF_EINTMSK_REG        ((STP_ODIF_BADDR) + (ODIF_EINTMSK_REG))
+#define STP_ODIF_DMACTLO0_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO0_REG))
+#define STP_ODIF_DMACTLO1_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO1_REG))
+#define STP_ODIF_DMACTLO2_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO2_REG))
+#define STP_ODIF_DMACTLO3_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO3_REG))
+#define STP_ODIF_INTCNTO0_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO0_REG))
+#define STP_ODIF_INTCNTO1_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO1_REG))
+#define STP_ODIF_INTCNTO2_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO2_REG))
+#define STP_ODIF_INTCNTO3_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO3_REG))
+#define STP_ODIF_INTCNTO4_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO4_REG))
+#define STP_ODIF_INTCNTO5_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO5_REG))
+#define STP_ODIF_INTCNTO6_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO6_REG))
+#define STP_ODIF_INTCNTO7_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO7_REG))
+#define STP_ODIF_INTCNTCR_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTCR_REG))
+#define STP_ODIF_ELCCTL_REG         ((STP_ODIF_BADDR) + (ODIF_ELCCTL_REG))
+#define STP_ODIF_ELCPLS_REG         ((STP_ODIF_BADDR) + (ODIF_ELCPLS_REG))
+#define STP_ODIF_ELCDBG_REG         ((STP_ODIF_BADDR) + (ODIF_ELCDBG_REG))
+#define STP_ODIF_ELCCNT_REG         ((STP_ODIF_BADDR) + (ODIF_ELCCNT_REG))
+#define STP_ODIF_ELCOUT_REG         ((STP_ODIF_BADDR) + (ODIF_ELCOUT_REG))
+
+#define EXD1_ODIF_INT_REG           ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INT_REG))
+#define EXD1_ODIF_INTCNTO1_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO1_REG))
+#define EXD1_ODIF_INTCNTO2_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO2_REG))
+#define EXD1_ODIF_INTCNTO3_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO3_REG))
+#define EXD1_ODIF_INTCNTO4_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO4_REG))
+#define EXD1_ODIF_INTCNTO5_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO5_REG))
+#define EXD1_ODIF_INTCNTO6_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO6_REG))
+#define EXD1_ODIF_INTCNTO7_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO7_REG))
+
+//------------------------------------------------------------------------------------------------------------------
+// IDMAC
+//------------------------------------------------------------------------------------------------------------------
+#define IDMAC_INTME_REG             (0x024uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// ODMAC
+//------------------------------------------------------------------------------------------------------------------
+#define ODMAC_INTME_REG             (0x024uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// DRPIN
+//------------------------------------------------------------------------------------------------------------------
+#define DRPIN_DUMMY                 (0x000uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// STPC
+//------------------------------------------------------------------------------------------------------------------
+#define STPC_SFTRST                 (0x000uLL)
+#define STPC_RSTCON_RST             (0x000uLL) // alias for old version
+#define STPC_INT_STS                (0x004uLL)
+#define STPC_ERRINT_STS             (0x008uLL)
+#define STPC_CLKE                   (0x010uLL)
+#define STPC_CLKGEN_RST             (0x040uLL)
+#define STPC_CLKGEN_STBY            (0x044uLL)
+#define STPC_CLKGEN_DIV             (0x048uLL)
+#define STPC_CLKGEN_STS             (0x04CuLL)
+#define STPC_CLKGEN_BYPASS          (0x050uLL)
+#define STPC_CLKGEN_HDIV            (0x054uLL)
+#define STPC_CLKGEN_DIVLAT          (0x058uLL)
+#define STPC_CLKGEN_STBYWAIT        (0x060uLL)
+#define STPC_CLKSW_CONFIG           (0x064uLL)
+#define STPC_CLKSW_CONFIG2          (0x068uLL)
+#define STPC_CLKSW_ACK              (0x06CuLL)
+#define STPC_PFCNTCTL               (0x080uLL)
+#define STPC_PFCNTCLR               (0x084uLL)
+#define STPC_CNT0                   (0x088uLL)
+#define STPC_CNT1                   (0x08CuLL)
+#define STPC_DRPCMD_MSK             (0x0C0uLL)
+#define STPC_MONI0                  (0x100uLL)
+#define STPC_MONI1                  (0x104uLL)
+#define STPC_MONI2                  (0x108uLL)
+#define STPC_MONI3                  (0x10CuLL)
+#define STPC_CTRLPLS0               (0x110uLL)
+#define STPC_CTRLPLS1               (0x114uLL)
+#define STPC_CTRLPLS2               (0x118uLL)
+#define STPC_CTRLPLS3               (0x11CuLL)
+#define STPC_CTRL0                  (0x120uLL)
+#define STPC_CTRL1                  (0x124uLL)
+#define STPC_CTRL2                  (0x128uLL)
+#define STPC_CTRL3                  (0x12CuLL)
+#define STPC_CLKGEN_CTRL            (0x130uLL)
+
+#define STP_STPC_SFTRST             ((STP_STPC_BADDR) + (STPC_SFTRST))
+#define STP_STPC_RSTCON_RST         ((STP_STPC_BADDR) + (STPC_RSTCON_RST))
+#define STP_STPC_INT_STS            ((STP_STPC_BADDR) + (STPC_INT_STS))
+#define STP_STPC_ERRINT_STS         ((STP_STPC_BADDR) + (STPC_ERRINT_STS))
+#define STP_STPC_CLKE               ((STP_STPC_BADDR) + (STPC_CLKE))
+#define STP_STPC_CLKGEN_RST         ((STP_STPC_BADDR) + (STPC_CLKGEN_RST))
+#define STP_STPC_CLKGEN_STBY        ((STP_STPC_BADDR) + (STPC_CLKGEN_STBY))
+#define STP_STPC_CLKGEN_DIV         ((STP_STPC_BADDR) + (STPC_CLKGEN_DIV))
+#define STP_STPC_CLKGEN_STS         ((STP_STPC_BADDR) + (STPC_CLKGEN_STS))
+#define STP_STPC_CLKGEN_BYPASS      ((STP_STPC_BADDR) + (STPC_CLKGEN_BYPASS))
+#define STP_STPC_CLKGEN_HDIV        ((STP_STPC_BADDR) + (STPC_CLKGEN_HDIV))
+#define STP_STPC_CLKGEN_DIVLAT      ((STP_STPC_BADDR) + (STPC_CLKGEN_DIVLAT))
+#define STP_STPC_CLKGEN_STBYWAIT    ((STP_STPC_BADDR) + (STPC_CLKGEN_STBYWAIT))
+#define STP_STPC_CLKSW_CONFIG       ((STP_STPC_BADDR) + (STPC_CLKSW_CONFIG))
+#define STP_STPC_CLKSW_CONFIG2      ((STP_STPC_BADDR) + (STPC_CLKSW_CONFIG2))
+#define STP_STPC_CLKSW_ACK          ((STP_STPC_BADDR) + (STPC_CLKSW_ACK))
+#define STP_STPC_PFCNTCTL           ((STP_STPC_BADDR) + (STPC_PFCNTCTL))
+#define STP_STPC_PFCNTCLR           ((STP_STPC_BADDR) + (STPC_PFCNTCLR))
+#define STP_STPC_CNT0               ((STP_STPC_BADDR) + (STPC_CNT0))
+#define STP_STPC_CNT1               ((STP_STPC_BADDR) + (STPC_CNT1))
+#define STP_STPC_DRPCMD_MSK         ((STP_STPC_BADDR) + (STPC_DRPCMD_MSK))
+#define STP_STPC_MONI0              ((STP_STPC_BADDR) + (STPC_MONI0))
+#define STP_STPC_MONI1              ((STP_STPC_BADDR) + (STPC_MONI1))
+#define STP_STPC_MONI2              ((STP_STPC_BADDR) + (STPC_MONI2))
+#define STP_STPC_MONI3              ((STP_STPC_BADDR) + (STPC_MONI3))
+#define STP_STPC_CTRLPLS0           ((STP_STPC_BADDR) + (STPC_CTRLPLS0))
+#define STP_STPC_CTRLPLS1           ((STP_STPC_BADDR) + (STPC_CTRLPLS1))
+#define STP_STPC_CTRLPLS2           ((STP_STPC_BADDR) + (STPC_CTRLPLS2))
+#define STP_STPC_CTRLPLS3           ((STP_STPC_BADDR) + (STPC_CTRLPLS3))
+#define STP_STPC_CTRL0              ((STP_STPC_BADDR) + (STPC_CTRL0))
+#define STP_STPC_CTRL1              ((STP_STPC_BADDR) + (STPC_CTRL1))
+#define STP_STPC_CTRL2              ((STP_STPC_BADDR) + (STPC_CTRL2))
+#define STP_STPC_CTRL3              ((STP_STPC_BADDR) + (STPC_CTRL3))
+#define STP_STPC_CLKGEN_CTRL        ((STP_STPC_BADDR) + (STPC_CLKGEN_CTRL))
+
+#define EXD0_STPC_CLKSW_CONFIG      ((EXD0_STPC_BADDR) + (STPC_CLKSW_CONFIG))
+
+//------------------------------------------------------------------------------------------------------------------
+// ADRCONV
+//------------------------------------------------------------------------------------------------------------------
+#define ADRCONV_TBL_EN              (0x1FFCuLL)
+#define ADRCONV_TBL                 (0x2000uLL)
+#define ADRCONV_CTL_REG             (0x1FFCuLL)
+#define ADRCONV_TBLn_REG            (0xE000uLL)
+
+#define STP_ADRCONV_TBL_EN          ((STP_ADRCONV_BADDR) + (ADRCONV_TBL_EN))
+#define STP_ADRCONV_TBL             ((STP_ADRCONV_BADDR) + (ADRCONV_TBL))
+
+#define EXD0_ADRCONV_TBL_EN         ((EXD0_ADRCONV_BADDR) + (ADRCONV_TBL_EN))
+#define EXD0_ADRCONV_TBL            ((EXD0_ADRCONV_BADDR) + (ADRCONV_TBL))
+
+//------------------------------------------------------------------------------------------------------------------
+// SYNC TBL
+//------------------------------------------------------------------------------------------------------------------
+#define STP_STBL_TBL0               ((STP_SYNCTBL_BADDR) + 0x000uLL)
+#define STP_STBL_TBL1               ((STP_SYNCTBL_BADDR) + 0x004uLL)
+#define STP_STBL_TBL2               ((STP_SYNCTBL_BADDR) + 0x008uLL)
+#define STP_STBL_TBL3               ((STP_SYNCTBL_BADDR) + 0x00CuLL)
+#define STP_STBL_TBL4               ((STP_SYNCTBL_BADDR) + 0x010uLL)
+#define STP_STBL_TBL5               ((STP_SYNCTBL_BADDR) + 0x014uLL)
+#define STP_STBL_TBL6               ((STP_SYNCTBL_BADDR) + 0x018uLL)
+#define STP_STBL_TBL7               ((STP_SYNCTBL_BADDR) + 0x01CuLL)
+#define STP_STBL_TBL8               ((STP_SYNCTBL_BADDR) + 0x020uLL)
+#define STP_STBL_TBL9               ((STP_SYNCTBL_BADDR) + 0x024uLL)
+#define STP_STBL_TBL10              ((STP_SYNCTBL_BADDR) + 0x028uLL)
+#define STP_STBL_TBL11              ((STP_SYNCTBL_BADDR) + 0x02CuLL)
+#define STP_STBL_TBL12              ((STP_SYNCTBL_BADDR) + 0x030uLL)
+#define STP_STBL_TBL13              ((STP_SYNCTBL_BADDR) + 0x034uLL)
+#define STP_STBL_TBL14              ((STP_SYNCTBL_BADDR) + 0x038uLL)
+#define STP_STBL_TBL15              ((STP_SYNCTBL_BADDR) + 0x03CuLL)
+#define STP_STBL_TBL16              ((STP_SYNCTBL_BADDR) + 0x040uLL)
+#define STP_STBL_TBL17              ((STP_SYNCTBL_BADDR) + 0x044uLL)
+#define STP_STBL_TBL18              ((STP_SYNCTBL_BADDR) + 0x048uLL)
+#define STP_STBL_TBL19              ((STP_SYNCTBL_BADDR) + 0x04CuLL)
+#define STP_STBL_TBL20              ((STP_SYNCTBL_BADDR) + 0x050uLL)
+#define STP_STBL_TBL21              ((STP_SYNCTBL_BADDR) + 0x054uLL)
+#define STP_STBL_TBL22              ((STP_SYNCTBL_BADDR) + 0x058uLL)
+#define STP_STBL_TBL23              ((STP_SYNCTBL_BADDR) + 0x05CuLL)
+#define STP_STBL_TBL24              ((STP_SYNCTBL_BADDR) + 0x060uLL)
+#define STP_STBL_TBL25              ((STP_SYNCTBL_BADDR) + 0x064uLL)
+#define STP_STBL_TBL26              ((STP_SYNCTBL_BADDR) + 0x068uLL)
+#define STP_STBL_TBL27              ((STP_SYNCTBL_BADDR) + 0x06CuLL)
+#define STP_STBL_TBL28              ((STP_SYNCTBL_BADDR) + 0x070uLL)
+#define STP_STBL_TBL29              ((STP_SYNCTBL_BADDR) + 0x074uLL)
+#define STP_STBL_TBL30              ((STP_SYNCTBL_BADDR) + 0x078uLL)
+#define STP_STBL_TBL31              ((STP_SYNCTBL_BADDR) + 0x07CuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// CLKRSTCON
+//------------------------------------------------------------------------------------------------------------------
+#define CLKRSTCON_SFTRST_REG        (0x000uLL)
+#define CLKRSTCON_CLKE_REG          (0x008uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// PRAM
+//------------------------------------------------------------------------------------------------------------------
+#define PRAM_INT                    ((PRAM_BADDR) + 0x00000000uLL)
+#define PRAM_INTMSK                 ((PRAM_BADDR) + 0x00000008uLL)
+#define PRAM_CTRL                   ((PRAM_BADDR) + 0x00000100uLL)
+#define PRAM_STATE0                 ((PRAM_BADDR) + 0x00000110uLL)
+#define PRAM_STATE1                 ((PRAM_BADDR) + 0x00000114uLL)
+#define PRAM_CNT0                   ((PRAM_BADDR) + 0x00000200uLL)
+#define PRAM_CNT1                   ((PRAM_BADDR) + 0x00000204uLL)
+#define PRAM_CNT2                   ((PRAM_BADDR) + 0x00000208uLL)
+#define PRAM_CNT3                   ((PRAM_BADDR) + 0x0000020CuLL)
+#define PRAM_CNT4                   ((PRAM_BADDR) + 0x00000210uLL)
+#define PRAM_CNT5                   ((PRAM_BADDR) + 0x00000214uLL)
+#define PRAM_CNT6                   ((PRAM_BADDR) + 0x00000218uLL)
+#define PRAM_CNT7                   ((PRAM_BADDR) + 0x0000021CuLL)
+#define PRAM_CNTSEL0                ((PRAM_BADDR) + 0x00000220uLL)
+#define PRAM_CNTSEL1                ((PRAM_BADDR) + 0x00000224uLL)
+#define PRAM_CNTSEL2                ((PRAM_BADDR) + 0x00000228uLL)
+#define PRAM_CNTSEL3                ((PRAM_BADDR) + 0x0000022CuLL)
+#define PRAM_CNTSEL4                ((PRAM_BADDR) + 0x00000230uLL)
+#define PRAM_CNTSEL5                ((PRAM_BADDR) + 0x00000234uLL)
+#define PRAM_CNTSEL6                ((PRAM_BADDR) + 0x00000238uLL)
+#define PRAM_CNTSEL7                ((PRAM_BADDR) + 0x0000023CuLL)
+#define PRAM_CNT_EN                 ((PRAM_BADDR) + 0x00000240uLL)
+#define PRAM_CHICKEN                ((PRAM_BADDR) + 0x00000840uLL)
+#define PRAM_DBGCTRL                ((PRAM_BADDR) + 0x00000F00uLL)
+#define PRAM_INFO                   ((PRAM_BADDR) + 0x00000F04uLL)
+#define PRAM_WDINFO                 ((PRAM_BADDR) + 0x00000F10uLL)
+#define PRAM_RDINFO                 ((PRAM_BADDR) + 0x00000F14uLL)
+#define PRAM_FSM                    ((PRAM_BADDR) + 0x00000F30uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// MACTOP
+//------------------------------------------------------------------------------------------------------------------
+#define MACTOP_MACCTL_INT_STS       ((MACCTL_BADDR) + 0x00000000uLL)
+#define MACTOP_MACCTL_INT_MSK       ((MACCTL_BADDR) + 0x00000004uLL)
+#define MACTOP_MACCTL_ERR_STS       ((MACCTL_BADDR) + 0x00000008uLL)
+#define MACTOP_MACCTL_ERR_MSK       ((MACCTL_BADDR) + 0x0000000CuLL)
+#define MACTOP_MACCTL_SETTING       ((MACCTL_BADDR) + 0x00000400uLL)
+#define MACTOP_MACCTL_ADD_NOP       ((MACCTL_BADDR) + 0x00000410uLL)
+#define MACTOP_MACCTL_FERR_STS      ((MACCTL_BADDR) + 0x00000800uLL)
+#define MACTOP_MACCTL_FERR_LOG1     ((MACCTL_BADDR) + 0x00000900uLL)
+#define MACTOP_MACCTL_FERR_LOG2     ((MACCTL_BADDR) + 0x00000904uLL)
+#define MACTOP_MACCTL_FERR_LOG3     ((MACCTL_BADDR) + 0x00000908uLL)
+#define MACTOP_MACCTL_STS0_0        ((MACCTL_BADDR) + 0x00001000uLL)
+#define MACTOP_MACCTL_STS0_1        ((MACCTL_BADDR) + 0x00001004uLL)
+#define MACTOP_MACCTL_STS0_2        ((MACCTL_BADDR) + 0x00001008uLL)
+#define MACTOP_MACCTL_STS1_0        ((MACCTL_BADDR) + 0x00001100uLL)
+#define MACTOP_MACCTL_STS1_1        ((MACCTL_BADDR) + 0x00001104uLL)
+#define MACTOP_MACCTL_STS1_2        ((MACCTL_BADDR) + 0x00001108uLL)
+#define MACTOP_MACCTL_STS1_3        ((MACCTL_BADDR) + 0x0000110CuLL)
+#define MACTOP_MACCTL_STS2_0        ((MACCTL_BADDR) + 0x00001180uLL)
+#define MACTOP_MACCTL_STS2_1        ((MACCTL_BADDR) + 0x00001184uLL)
+#define MACTOP_MACCTL_STS2_2        ((MACCTL_BADDR) + 0x00001188uLL)
+#define MACTOP_MACCTL_STS2_3        ((MACCTL_BADDR) + 0x0000118CuLL)
+#define MACTOP_MACCTL_STS2_4        ((MACCTL_BADDR) + 0x00001190uLL)
+#define MACTOP_MACCTL_STS3_0        ((MACCTL_BADDR) + 0x00001200uLL)
+#define MACTOP_MACCTL_STS3_1        ((MACCTL_BADDR) + 0x00001204uLL)
+#define MACTOP_MACCTL_STS3_2        ((MACCTL_BADDR) + 0x00001208uLL)
+#define MACTOP_MACCTL_STS3_3        ((MACCTL_BADDR) + 0x0000120CuLL)
+#define MACTOP_MACCTL_STS3_4        ((MACCTL_BADDR) + 0x00001210uLL)
+#define MACTOP_MACCTL_STS3_5        ((MACCTL_BADDR) + 0x00001214uLL)
+#define MACTOP_MACCTL_STS3_6        ((MACCTL_BADDR) + 0x00001218uLL)
+#define MACTOP_MACCTL_STS3_7        ((MACCTL_BADDR) + 0x0000121CuLL)
+#define MACTOP_MACCTL_STS3_8        ((MACCTL_BADDR) + 0x00001220uLL)
+#define MACTOP_MACCTL_STS3_9        ((MACCTL_BADDR) + 0x00001224uLL)
+#define MACTOP_MACCTL_STS3_10       ((MACCTL_BADDR) + 0x00001228uLL)
+#define MACTOP_MACCTL_STS4_0        ((MACCTL_BADDR) + 0x00001280uLL)
+#define MACTOP_MACCTL_STS4_1        ((MACCTL_BADDR) + 0x00001284uLL)
+#define MACTOP_MACCTL_STS4_2        ((MACCTL_BADDR) + 0x00001288uLL)
+#define MACTOP_MACCTL_STS4_3        ((MACCTL_BADDR) + 0x0000128CuLL)
+#define MACTOP_MACCTL_STS4_4        ((MACCTL_BADDR) + 0x00001290uLL)
+#define MACTOP_MACCTL_STS4_5        ((MACCTL_BADDR) + 0x00001294uLL)
+#define MACTOP_MACCTL_STS4_6        ((MACCTL_BADDR) + 0x00001298uLL)
+#define MACTOP_MACCTL_STS4_7        ((MACCTL_BADDR) + 0x0000129CuLL)
+#define MACTOP_MACCTL_STS4_8        ((MACCTL_BADDR) + 0x000012A0uLL)
+#define MACTOP_MACCTL_STS4_9        ((MACCTL_BADDR) + 0x000012A4uLL)
+#define MACTOP_MACCTL_STS4_10       ((MACCTL_BADDR) + 0x000012A8uLL)
+#define MACTOP_MACCTL_STS5_0        ((MACCTL_BADDR) + 0x00001300uLL)
+#define MACTOP_MACCTL_STS5_1        ((MACCTL_BADDR) + 0x00001304uLL)
+#define MACTOP_MACCTL_STS5_2        ((MACCTL_BADDR) + 0x00001308uLL)
+#define MACTOP_MACCTL_STS5_3        ((MACCTL_BADDR) + 0x0000130CuLL)
+#define MACTOP_MACCTL_STS5_4        ((MACCTL_BADDR) + 0x00001310uLL)
+#define MACTOP_MACCTL_STS5_5        ((MACCTL_BADDR) + 0x00001314uLL)
+#define MACTOP_MACCTL_STS5_6        ((MACCTL_BADDR) + 0x00001318uLL)
+#define MACTOP_MACCTL_STS5_7        ((MACCTL_BADDR) + 0x0000131CuLL)
+#define MACTOP_MACCTL_STS5_8        ((MACCTL_BADDR) + 0x00001320uLL)
+#define MACTOP_MACCTL_STS5_9        ((MACCTL_BADDR) + 0x00001324uLL)
+#define MACTOP_MACCTL_STS5_10       ((MACCTL_BADDR) + 0x00001328uLL)
+#define MACTOP_MACCTL_STS5_11       ((MACCTL_BADDR) + 0x0000132CuLL)
+#define MACTOP_MACCTL_STS5_12       ((MACCTL_BADDR) + 0x00001330uLL)
+#define MACTOP_MACCTL_STS5_13       ((MACCTL_BADDR) + 0x00001334uLL)
+#define MACTOP_MACCTL_STS5_14       ((MACCTL_BADDR) + 0x00001338uLL)
+#define MACTOP_MACCTL_STS5_15       ((MACCTL_BADDR) + 0x0000133CuLL)
+#define MACTOP_MACCTL_STS5_16       ((MACCTL_BADDR) + 0x00001340uLL)
+#define MACTOP_MACCTL_STS5_17       ((MACCTL_BADDR) + 0x00001344uLL)
+#define MACTOP_MACCTL_STS6_0        ((MACCTL_BADDR) + 0x00001380uLL)
+#define MACTOP_MACCTL_STS6_1        ((MACCTL_BADDR) + 0x00001384uLL)
+#define MACTOP_MACCTL_STS6_2        ((MACCTL_BADDR) + 0x00001388uLL)
+#define MACTOP_MACCTL_STS6_3        ((MACCTL_BADDR) + 0x0000138CuLL)
+#define MACTOP_MACCTL_STS6_4        ((MACCTL_BADDR) + 0x00001390uLL)
+#define MACTOP_MACCTL_STS6_5        ((MACCTL_BADDR) + 0x00001394uLL)
+#define MACTOP_MACCTL_STS6_6        ((MACCTL_BADDR) + 0x00001398uLL)
+#define MACTOP_MACCTL_STS6_7        ((MACCTL_BADDR) + 0x0000139CuLL)
+#define MACTOP_MACCTL_STS6_8        ((MACCTL_BADDR) + 0x000013A0uLL)
+#define MACTOP_MACCTL_STS6_9        ((MACCTL_BADDR) + 0x000013A4uLL)
+#define MACTOP_MACCTL_STS6_10       ((MACCTL_BADDR) + 0x000013A8uLL)
+#define MACTOP_MACCTL_STS6_11       ((MACCTL_BADDR) + 0x000013ACuLL)
+#define MACTOP_MACCTL_STS6_12       ((MACCTL_BADDR) + 0x000013B0uLL)
+#define MACTOP_MACCTL_MONITOR1_CTL  ((MACCTL_BADDR) + 0x00001400uLL)
+#define MACTOP_MACCTL_MONITOR2_CTL  ((MACCTL_BADDR) + 0x00001404uLL)
+#define MACTOP_MACCTL_MONITOR1L     ((MACCTL_BADDR) + 0x00001500uLL)
+#define MACTOP_MACCTL_MONITOR1H     ((MACCTL_BADDR) + 0x00001504uLL)
+#define MACTOP_MACCTL_MONITOR2L     ((MACCTL_BADDR) + 0x00001508uLL)
+#define MACTOP_MACCTL_MONITOR2H     ((MACCTL_BADDR) + 0x0000150CuLL)
+#define MACTOP_MACCTL_DBG_LOG_CTL   ((MACCTL_BADDR) + 0x00001700uLL)
+#define MACTOP_MACCTL_DBG_LOG_NUM   ((MACCTL_BADDR) + 0x00001704uLL)
+#define MACTOP_MACCTL_DBG_LOG_RDAT  ((MACCTL_BADDR) + 0x00001708uLL)
+#define MACTOP_MACCTL_DBG_LOG_RSIZE ((MACCTL_BADDR) + 0x0000170CuLL)
+#define MACTOP_MACCTL_DBG_LOG_LID   ((MACCTL_BADDR) + 0x00001710uLL)
+#define MACTOP_MACCTL_DBG_LOG_CID0  ((MACCTL_BADDR) + 0x00001714uLL)
+#define MACTOP_MACCTL_DBG_LOG_CID1  ((MACCTL_BADDR) + 0x00001718uLL)
+
+#define MACTOP_MACCTL_SCNT          ((MACCTL_BADDR) + 0x00001800uLL)
+#define MACTOP_MACCTL_CCNT          ((MACCTL_BADDR) + 0x00001804uLL)
+#define MACTOP_MACCTL_INST_EN       ((MACCTL_BADDR) + 0x00002000uLL)
+#define MACTOP_MACCTL_INST_NUM_M1   ((MACCTL_BADDR) + 0x00002004uLL)
+#define MACTOP_MACCTL_INST_DATA     ((MACCTL_BADDR) + 0x00002100uLL)
+#define MACTOP_MACCTL_BP_MODE       ((MACCTL_BADDR) + 0x00003000uLL)
+#define MACTOP_MACCTL_BP_CTL        ((MACCTL_BADDR) + 0x00003004uLL)
+#define MACTOP_MACCTL_BP_DONE       ((MACCTL_BADDR) + 0x00003008uLL)
+#define MACTOP_MACCTL_BP_CSTART     ((MACCTL_BADDR) + 0x0000300CuLL)
+#define MACTOP_MACCTL_BP_ITR        ((MACCTL_BADDR) + 0x00003010uLL)
+#define MACTOP_MACCTL_BP_INST       ((MACCTL_BADDR) + 0x00003014uLL)
+#define MAC64_0_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00010000uLL)
+#define MAC64_1_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00011000uLL)
+#define MAC64_2_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00012000uLL)
+#define MAC64_3_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00013000uLL)
+#define MAC64_4_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00014000uLL)
+#define MAC64_5_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00015000uLL)
+#define MAC64_6_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00016000uLL)
+#define MAC64_7_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00017000uLL)
+#define MAC64_8_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00018000uLL)
+                                     
+// MACTOP DCLK
+#define DOFIFO0_STS                 ((MACCTL_DCLK_BADDR) + 0x0000F800uLL)
+#define DOFIFO0_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000F900uLL)
+#define DOFIFO0_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000F904uLL)
+#define DOFIFO0_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000F9F0uLL)
+#define DOFIFO0_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000F9F4uLL)
+#define DOFIFO1_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FA00uLL)
+#define DOFIFO1_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FB00uLL)
+#define DOFIFO1_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FB04uLL)
+#define DOFIFO1_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FBF0uLL)
+#define DOFIFO1_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FBF4uLL)
+#define DOFIFO2_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FC00uLL)
+#define DOFIFO2_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FD00uLL)
+#define DOFIFO2_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FD04uLL)
+#define DOFIFO2_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FDF0uLL)
+#define DOFIFO2_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FDF4uLL)
+#define DOFIFO3_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FE00uLL)
+#define DOFIFO3_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FF00uLL)
+#define DOFIFO3_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FF04uLL)
+#define DOFIFO3_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FFF0uLL)
+#define DOFIFO3_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FFF4uLL)
+
+//MACTOP MCLK
+#define DIFIFO0_STS                 ((MACCTL_BADDR) + 0x00008000uLL)
+#define DIFIFO0_RD0_L               ((MACCTL_BADDR) + 0x00008100uLL)
+#define DIFIFO0_RD0_U               ((MACCTL_BADDR) + 0x00008104uLL)
+#define DIFIFO0_RD15_L              ((MACCTL_BADDR) + 0x000081F0uLL)
+#define DIFIFO0_RD15_U              ((MACCTL_BADDR) + 0x000081F4uLL)
+#define DIFIFO1_STS                 ((MACCTL_BADDR) + 0x00008200uLL)
+#define DIFIFO1_RD0_L               ((MACCTL_BADDR) + 0x00008300uLL)
+#define DIFIFO1_RD0_U               ((MACCTL_BADDR) + 0x00008304uLL)
+#define DIFIFO1_RD15_L              ((MACCTL_BADDR) + 0x000083F0uLL)
+#define DIFIFO1_RD15_U              ((MACCTL_BADDR) + 0x000083F4uLL)
+#define DIFIFO2_STS                 ((MACCTL_BADDR) + 0x00008400uLL)
+#define DIFIFO2_RD0_L               ((MACCTL_BADDR) + 0x00008500uLL)
+#define DIFIFO2_RD0_U               ((MACCTL_BADDR) + 0x00008504uLL)
+#define DIFIFO2_RD15_L              ((MACCTL_BADDR) + 0x000085F0uLL)
+#define DIFIFO2_RD15_U              ((MACCTL_BADDR) + 0x000085F4uLL)
+#define DIFIFO3_STS                 ((MACCTL_BADDR) + 0x00008600uLL)
+#define DIFIFO3_RD0_L               ((MACCTL_BADDR) + 0x00008700uLL)
+#define DIFIFO3_RD0_U               ((MACCTL_BADDR) + 0x00008704uLL)
+#define DIFIFO3_RD15_L              ((MACCTL_BADDR) + 0x000087F0uLL)
+#define DIFIFO3_RD15_U              ((MACCTL_BADDR) + 0x000087F4uLL)
+#define MACCTL_INT_STS              ((MACCTL_BADDR) + 0x00000000uLL)
+#define MACCTL_INT_MSK              ((MACCTL_BADDR) + 0x00000004uLL)
+#define MACCTL_ERR_STS              ((MACCTL_BADDR) + 0x00000008uLL)
+#define MACCTL_ERR_MSK              ((MACCTL_BADDR) + 0x0000000CuLL)
+#define MACCTL_INT_CNT              ((MACCTL_BADDR) + 0x00000100uLL)
+#define MACCTL_ERR_CNT              ((MACCTL_BADDR) + 0x00000104uLL)
+#define MACCTL_SETTING              ((MACCTL_BADDR) + 0x00000400uLL)
+#define MACCTL_ADD_NOP              ((MACCTL_BADDR) + 0x00000410uLL)
+#define MACCTL_EXT_HOLD_PERIOD      ((MACCTL_BADDR) + 0x00000420uLL)
+#define MACCTL_EXT_HOLD_TH          ((MACCTL_BADDR) + 0x00000424uLL)
+#define MACCTL_NZNUM_CLR            ((MACCTL_BADDR) + 0x00000430uLL)
+#define MACCTL_NZNUM_TH             ((MACCTL_BADDR) + 0x00000434uLL)
+#define MACCTL_NZNUM_SET            ((MACCTL_BADDR) + 0x00000438uLL)
+#define MACCTL_PPU_NOP              ((MACCTL_BADDR) + 0x00000440uLL)
+#define MACCTL_WAIT_IM_NUM          ((MACCTL_BADDR) + 0x00000444uLL)
+#define MACCTL_INST_EBL             ((MACCTL_BADDR) + 0x00000450uLL)
+#define MACCTL_MAC_DATA_EBL         ((MACCTL_BADDR) + 0x00000460uLL)
+#define MACCTL_SET_PRAM_TH          ((MACCTL_BADDR) + 0x00000470uLL)
+#define MACCTL_GUARD                ((MACCTL_BADDR) + 0x00000480uLL)
+#define MACCTL_WAIT_IM_READY        ((MACCTL_BADDR) + 0x00000490uLL)
+#define MACCTL_FMA_OP_LIMIT2        ((MACCTL_BADDR) + 0x000004A0uLL)
+#define MACCTL_FERR_STS             ((MACCTL_BADDR) + 0x00000800uLL)
+#define MACCTL_FERR_LOG1            ((MACCTL_BADDR) + 0x00000900uLL)
+#define MACCTL_FERR_LOG2            ((MACCTL_BADDR) + 0x00000904uLL)
+#define MACCTL_FERR_LOG3            ((MACCTL_BADDR) + 0x00000908uLL)
+#define MACCTL_STS0_0               ((MACCTL_BADDR) + 0x00001000uLL)
+#define MACCTL_STS0_1               ((MACCTL_BADDR) + 0x00001004uLL)
+#define MACCTL_STS0_2               ((MACCTL_BADDR) + 0x00001008uLL)
+#define MACCTL_STS1_0               ((MACCTL_BADDR) + 0x00001100uLL)
+#define MACCTL_STS1_1               ((MACCTL_BADDR) + 0x00001104uLL)
+#define MACCTL_STS1_2               ((MACCTL_BADDR) + 0x00001108uLL)
+#define MACCTL_STS1_3               ((MACCTL_BADDR) + 0x0000110CuLL)
+#define MACCTL_STS2_0               ((MACCTL_BADDR) + 0x00001180uLL)
+#define MACCTL_STS2_1               ((MACCTL_BADDR) + 0x00001184uLL)
+#define MACCTL_STS2_2               ((MACCTL_BADDR) + 0x00001188uLL)
+#define MACCTL_STS2_3               ((MACCTL_BADDR) + 0x0000118CuLL)
+#define MACCTL_STS2_4               ((MACCTL_BADDR) + 0x00001190uLL)
+#define MACCTL_STS3_0               ((MACCTL_BADDR) + 0x00001200uLL)
+#define MACCTL_STS3_1               ((MACCTL_BADDR) + 0x00001204uLL)
+#define MACCTL_STS3_2               ((MACCTL_BADDR) + 0x00001208uLL)
+#define MACCTL_STS3_3               ((MACCTL_BADDR) + 0x0000120CuLL)
+#define MACCTL_STS3_4               ((MACCTL_BADDR) + 0x00001210uLL)
+#define MACCTL_STS3_5               ((MACCTL_BADDR) + 0x00001214uLL)
+#define MACCTL_STS3_6               ((MACCTL_BADDR) + 0x00001218uLL)
+#define MACCTL_STS3_7               ((MACCTL_BADDR) + 0x0000121CuLL)
+#define MACCTL_STS3_8               ((MACCTL_BADDR) + 0x00001220uLL)
+#define MACCTL_STS3_9               ((MACCTL_BADDR) + 0x00001224uLL)
+#define MACCTL_STS3_10              ((MACCTL_BADDR) + 0x00001228uLL)
+#define MACCTL_STS4_0               ((MACCTL_BADDR) + 0x00001280uLL)
+#define MACCTL_STS4_1               ((MACCTL_BADDR) + 0x00001284uLL)
+#define MACCTL_STS4_2               ((MACCTL_BADDR) + 0x00001288uLL)
+#define MACCTL_STS4_3               ((MACCTL_BADDR) + 0x0000128CuLL)
+#define MACCTL_STS4_4               ((MACCTL_BADDR) + 0x00001290uLL)
+#define MACCTL_STS4_5               ((MACCTL_BADDR) + 0x00001294uLL)
+#define MACCTL_STS4_6               ((MACCTL_BADDR) + 0x00001298uLL)
+#define MACCTL_STS4_7               ((MACCTL_BADDR) + 0x0000129CuLL)
+#define MACCTL_STS4_8               ((MACCTL_BADDR) + 0x000012A0uLL)
+#define MACCTL_STS4_9               ((MACCTL_BADDR) + 0x000012A4uLL)
+#define MACCTL_STS4_10              ((MACCTL_BADDR) + 0x000012A8uLL)
+#define MACCTL_STS5_0               ((MACCTL_BADDR) + 0x00001300uLL)
+#define MACCTL_STS5_1               ((MACCTL_BADDR) + 0x00001304uLL)
+#define MACCTL_STS5_2               ((MACCTL_BADDR) + 0x00001308uLL)
+#define MACCTL_STS5_3               ((MACCTL_BADDR) + 0x0000130CuLL)
+#define MACCTL_STS5_4               ((MACCTL_BADDR) + 0x00001310uLL)
+#define MACCTL_STS5_5               ((MACCTL_BADDR) + 0x00001314uLL)
+#define MACCTL_STS5_6               ((MACCTL_BADDR) + 0x00001318uLL)
+#define MACCTL_STS5_7               ((MACCTL_BADDR) + 0x0000131CuLL)
+#define MACCTL_STS5_8               ((MACCTL_BADDR) + 0x00001320uLL)
+#define MACCTL_STS5_9               ((MACCTL_BADDR) + 0x00001324uLL)
+#define MACCTL_STS5_10              ((MACCTL_BADDR) + 0x00001328uLL)
+#define MACCTL_STS5_11              ((MACCTL_BADDR) + 0x0000132CuLL)
+#define MACCTL_STS5_12              ((MACCTL_BADDR) + 0x00001330uLL)
+#define MACCTL_STS5_13              ((MACCTL_BADDR) + 0x00001334uLL)
+#define MACCTL_STS5_14              ((MACCTL_BADDR) + 0x00001338uLL)
+#define MACCTL_STS5_15              ((MACCTL_BADDR) + 0x0000133CuLL)
+#define MACCTL_STS5_16              ((MACCTL_BADDR) + 0x00001340uLL)
+#define MACCTL_STS5_17              ((MACCTL_BADDR) + 0x00001344uLL)
+#define MACCTL_STS6_0               ((MACCTL_BADDR) + 0x00001380uLL)
+#define MACCTL_STS6_1               ((MACCTL_BADDR) + 0x00001384uLL)
+#define MACCTL_STS6_2               ((MACCTL_BADDR) + 0x00001388uLL)
+#define MACCTL_STS6_3               ((MACCTL_BADDR) + 0x0000138CuLL)
+#define MACCTL_STS6_4               ((MACCTL_BADDR) + 0x00001390uLL)
+#define MACCTL_STS6_5               ((MACCTL_BADDR) + 0x00001394uLL)
+#define MACCTL_STS6_6               ((MACCTL_BADDR) + 0x00001398uLL)
+#define MACCTL_STS6_7               ((MACCTL_BADDR) + 0x0000139CuLL)
+#define MACCTL_STS6_8               ((MACCTL_BADDR) + 0x000013A0uLL)
+#define MACCTL_STS6_9               ((MACCTL_BADDR) + 0x000013A4uLL)
+#define MACCTL_STS6_10              ((MACCTL_BADDR) + 0x000013A8uLL)
+#define MACCTL_STS6_11              ((MACCTL_BADDR) + 0x000013ACuLL)
+#define MACCTL_STS6_12              ((MACCTL_BADDR) + 0x000013B0uLL)
+#define MACCTL_MONITOR1_CTL         ((MACCTL_BADDR) + 0x00001400uLL)
+#define MACCTL_MONITOR2_CTL         ((MACCTL_BADDR) + 0x00001404uLL)
+#define MACCTL_MONITOR1L            ((MACCTL_BADDR) + 0x00001500uLL)
+#define MACCTL_MONITOR1H            ((MACCTL_BADDR) + 0x00001504uLL)
+#define MACCTL_MONITOR2L            ((MACCTL_BADDR) + 0x00001508uLL)
+#define MACCTL_MONITOR2H            ((MACCTL_BADDR) + 0x0000150CuLL)
+#define MACCTL_DBG_LOG_CTL          ((MACCTL_BADDR) + 0x00001700uLL)
+#define MACCTL_DBG_LOG_NUM          ((MACCTL_BADDR) + 0x00001704uLL)
+#define MACCTL_DBG_LOG_RDAT         ((MACCTL_BADDR) + 0x00001708uLL)
+#define MACCTL_SCNT                 ((MACCTL_BADDR) + 0x00001800uLL)
+#define MACCTL_CCNT                 ((MACCTL_BADDR) + 0x00001804uLL)
+#define MACCTL_INST_EN              ((MACCTL_BADDR) + 0x00002000uLL)
+#define MACCTL_INST_NUM_M1          ((MACCTL_BADDR) + 0x00002004uLL)
+#define MACCTL_INST                 ((MACCTL_BADDR) + 0x00002100uLL)
+#define MACCTL_BP_MODE              ((MACCTL_BADDR) + 0x00003000uLL)
+#define MACCTL_BP_CTL               ((MACCTL_BADDR) + 0x00003004uLL)
+#define MACCTL_BP_DONE              ((MACCTL_BADDR) + 0x00003008uLL)
+#define MACCTL_BP_CSTART            ((MACCTL_BADDR) + 0x0000300CuLL)
+#define MACCTL_BP_ITR               ((MACCTL_BADDR) + 0x00003010uLL)
+#define MACCTL_BP_INST              ((MACCTL_BADDR) + 0x00003014uLL)
+#define CFIFO_STS                   ((MACCTL_BADDR) + 0x00007000uLL)
+#define CFIFO_RD0_L                 ((MACCTL_BADDR) + 0x00007100uLL)
+#define CFIFO_RD0_LM                ((MACCTL_BADDR) + 0x00007104uLL)
+#define CFIFO_RD0_UM                ((MACCTL_BADDR) + 0x00007108uLL)
+#define CFIFO_RD0_U                 ((MACCTL_BADDR) + 0x0000710CuLL)
+#define CFIFO_RD1_L                 ((MACCTL_BADDR) + 0x00007110uLL)
+#define CFIFO_RD1_LM                ((MACCTL_BADDR) + 0x00007114uLL)
+#define CFIFO_RD1_UM                ((MACCTL_BADDR) + 0x00007118uLL)
+#define CFIFO_RD1_U                 ((MACCTL_BADDR) + 0x0000711CuLL)
+#define CFIFO_RD2_L                 ((MACCTL_BADDR) + 0x00007120uLL)
+#define CFIFO_RD2_LM                ((MACCTL_BADDR) + 0x00007124uLL)
+#define CFIFO_RD2_UM                ((MACCTL_BADDR) + 0x00007128uLL)
+#define CFIFO_RD2_U                 ((MACCTL_BADDR) + 0x0000712CuLL)
+#define CFIFO_RD3_L                 ((MACCTL_BADDR) + 0x00007130uLL)
+#define CFIFO_RD3_LM                ((MACCTL_BADDR) + 0x00007134uLL)
+#define CFIFO_RD3_UM                ((MACCTL_BADDR) + 0x00007138uLL)
+#define CFIFO_RD3_U                 ((MACCTL_BADDR) + 0x0000713CuLL)
+#define CFIFO_RD4_L                 ((MACCTL_BADDR) + 0x00007140uLL)
+#define CFIFO_RD4_LM                ((MACCTL_BADDR) + 0x00007144uLL)
+#define CFIFO_RD4_UM                ((MACCTL_BADDR) + 0x00007148uLL)
+#define CFIFO_RD4_U                 ((MACCTL_BADDR) + 0x0000714CuLL)
+#define CFIFO_RD5_L                 ((MACCTL_BADDR) + 0x00007150uLL)
+#define CFIFO_RD5_LM                ((MACCTL_BADDR) + 0x00007154uLL)
+#define CFIFO_RD5_UM                ((MACCTL_BADDR) + 0x00007158uLL)
+#define CFIFO_RD5_U                 ((MACCTL_BADDR) + 0x0000715CuLL)
+#define CFIFO_RD6_L                 ((MACCTL_BADDR) + 0x00007160uLL)
+#define CFIFO_RD6_LM                ((MACCTL_BADDR) + 0x00007164uLL)
+#define CFIFO_RD6_UM                ((MACCTL_BADDR) + 0x00007168uLL)
+#define CFIFO_RD6_U                 ((MACCTL_BADDR) + 0x0000716CuLL)
+#define CFIFO_RD7_L                 ((MACCTL_BADDR) + 0x00007170uLL)
+#define CFIFO_RD7_LM                ((MACCTL_BADDR) + 0x00007174uLL)
+#define CFIFO_RD7_UM                ((MACCTL_BADDR) + 0x00007178uLL)
+#define CFIFO_RD7_U                 ((MACCTL_BADDR) + 0x0000717CuLL)
+#define CFIFO_RD8_L                 ((MACCTL_BADDR) + 0x00007180uLL)
+#define CFIFO_RD8_LM                ((MACCTL_BADDR) + 0x00007184uLL)
+#define CFIFO_RD8_UM                ((MACCTL_BADDR) + 0x00007188uLL)
+#define CFIFO_RD8_U                 ((MACCTL_BADDR) + 0x0000718CuLL)
+#define CFIFO_RD9_L                 ((MACCTL_BADDR) + 0x00007190uLL)
+#define CFIFO_RD9_LM                ((MACCTL_BADDR) + 0x00007194uLL)
+#define CFIFO_RD9_UM                ((MACCTL_BADDR) + 0x00007198uLL)
+#define CFIFO_RD9_U                 ((MACCTL_BADDR) + 0x0000719CuLL)
+#define CFIFO_RD10_L                ((MACCTL_BADDR) + 0x000071A0uLL)
+#define CFIFO_RD10_LM               ((MACCTL_BADDR) + 0x000071A4uLL)
+#define CFIFO_RD10_UM               ((MACCTL_BADDR) + 0x000071A8uLL)
+#define CFIFO_RD10_U                ((MACCTL_BADDR) + 0x000071ACuLL)
+#define CFIFO_RD11_L                ((MACCTL_BADDR) + 0x000071B0uLL)
+#define CFIFO_RD11_LM               ((MACCTL_BADDR) + 0x000071B4uLL)
+#define CFIFO_RD11_UM               ((MACCTL_BADDR) + 0x000071B8uLL)
+#define CFIFO_RD11_U                ((MACCTL_BADDR) + 0x000071BCuLL)
+#define CFIFO_RD12_L                ((MACCTL_BADDR) + 0x000071C0uLL)
+#define CFIFO_RD12_LM               ((MACCTL_BADDR) + 0x000071C4uLL)
+#define CFIFO_RD12_UM               ((MACCTL_BADDR) + 0x000071C8uLL)
+#define CFIFO_RD12_U                ((MACCTL_BADDR) + 0x000071CCuLL)
+#define CFIFO_RD13_L                ((MACCTL_BADDR) + 0x000071D0uLL)
+#define CFIFO_RD13_LM               ((MACCTL_BADDR) + 0x000071D4uLL)
+#define CFIFO_RD13_UM               ((MACCTL_BADDR) + 0x000071D8uLL)
+#define CFIFO_RD13_U                ((MACCTL_BADDR) + 0x000071DCuLL)
+#define CFIFO_RD14_L                ((MACCTL_BADDR) + 0x000071E0uLL)
+#define CFIFO_RD14_LM               ((MACCTL_BADDR) + 0x000071E4uLL)
+#define CFIFO_RD14_UM               ((MACCTL_BADDR) + 0x000071E8uLL)
+#define CFIFO_RD14_U                ((MACCTL_BADDR) + 0x000071ECuLL)
+#define CFIFO_RD15_L                ((MACCTL_BADDR) + 0x000071F0uLL)
+#define CFIFO_RD15_LM               ((MACCTL_BADDR) + 0x000071F4uLL)
+#define CFIFO_RD15_UM               ((MACCTL_BADDR) + 0x000071F8uLL)
+#define CFIFO_RD15_U                ((MACCTL_BADDR) + 0x000071FCuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// MAC64 (stp/b1top/env/bench/v/reg_address_mac4k.v)
+//------------------------------------------------------------------------------------------------------------------
+#define MAC64_0_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x000000uLL)
+#define MAC64_1_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x001000uLL)
+#define MAC64_2_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x002000uLL)
+#define MAC64_3_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x003000uLL)
+#define MAC64_4_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x004000uLL)
+#define MAC64_5_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x005000uLL)
+#define MAC64_6_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x006000uLL)
+#define MAC64_7_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x007000uLL)
+#define MAC64_8_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x008000uLL)
+#define MAC64_9_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x009000uLL)
+#define MAC64_10_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00A000uLL)
+#define MAC64_11_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00B000uLL)
+#define MAC64_12_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00C000uLL)
+#define MAC64_13_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00D000uLL)
+#define MAC64_14_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00E000uLL)
+#define MAC64_15_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00F000uLL)
+
+#define MAC64_16_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x010000uLL)
+#define MAC64_17_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x011000uLL)
+#define MAC64_18_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x012000uLL)
+#define MAC64_19_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x013000uLL)
+#define MAC64_20_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x014000uLL)
+#define MAC64_21_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x015000uLL)
+#define MAC64_22_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x016000uLL)
+#define MAC64_23_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x017000uLL)
+#define MAC64_24_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x018000uLL)
+#define MAC64_25_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x019000uLL)
+#define MAC64_26_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01A000uLL)
+#define MAC64_27_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01B000uLL)
+#define MAC64_28_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01C000uLL)
+#define MAC64_29_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01D000uLL)
+#define MAC64_30_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01E000uLL)
+#define MAC64_31_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01F000uLL)
+
+#define MAC64_32_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x020000uLL)
+#define MAC64_33_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x021000uLL)
+#define MAC64_34_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x022000uLL)
+#define MAC64_35_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x023000uLL)
+#define MAC64_36_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x024000uLL)
+#define MAC64_37_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x025000uLL)
+#define MAC64_38_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x026000uLL)
+#define MAC64_39_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x027000uLL)
+#define MAC64_40_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x028000uLL)
+#define MAC64_41_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x029000uLL)
+#define MAC64_42_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02A000uLL)
+#define MAC64_43_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02B000uLL)
+#define MAC64_44_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02C000uLL)
+#define MAC64_45_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02D000uLL)
+#define MAC64_46_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02E000uLL)
+#define MAC64_47_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02F000uLL)
+
+#define MAC64_48_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x030000uLL)
+#define MAC64_49_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x031000uLL)
+#define MAC64_50_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x032000uLL)
+#define MAC64_51_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x033000uLL)
+#define MAC64_52_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x034000uLL)
+#define MAC64_53_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x035000uLL)
+#define MAC64_54_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x036000uLL)
+#define MAC64_55_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x037000uLL)
+#define MAC64_56_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x038000uLL)
+#define MAC64_57_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x039000uLL)
+#define MAC64_58_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03A000uLL)
+#define MAC64_59_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03B000uLL)
+#define MAC64_60_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03C000uLL)
+#define MAC64_61_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03D000uLL)
+#define MAC64_62_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03E000uLL)
+#define MAC64_63_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03F000uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// FMBUF
+//------------------------------------------------------------------------------------------------------------------
+#define FMBUF_ERR_STS               ((FMBUF_BADDR) + 0x00000000uLL)
+#define FMBUF_ERR_MSK               ((FMBUF_BADDR) + 0x00000004uLL)
+#define FMBUF_FMAP_CTRL             ((FMBUF_BADDR) + 0x00000100uLL)
+#define FMBUF_FMAP_IM_ARB           ((FMBUF_BADDR) + 0x00000104uLL)
+#define FMBUF_EXTIN_CTRL            ((FMBUF_BADDR) + 0x00000118uLL)
+#define FMBUF_EXTOUT_CTRL           ((FMBUF_BADDR) + 0x00000120uLL)
+#define FMBUF_FB_W_INTERVAL0        ((FMBUF_BADDR) + 0x00000130uLL)
+#define FMBUF_FB_W_INTERVAL1        ((FMBUF_BADDR) + 0x00000134uLL)
+#define FMBUF_FB_W_INTERVAL2        ((FMBUF_BADDR) + 0x00000138uLL)
+#define FMBUF_FB_W_INTERVAL3        ((FMBUF_BADDR) + 0x0000013CuLL)
+#define FMBUF_FB_W_INTERVAL4        ((FMBUF_BADDR) + 0x00000140uLL)
+#define FMBUF_FB_W_INTERVAL5        ((FMBUF_BADDR) + 0x00000144uLL)
+#define FMBUF_STS0                  ((FMBUF_BADDR) + 0x00000200uLL)
+#define FMBUF_STS1                  ((FMBUF_BADDR) + 0x00000204uLL)
+#define FMBUF_STS2                  ((FMBUF_BADDR) + 0x00000208uLL)
+#define FMBUF_STS3                  ((FMBUF_BADDR) + 0x0000020CuLL)
+#define FMBUF_STS4                  ((FMBUF_BADDR) + 0x00000210uLL)
+#define FMBUF_STS5                  ((FMBUF_BADDR) + 0x00000214uLL)
+#define FMBUF_STS6                  ((FMBUF_BADDR) + 0x00000218uLL)
+#define FMBUF_DEBUG                 ((FMBUF_BADDR) + 0x00000E00uLL)
+#define FMBUF_CNTER_CLR             ((FMBUF_BADDR) + 0x00000E04uLL)
+#define FMBUF_CNTER_SEL0            ((FMBUF_BADDR) + 0x00000E10uLL)
+#define FMBUF_CNTER_SEL1            ((FMBUF_BADDR) + 0x00000E14uLL)
+#define FMBUF_CNTER_SEL2            ((FMBUF_BADDR) + 0x00000E18uLL)
+#define FMBUF_CNTER_SEL3            ((FMBUF_BADDR) + 0x00000E1CuLL)
+#define FMBUF_CALC_START_CNT        ((FMBUF_BADDR) + 0x00000E20uLL)
+#define FMBUF_TARGET                ((FMBUF_BADDR) + 0x00000E24uLL)
+#define FMBUF_CNT0                  ((FMBUF_BADDR) + 0x00000E30uLL)
+#define FMBUF_CNT1                  ((FMBUF_BADDR) + 0x00000E34uLL)
+#define FMBUF_CNT2                  ((FMBUF_BADDR) + 0x00000E38uLL)
+#define FMBUF_CNT3                  ((FMBUF_BADDR) + 0x00000E3CuLL)
+#define FMBUF_CNT4                  ((FMBUF_BADDR) + 0x00000E40uLL)
+#define FMBUF_CNT5                  ((FMBUF_BADDR) + 0x00000E44uLL)
+#define FMBUF_CNT6                  ((FMBUF_BADDR) + 0x00000E48uLL)
+#define FMBUF_CNT7                  ((FMBUF_BADDR) + 0x00000E4CuLL)
+#define FMBUF_CNT8                  ((FMBUF_BADDR) + 0x00000E50uLL)
+#define FMBUF_CNT9                  ((FMBUF_BADDR) + 0x00000E54uLL)
+#define FMBUF_CNT10                 ((FMBUF_BADDR) + 0x00000E58uLL)
+#define FMBUF_CNT11                 ((FMBUF_BADDR) + 0x00000E5CuLL)
+#define FMBUF_CNT12                 ((FMBUF_BADDR) + 0x00000E60uLL)
+#define FMBUF_CNT13                 ((FMBUF_BADDR) + 0x00000E64uLL)
+#define FMBUF_CNT14                 ((FMBUF_BADDR) + 0x00000E68uLL)
+#define FMBUF_CNT15                 ((FMBUF_BADDR) + 0x00000E6CuLL)
+#define FMBUF_MMON_CTRL             ((FMBUF_BADDR) + 0x00000E80uLL)
+#define FMBUF_MEMLOG                ((FMBUF_BADDR) + 0x00000E84uLL)
+#define FMBUF_CHICKEN0              ((FMBUF_BADDR) + 0x00000F00uLL)
+#define FMBUF_CHICKEN1              ((FMBUF_BADDR) + 0x00000F04uLL)
+#define FMBUF_CLK_CTRL              ((FMBUF_BADDR) + 0x00000F08uLL)
+                                                 
+//------------------------------------------------------------------------------------------------------------------
+// AIDMAC
+//------------------------------------------------------------------------------------------------------------------
+#define AID0_IDIF2_INT_REG              ((AID0_IDIF2_BADDR) + 0x000uLL)
+#define AID0_IDIF2_INTMSK_REG           ((AID0_IDIF2_BADDR) + 0x004uLL)
+#define AID0_IDIF2_EINT_REG             ((AID0_IDIF2_BADDR) + 0x008uLL)
+#define AID0_IDIF2_EINTMSK_REG          ((AID0_IDIF2_BADDR) + 0x00CuLL)
+#define AID0_IDIF2_EINT_DSC_REG         ((AID0_IDIF2_BADDR) + 0x010uLL)
+#define AID0_IDIF2_EINTMSK_DSC_REG      ((AID0_IDIF2_BADDR) + 0x014uLL)
+#define AID0_IDIF2_INTMSKSET_REG        ((AID0_IDIF2_BADDR) + 0x020uLL)
+#define AID0_IDIF2_INTMSKCLR_REG        ((AID0_IDIF2_BADDR) + 0x024uLL)
+#define AID0_IDIF2_EINTMSKSET_REG       ((AID0_IDIF2_BADDR) + 0x030uLL)
+#define AID0_IDIF2_EINTMSKCLR_REG       ((AID0_IDIF2_BADDR) + 0x034uLL)
+#define AID0_IDIF2_EINTMSKDSCSET_REG    ((AID0_IDIF2_BADDR) + 0x038uLL)
+#define AID0_IDIF2_EINTMSKDSCCLR_REG    ((AID0_IDIF2_BADDR) + 0x03CuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// INTMON
+//------------------------------------------------------------------------------------------------------------------
+#define INTM_INT_REG                ((INTMON_BADR) + 0x000uLL)
+#define INTM_ERRINT_REG             ((INTMON_BADR) + 0x008uLL)
+                                                 
+//------------------------------------------------------------------------------------------------------------------
+// CPG
+//------------------------------------------------------------------------------------------------------------------
+#define CPG_BADDR                   (0x10420000uLL)
+
+// PLLETH
+#define CPG_PLLETH_STBY_REG         (0x0A0uLL)
+#define CPG_PLLETH_MON_REG          (0x0B0uLL)
+
+// MSTOP
+#define CPG_BUS_8_MSTOP_REG         (0xD1CuLL)     // 0=module operating(initial),1=stop:[8]=AIMAC, [9]=STP, [10]=DRP
+#define CPG_BUS_9_MSTOP_REG         (0xD20uLL)
+
+// BUS
+#define CPG_BUS_12_MSTOP_REG        (0xD2CuLL)
+
+// ACLK dividing ratio setting
+#define CPG_CDDIV2_REG              (0x408uLL)      // PLLCM33_CST400_GEAR dividing ratio setting
+#define CPG_CLKON_1_REG             (0x604uLL)
+#define CPG_CLKON_17_REG            (0x644uLL)      // CLK_ON(0=OFF(initial),1=ON) : [0]=DRP.DCLKIN, [1]=DRP.ACLK, [2]=DRP.INITCLK, [3]=DRPAI.DCLKIN, [4]=DRPAI.ACLK, [5]=DRPAI.INITCLK, [6]=DRPAI.MCLK
+#define CPG_CLKSTATUS0_REG          (0x700uLL)      // PLLCM33_CST400_GEAR status check
+#define CPG_CLKMON_0_REG            (0x800uLL)      // Clock monitor
+#define CPG_CLKMON_8_REG            (0x820uLL)      // Clock monitor
+
+// RESETn
+#define CPG_RST_3_REG               (0x90CuLL)
+#define CPG_RST_4_REG               (0x910uLL)
+#define CPG_RST_15_REG              (0x93CuLL)      // reset control (0=ResetON(initial), 1=OFF):[12]=DRP.ARESETn, [13]=DRPAI.ARESETn)
+#define CPG_RSTMON_1_REG            (0xA04uLL)      // reset monitor
+#define CPG_RSTMON_7_REG            (0xA1CuLL)      // reset monitor
+
+
+//------------------------------------------------------------------------------------------------------------------
+// Error Status Register
+//------------------------------------------------------------------------------------------------------------------
+//[drp error status]
+#define STPC_ERRINT_STS_ADDR        (0x00F1D808uLL)
+#define DRP_ERRINT_STATUS_ADDR      (0x003B0048uLL)
+#define IDIF_EINT_ADDR              (0x00F19008uLL)
+#define IDIF_EINT_DSC_ADDR          (0x00F19010uLL)
+#define ODIF_EINT_ADDR              (0x00F1A008uLL)
+#define IDMAC_INTSE_ADDR            (0x00F1B020uLL)
+#define IDMAC_AERS_ADDR             (0x00F1B030uLL)
+#define ODMAC_INTSE_ADDR            (0x00F1C020uLL)
+#define ODMAC_AERS_ADDR             (0x00F1C030uLL)
+//[aimac error status]
+#define INTMON_ERRINT_ADDR          (0x00141008uLL)
+#define AID0_IDIF_EINT_ADDR         (0x00119008uLL)
+#define AID0_IDIF2_EINT_DSC_ADDR    (0x0011A010uLL)
+#define AID0_IDMAC_INTSE_ADDR       (0x0011B020uLL)
+#define AID0_IDMAC_AERS_ADDR        (0x0011B030uLL)
+#define AID1_IDIF_EINT_ADDR         (0x000D9008uLL)
+#define AID1_IDMAC_INTSE_ADDR       (0x000DB020uLL)
+#define AID1_IDMAC_AERS_ADDR        (0x000DB030uLL)
+#define EXD0_IDIF_EINT_ADDR         (0x00019008uLL)
+#define EXD0_IDIF_DSC_ADDR          (0x00019010uLL)
+#define EXD0_ODIF_EINT_ADDR         (0x0001A008uLL)
+#define EXD0_IDMAC_INTSE_ADDR       (0x0001B020uLL)
+#define EXD0_IDMAC_AERS_ADDR        (0x0001B030uLL)
+#define EXD0_ODMAC_INTSE_ADDR       (0x0001C020uLL)
+#define EXD0_ODMAC_AERS_ADDR        (0x0001C030uLL)
+#define EXD1_IDIF_EINT_ADDR         (0x00059008uLL)
+#define EXD1_ODIF_EINT_ADDR         (0x0005A008uLL)
+#define EXD1_IDMAC_INTSE_ADDR       (0x0005B020uLL)
+#define EXD1_IDMAC_AERS_ADDR        (0x0005B030uLL)
+#define EXD1_ODMAC_INTSE_ADDR       (0x0005C020uLL)
+#define EXD1_ODMAC_AERS_ADDR        (0x0005C030uLL)
+#define PRAM_INT_ADDR               (0x00200000uLL)
+#define FMBUF_ERR_STS_ADDR          (0x001E0000uLL)
+#define MACCTL_ERR_STS_ADDR         (0x001C0008uLL)
+
+#endif /* DRP_REG__H */
diff --git a/drivers/drp/lock_drp.c b/drivers/drp/lock_drp.c
new file mode 100644
index 0000000000000..043bf12e1f6f6
--- /dev/null
+++ b/drivers/drp/lock_drp.c
@@ -0,0 +1,632 @@
+/*
+ * Driver for the Renesas RZ/V2H, RZ/V2N DRP-AI unit
+ *
+ * Copyright (C) 2023-2024 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <linux/stddef.h>
+#include <linux/device.h>
+#include <linux/delay.h>
+#include "lock_drp.h"
+
+/** The hash value are generated with the following command.
+ *    echo "CONFIG_DRP_SUPPORT_SHARED_MEMORY" | md5sum
+ */
+#define INIT_HASH_TOP_VAL                   (0x9bca83cf9c5b7f1e)
+#define INIT_HASH_BOTTOM_VAL                (0xa30b890ea28c78e7)
+
+#define WRITE_CONTROL_BIT     (0)
+#define RESET_CONT_STATUS_BIT (3)
+#define DRPAI_HW_STATUS_BIT   (4)
+
+#define FLAG_MANAGE_MEMORY         (0x0)
+#define RESET_CONT_STORE_MEMORY    (0x1)
+#define HASH_TOP_STORE_MEMORY      (0x2)
+#define HASH_BOTTOM_STORE_MEMORY   (0x3)
+
+#define LOCK_TIMEOUT_US (1000)  // 1000us = 1ms
+#define DELAY_TIME_US   (10)
+
+int lock_drp(unsigned long long *addr, unsigned int num)
+{
+    int result = 0;
+    unsigned long long old_value;
+
+    /* Check Arguments. */
+    if ((NULL == addr) || (((unsigned long long)addr & 0x7uLL) != 0) || (num >= 64))
+    {
+        result = -2;
+    }
+    else
+    {
+        /* set the specified bit. */
+        old_value = __sync_fetch_and_or(addr, (1uLL << num));
+        /* Check previous value. */
+        if ((old_value & (1uLL << num)) != 0)
+        {
+          result = -1;
+        }
+    }
+
+    return result;
+}
+
+int unlock_drp(unsigned long long *addr, unsigned int num)
+{
+    int result = 0;
+
+    /* Check Arguments. */
+    if ((NULL == addr) || (((unsigned long long)addr & 0x7uLL) != 0) || (num >= 64))
+    {
+        result = -2;
+    }
+    else
+    {
+        /* Clear the specified bit. */
+        (void)__sync_fetch_and_and(addr, ~(1uLL << num));
+    }
+    return result;
+}
+
+static int lock_write_control(unsigned long long *addr)
+{
+    int result = 0;
+    int elapsed_us_time = 0;
+
+    while(0 != (__sync_fetch_and_or(addr, (1uLL << WRITE_CONTROL_BIT)) & (1uLL << WRITE_CONTROL_BIT)))
+    {
+        udelay(DELAY_TIME_US);
+
+        elapsed_us_time += DELAY_TIME_US;
+        if(elapsed_us_time > LOCK_TIMEOUT_US)
+        {
+            result = -1;
+            goto end;
+        }
+    }
+
+end:
+    return result;
+}
+
+static int unlock_write_control(unsigned long long *addr)
+{
+    int result = 0;
+    /* Clear the specified bit. */
+    (void)__sync_fetch_and_and(addr, ~(1uLL << WRITE_CONTROL_BIT));
+
+    return result;
+}
+
+/** Test and set the specified bit on shared memory.
+ * @param *addr Base address for shared memory.
+ * @param *lock Spinlock pointer.
+ * @param context Indicates in which context this function was called.
+ * @param num A bit to be set to 1.
+ * @return Whether this function succeeded or not
+ * @retval 0 Success
+ * @retval -1 A specified bit has already set by another driver.
+ * @retval -2 Invalid argument is set.
+ * @retval -3 Failed to lock write control bit
+ */
+static int test_and_set_bit_on_shared_mem(unsigned long long *addr,
+                                          spinlock_t *lock,
+                                          unsigned int context,
+                                          unsigned int num)
+{
+    int result = 0;
+    int write_ctr_lock_status = -1;
+    unsigned long flags;
+
+    if (PROCESS_CONTEXT == context)
+    {
+        // To prevent interruption during critical section.
+        spin_lock_irqsave(lock, flags);
+    }
+
+    /* Check Arguments. */
+    if (NULL == addr) 
+    {
+        result = -2;
+    }
+
+    // Lock write control bit 
+    write_ctr_lock_status = lock_write_control(addr);
+    if(0 != write_ctr_lock_status)
+    {
+        // TIMEOUT
+        result = -3;
+        goto end;
+    }
+
+    // If RESET_CONT_STATUS_BIT is 1,
+    // it means that reset controler has been initilized by a driver.
+    if ((*(addr+FLAG_MANAGE_MEMORY) & ( 1uLL << num)) != 0)
+    {
+        result = -1;
+        goto end;
+    }
+    *(addr+FLAG_MANAGE_MEMORY) = (*(addr+FLAG_MANAGE_MEMORY) | (0x1 << num));
+
+    goto end;
+end:
+    if(0 == write_ctr_lock_status)
+    {
+        unlock_write_control(addr);
+    }
+    if (PROCESS_CONTEXT == context)
+    {
+        spin_unlock_irqrestore(lock, flags);
+    }
+    return result;
+}
+
+/** Clear the specified bit on shared memory.
+ * @param *addr Base address for shared memory.
+ * @param *lock Spinlock pointer.
+ * @param context Indicates in which context this function was called.
+ * @param num A bit to be set to 0.
+ * @return Whether this function succeeded or not
+ * @retval 0 Success
+ * @retval -2 Invalid argument is set.
+ * @retval -3 Failed to lock write control bit
+ */
+static int clear_bit_on_shared_mem(unsigned long long *addr,
+                                      spinlock_t *lock,
+                                      unsigned int context,
+                                      unsigned int num)
+{
+    int result = 0;
+    int write_ctr_lock_status = -1;
+    unsigned long flags;
+
+    if (PROCESS_CONTEXT == context)
+    {
+        // To prevent interruption during critical section.
+        spin_lock_irqsave(lock, flags);
+    }
+
+    /* Check Arguments. */
+    if (NULL == addr)
+    {
+        result = -2;
+        goto end;
+    }
+
+    // Lock write control bit 
+    write_ctr_lock_status = lock_write_control(addr);
+    if(0 != write_ctr_lock_status)
+    {
+        // TIMEOUT
+        result = -3;
+        goto end;
+    }
+
+    /* Clear the specified bit. */
+    *(addr+FLAG_MANAGE_MEMORY) = (*(addr+FLAG_MANAGE_MEMORY) & ~(1uLL << num));
+
+    goto end;
+end:
+    if(0 == write_ctr_lock_status)
+    {
+        unlock_write_control(addr);
+    }
+    if (PROCESS_CONTEXT == context)
+    {
+        spin_unlock_irqrestore(lock, flags);
+    }
+    return result;
+}
+
+/** Check a specifed bit on shared memory whether it is set.
+ * @param *addr Base address for shared memory.
+ * @param num A bit to be checked.
+ * @return Whether this function succeeded or not
+ * @retval 0 Success
+ * @retval -1 A specified bit is cleared.
+ * @retval -2 Invalid argument is set.
+ */
+static int is_shared_memory_bit_set(unsigned long long *addr, unsigned int num)
+{
+    int result = 0;
+
+    /* Check Arguments. */
+    if (NULL == addr)
+    {
+        result = -2;
+        goto end;
+    }
+
+    if ((*addr & ( 0x1 << num)) != 0)
+    {
+        // num bit is used by driver.
+        /* do nothing */
+    }
+    else
+    {
+        // num bit is not used by driver.
+        result = -1;
+        goto end;
+    }
+    goto end;
+end:
+    return result;
+}
+
+/*******************************************************************************
+ * Public APIs
+ *******************************************************************************/
+/** Lock shared memory to use be used in exclusion control of DRP-AI
+ * @param addr Base address for a shared memory.
+ * @param lock A pointer for spinlock to prevent interrupts in process context 
+ *             during performing this function.
+ * @param context Specify whether this function is called by a process or an interrupt.
+ *                If this function called by a process context, set PROCESS_CONTEXT.
+ * @param num Bit number in the shared memory area that manages the driver status.
+ *            Set DRPFLAG_DRP_LOCK(=0x2) for the DRP driver.
+ *            Set DRPFLAG_DRPAI_LOCK(=0x1) for the DRP-AI driver.
+ * @return Whether this function succeeded or not
+ * @retval 0 Success
+ * @retval -1 Failed to lock shared memory
+ * @retval -2 Invalid argument is set.
+ * @retval -3 Failed to lock write control bit
+ */
+int R_DRP_LockDrpaiContStatus(unsigned long long *addr,
+                              spinlock_t *lock,
+                              unsigned int context,
+                              unsigned int num)
+{
+    int result = 0;
+    int write_ctr_lock_status = -1;
+    unsigned long flags;
+    unsigned int shift_val;
+
+    if(PROCESS_CONTEXT == context)
+    {
+        // To prevent interruption during critical section.
+        spin_lock_irqsave(lock, flags);
+    }
+
+    /* Check Arguments. */
+    if (NULL == addr)
+    {
+        result = -2;
+        goto end;
+    }
+
+    // Lock write control bit 
+    write_ctr_lock_status = lock_write_control(addr);
+    if(0 != write_ctr_lock_status)
+    {
+        // Failed to get write control
+        // Error causes are TIMEOUT.
+        result = -3;
+        goto end;
+    }
+
+    // The following is bit manipulation example here.
+    //
+    // Case1: DRP Driver locked, DRPAI Driver try locking.
+    // addr = 0b1100
+    // num = DRPFLAG_DRPAI_LOCK (0b01) => ~(not operation) => 0b10 
+    // 0x1 is shifted by 0b10 => 0b100
+    // addr is masked by 0b100 => 0b0100. It means a locked status.
+    //
+    // Case2: nolocked, DRPAI Driver try locking
+    // addr = 0b1000
+    // num = DRPFLAG_DRPAI_LOCK (0b01) => ~(not operation) => 0b10 
+    // 0x1 is shifted by 0b10 => 0b100
+    // addr is masked by 0b100 => 0b0000. It means a no locked status.
+    shift_val = (~num) & 0x3;
+    if ((*(addr+FLAG_MANAGE_MEMORY) & (0x1 << shift_val)) != 0)
+    {
+        result = -1;
+        goto end;
+    }
+
+    // Set 1 to DRPAI bit to get a DRPAI control.
+    // If DRP bit is 1, DRPAI is used by DRP Driver.
+    // When DRPAI is used by DRP Driver, this function returns -1
+    // If DRPAI is used from DRPAI driver, this function returns 0. 
+    // This is because it is assumed that this function is already protected 
+    // by semaphores or spinlock or status transition management in the context in which it is called.
+    *(addr+FLAG_MANAGE_MEMORY) = (*(addr+FLAG_MANAGE_MEMORY) |(0x1 << num));
+
+    goto end;
+end:
+    if(0 == write_ctr_lock_status)
+    {
+        unlock_write_control(addr);
+    }
+    if (PROCESS_CONTEXT == context)
+    {
+        spin_unlock_irqrestore(lock, flags);
+    }
+
+    return result;
+}
+
+/** Unlock shared memory to be used in exclusion control of DRP-AI
+ * @param addr Base address for a shared memory.
+ * @param lock A pointer for spinlock to prevent interrupts in process context 
+ *             during performing this function.
+ * @param context Specify whether this function is called by a process or an interrupt.
+ *                If this function called by a process context, set PROCESS_CONTEXT.
+ * @param num Bit number in the shared memory area that manages the driver status.
+ *            Set DRPFLAG_DRP_LOCK(=0x2) for the DRP driver.
+ *            Set DRPFLAG_DRPAI_LOCK(=0x1) for the DRP-AI driver.
+ * @return Whether this function succeeded or not
+ * @retval 0 Success
+ * @retval -2 Invalid argument is set.
+ * @retval -3 Failed to lock write control bit
+ */
+int R_DRP_UnlockDrpaiContStatus(unsigned long long *addr,
+                                spinlock_t *lock,
+                                unsigned int context,
+                                unsigned int num)
+{
+    return clear_bit_on_shared_mem(addr, lock, context, num);
+}
+
+/** Check whether DRPAI is used by someone.
+ * @param addr Base address for a shared memory.
+ * @param num Bit number in the shared memory area that manages the driver status.
+ *            Set DRPFLAG_DRP_LOCK(=0x2) for the DRP driver.
+ *            Set DRPFLAG_DRPAI_LOCK(=0x1) for the DRP-AI driver.
+ * @return Status on shared memory for exculsion control of DRP-AI
+ * @retval 0 Success. DRP-AI is used by a num bit Driver.
+ * @retval 1 Nobody uses DRP-AI.
+ * @retval -1 DRP-AI is not used by a num bit Driver
+ * @retval -2 Invalid argument is set.
+ * @note Only read the shared memory which is used by exclude control
+ */
+int R_DRP_IsDrpaiContStatusLocked(unsigned long long *addr, unsigned int num)
+{
+    int tilde_num;  
+    int is_num_bit_locked = -1;
+    int is_tilde_num_bit_locked = -1;
+
+    // If num=DRPFLAG_DRP_LOCK(0x2), tilde_num becomes 0x1(=DRPFLAG_DRPAI_LOCK)
+    // If num=DRPFLAG_DRPAI_LOCK(0x1), tilde_num becomes 0x2(=DRPFLAG_DRP_LOCK)
+    tilde_num = (~num) & 0x3;
+
+    is_num_bit_locked = is_shared_memory_bit_set(addr, num);
+    is_tilde_num_bit_locked = is_shared_memory_bit_set(addr, tilde_num);
+
+    // If both bits are not locked (DRPFLAG_DRPAI_LOCK bit is 0 and DRPFLAG_DRP_LOCK bit is 0),
+    // nobody is using the DRP-AI.
+    if((-1 == is_num_bit_locked) && (-1 == is_tilde_num_bit_locked))
+    {
+        is_num_bit_locked = 1;
+    }
+
+    return is_num_bit_locked;
+}
+
+
+/** After confirming that the reset control pointer can be used, 
+ *  Lock shared memory to use be used in exclusion control of DRP-AI.
+ * @param addr Base address for a shared memory.
+ * @param lock A pointer for spinlock to prevent interrupts in process context 
+ *             during performing this function.
+ * @param context Specify whether this function is called by a process or an interrupt.
+ *                If this function called by a process context, set PROCESS_CONTEXT.
+ * @return Whether this function succeeded or not
+ * @retval 0 Success
+ * @retval -1 Another driver already has initlized the reset control pointer.
+ * @retval -2 Invalid argument is set.
+ * @retval -3 Failed to lock write control bit
+*/
+int R_DRP_LockResetContStatusBit(unsigned long long *addr,
+                                 spinlock_t *lock,
+                                 unsigned int context)
+{
+    return test_and_set_bit_on_shared_mem(addr, lock, context, RESET_CONT_STATUS_BIT);
+}
+
+/** Unlock shared memory to use be used in exclusion control of DRP-AI.
+ * @param addr Base address for a shared memory.
+ * @param lock A pointer for spinlock to prevent interrupts in process context 
+ *             during performing this function.
+ * @param context Specify whether this function is called by a process or an interrupt.
+ *                If this function called by a process context, set PROCESS_CONTEXT.
+ * @return Whether this function succeeded or not
+ * @retval 0 Success
+ * @retval -2 Invalid argument is set.
+ * @retval -3 Failed to lock write control bit
+*/
+int R_DRP_UnlockResetContStatusBit(unsigned long long *addr,
+                                   spinlock_t *lock,
+                                   unsigned int context)
+{
+    return clear_bit_on_shared_mem(addr, lock, context, RESET_CONT_STATUS_BIT);
+}
+
+/** Record in a shared memory that DRP-AI is active.
+ * @param addr Base address for a shared memory.
+ * @param lock A pointer for spinlock to prevent interrupts in process context 
+ *             during performing this function.
+ * @param context Specify whether this function is called by a process or an interrupt.
+ *                If this function called by a process context, set PROCESS_CONTEXT.
+ * @return Whether this function succeeded or not
+ * @retval 0 Successfully record that DRP-AI has been initialised.
+ * @retval -1 Another driver already has initlized the DRP-AI HW.
+ * @retval -2 Invalid argument is set.
+ * @retval -3 Failed to lock write control bit
+*/
+int R_DRP_RecordDrpaiActiveStatus(unsigned long long *addr,
+                                  spinlock_t *lock,
+                                  unsigned int context)
+{
+    return test_and_set_bit_on_shared_mem(addr, lock, context, DRPAI_HW_STATUS_BIT);
+}
+
+/** Record in a shared memory that DRP-AI is inactive.
+ * @param addr Base address for a shared memory.
+ * @param lock A pointer for spinlock to prevent interrupts in process context 
+ *             during performing this function.
+ * @param context Specify whether this function is called by a process or an interrupt.
+ *                If this function called by a process context, set PROCESS_CONTEXT.
+ * @return Whether this function succeeded or not
+ * @retval 0 Successfully record that DRP-AI has been stopped.
+ * @retval -2 Invalid argument is set.
+ * @retval -3 Failed to lock write control bit
+*/
+int R_DRP_RecordDrpaiInactiveStatus(unsigned long long *addr,
+                                    spinlock_t *lock,
+                                    unsigned int context)
+{
+    return clear_bit_on_shared_mem(addr, lock, context, DRPAI_HW_STATUS_BIT);
+}
+
+/** Check whether that DRP-AI is active.
+ * @param addr Base address for a shared memory.
+ * @return Whether this function succeeded or not
+ * @retval 0 DRP-AI has already been initialised.
+ * @retval -1 DRP-AI is stopped. Must initialise DRP-AI.
+ * @retval -2 Invalid argument is set.
+*/
+int R_DRP_IsDrpaiHwStatusActive(unsigned long long *addr)
+{
+    return is_shared_memory_bit_set(addr, DRPAI_HW_STATUS_BIT);
+}
+
+/** Initialize a shared memory.
+ * @param addr Base address for a shared memory.
+ * @return Whether this function succeeded or not
+ * @retval 0 Successfully initialize a shared memory. Shared memory has not yet been initialized,
+ *           but the HASH values were successfully written.
+ * @retval -2 Invalid argument is set.
+ * @note Write HASH to HASH_TOP_STORE_MEMORY and HASH_BOTTOM_STORE_MEMORY.
+*/
+int R_DRP_InitializeSharedMemory(unsigned long long *addr)
+{
+    int result = 0;
+
+    /* Check Arguments. */
+    if (NULL == addr) 
+    {
+        result = -2;
+        goto end;
+    }
+
+    *(addr+HASH_TOP_STORE_MEMORY) = 0uLL;
+    *(addr+HASH_BOTTOM_STORE_MEMORY) = 0uLL;
+    *(addr+HASH_TOP_STORE_MEMORY) = (*(addr+HASH_TOP_STORE_MEMORY) | INIT_HASH_TOP_VAL);
+    *(addr+HASH_BOTTOM_STORE_MEMORY) = (*(addr+HASH_BOTTOM_STORE_MEMORY) | INIT_HASH_BOTTOM_VAL);
+
+    goto end;
+end:
+    return result;
+}
+
+/** Clear the flag management area in a shared memory.
+ * @param addr Base address for a shared memory.
+ * @return Whether this function succeeded or not
+ * @retval 0 Successfully clear a shared memory. Write 0 to shared memory.
+ * @retval -2 Invalid argument is set.
+ * @note Write 0 to FLAG_MANAGE_MEMORY area.
+*/
+int R_DRP_ClearFlagManagementArea(unsigned long long *addr)
+{
+    int result = 0;
+
+    /* Check Arguments. */
+    if (NULL == addr) 
+    {
+        result = -2;
+        goto end;
+    }
+
+    *(addr+FLAG_MANAGE_MEMORY) = 0uLL;
+
+    goto end;
+end:
+    return result;
+}
+
+/** Clear the hash area in a shared memory.
+ * @param addr Base address for a shared memory.
+ * @return Whether this function succeeded or not
+ * @retval 0 Successfully clear a shared memory. Write 0 to shared memory.
+ * @retval -2 Invalid argument is set.
+ * @note Write 0 to FLAG_MANAGE_MEMORY area. Write 0 to HASH_TOP_STORE_MEMORY and HASH_BOTTOM_STORE_MEMORY.
+*/
+int R_DRP_ClearHashArea(unsigned long long *addr)
+{
+    int result = 0;
+
+    /* Check Arguments. */
+    if (NULL == addr) 
+    {
+        result = -2;
+        goto end;
+    }
+
+    *(addr+HASH_TOP_STORE_MEMORY) = 0uLL;
+    *(addr+HASH_BOTTOM_STORE_MEMORY) = 0uLL;
+
+    goto end;
+end:
+    return result;
+}
+
+/** Check whether a shared memory is initilized with HASH.
+ * @param addr Base address for a shared memory.
+ * @retval 0 Shared memory has not yet been initialized,
+ * @retval -1 Shared memory has already been initialized
+ * @retval -2 Invalid argument is set.
+ */
+int R_DRP_IsSharedMemoryInitialized(unsigned long long *addr)
+{
+    int result = 0;
+    /* Check Arguments. */
+    if (NULL == addr) 
+    {
+        result = -2;
+        goto end;
+    }
+
+    // If memory has been initilized, returns -1 as error.
+    if ((*(addr+HASH_TOP_STORE_MEMORY) == INIT_HASH_TOP_VAL) && (*(addr+HASH_BOTTOM_STORE_MEMORY) == INIT_HASH_BOTTOM_VAL))
+    {
+        result = -1;
+        goto end;
+    }
+end:
+    return result;
+}
+
+/** Get a reset controller pointer from shared memory.
+ * @param addr Base address for a shared memory.
+ * @return A pointer to the reset controller set in shared memory.
+ * @retval a reset controller pointer
+ */
+struct reset_control * R_DRP_GetResetContPointerFromSharedMemory(unsigned long long *addr)
+{
+    return (struct reset_control*)*((addr + RESET_CONT_STORE_MEMORY));
+}
+
+/** Set a reset controller pointer to shared memory.
+ * @param addr Base address for a shared memory.
+ * @param rstc A pointer to be set in shared memory.
+ * @return Always returns 0
+ * @retval 0 always returns 0
+ */
+int R_DRP_SetResetContPointerToSharedMemory(unsigned long long *addr, struct reset_control * rstc)
+{
+    void ** p_rstc;
+
+    p_rstc = (void**)(addr + RESET_CONT_STORE_MEMORY);
+    *p_rstc = rstc;
+    return 0;
+}
diff --git a/drivers/drp/lock_drp.h b/drivers/drp/lock_drp.h
new file mode 100644
index 0000000000000..11a55e79f7d6a
--- /dev/null
+++ b/drivers/drp/lock_drp.h
@@ -0,0 +1,67 @@
+/*
+ * Driver for the Renesas RZ/V2H, RZ/V2N DRP-AI unit
+ *
+ * Copyright (C) 2023-2024 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef R_DRP_LOCK_H
+#define R_DRP_LOCK_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+/* The following macros are used in exclusion control of DRP-AI */
+#define DRPFLAG_DRPAI_LOCK  (1)
+#define DRPFLAG_DRP_LOCK    (2)
+
+#define INTERRUPT_CONTEXT     (0)
+#define PROCESS_CONTEXT       (1)
+
+
+int R_DRP_LockDrpaiContStatus(unsigned long long *addr,
+                              spinlock_t *lock,
+                              unsigned int context,
+                              unsigned int num);
+int R_DRP_UnlockDrpaiContStatus(unsigned long long *addr,
+                                spinlock_t *lock,
+                                unsigned int context,
+                                unsigned int num);
+int R_DRP_IsDrpaiContStatusLocked(unsigned long long *addr, unsigned int num);
+int R_DRP_LockResetContStatusBit(unsigned long long *addr,
+                                 spinlock_t *lock,
+                                 unsigned int context);
+int R_DRP_UnlockResetContStatusBit(unsigned long long *addr,
+                                   spinlock_t *lock,
+                                   unsigned int context);
+int R_DRP_RecordDrpaiActiveStatus(unsigned long long *addr,
+                                  spinlock_t *lock,
+                                  unsigned int context);
+int R_DRP_RecordDrpaiInactiveStatus(unsigned long long *addr,
+                                    spinlock_t *lock,
+                                    unsigned int context);
+int R_DRP_IsDrpaiHwStatusActive(unsigned long long *addr);
+int R_DRP_InitializeSharedMemory(unsigned long long *addr);
+int R_DRP_IsSharedMemoryInitialized(unsigned long long *addr);
+int R_DRP_ClearFlagManagementArea(unsigned long long *addr);
+int R_DRP_ClearHashArea(unsigned long long *addr);
+struct reset_control * R_DRP_GetResetContPointerFromSharedMemory(unsigned long long *addr);
+int R_DRP_SetResetContPointerToSharedMemory(unsigned long long *addr, struct reset_control * rstc);
+
+int lock_drp(unsigned long long *addr, unsigned int num);
+int unlock_drp(unsigned long long * addr, unsigned int num);
+ 
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* R_DRP_LOCK_H */
diff --git a/include/linux/drp.h b/include/linux/drp.h
new file mode 100644
index 0000000000000..f368295a1b248
--- /dev/null
+++ b/include/linux/drp.h
@@ -0,0 +1,22 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DRP_H
+#define _DRP_H
+
+#include <uapi/linux/drp.h>
+
+#endif /* _DRP_H */
diff --git a/include/uapi/linux/drp.h b/include/uapi/linux/drp.h
new file mode 100644
index 0000000000000..3c8e8d33e9851
--- /dev/null
+++ b/include/uapi/linux/drp.h
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Driver for the Renesas RZ/V2H DRPI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI__DRP_H
+#define _UAPI__DRP_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <linux/ioctl.h>
+
+#define DRP_IO_TYPE               (46)
+#define DRP_ASSIGN                _IOW (DRP_IO_TYPE, 0, drp_data_t)
+#define DRP_START                 _IOW (DRP_IO_TYPE, 1, drp_data_t)
+#define DRP_RESET                 _IO  (DRP_IO_TYPE, 2)
+#define DRP_GET_STATUS            _IOR (DRP_IO_TYPE, 3, drp_status_t)
+#define DRP_SET_SEQ               _IOW (DRP_IO_TYPE, 6, drp_seq_t)           /* Since the sturecture size is different,            */
+#define DRP_GET_CODEC_AREA        _IOR (DRP_IO_TYPE, 11, drp_data_t)
+#define DRP_GET_OPENCVA_AREA      _IOR (DRP_IO_TYPE, 12, drp_data_t)
+#define DRP_SET_DRP_MAX_FREQ      _IOW (DRP_IO_TYPE, 13, uint32_t)
+#define DRP_READ_DRP_REG          _IOWR(DRP_IO_TYPE, 64, drp_reg_t)
+#define DRP_WRITE_DRP_REG         _IOW (DRP_IO_TYPE, 65, drp_reg_t)
+
+#define DRP_STATUS_INIT                   (0)
+#define DRP_STATUS_IDLE                   (1)
+#define DRP_STATUS_RUN                    (2)
+#define DRP_ERRINFO_SUCCESS               (0)
+#define DRP_ERRINFO_DRP_ERR               (-1)
+#define DRP_ERRINFO_RESET                 (-3)
+#define DRP_RESERVED_NUM                  (10)
+#define DRP_SEQ_NUM                       (20)
+#define DRP_EXE_DRP_40BIT                 (3)
+#define DRP_OPMASK_FORCE_LOAD             (0x8000)
+#define PARAM_ADDRESS_NUM                 (120)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drp_data
+{
+    uint64_t        address;
+    uint32_t        size;
+} drp_data_t;
+
+typedef struct drp_status
+{
+    uint32_t        status;
+    int32_t         err;
+    uint32_t        reserved[DRP_RESERVED_NUM];
+} drp_status_t;
+
+typedef struct iodata_info
+{
+    uint64_t        address;
+    uint32_t        size;
+    uint32_t        pos;
+} iodata_info_st;
+
+typedef struct drp_seq
+{
+    uint32_t        num;
+    uint32_t        order[DRP_SEQ_NUM];
+    uint64_t        address;
+    uint32_t        iodata_num;
+    iodata_info_st  iodata[PARAM_ADDRESS_NUM];
+} drp_seq_t;
+
+typedef struct drp_reg
+{
+    uint32_t        offset;
+    uint32_t        value;
+} drp_reg_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UAPI__DRP_H */
-- 
2.34.1

