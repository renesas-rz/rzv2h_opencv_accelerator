diff -uprN old/drivers/Kconfig new/drivers/Kconfig
--- old/drivers/Kconfig	2023-12-06 21:23:52.000000000 +0900
+++ new/drivers/Kconfig	2023-12-06 16:59:11.000000000 +0900
@@ -230,6 +230,8 @@ source "drivers/siox/Kconfig"
 
 source "drivers/slimbus/Kconfig"
 
+source "drivers/drp/Kconfig"
+
 source "drivers/interconnect/Kconfig"
 
 source "drivers/counter/Kconfig"
diff -uprN old/drivers/Makefile new/drivers/Makefile
--- old/drivers/Makefile	2023-12-06 21:24:02.000000000 +0900
+++ new/drivers/Makefile	2023-12-06 16:59:45.000000000 +0900
@@ -186,6 +186,7 @@ obj-$(CONFIG_MULTIPLEXER)	+= mux/
 obj-$(CONFIG_UNISYS_VISORBUS)	+= visorbus/
 obj-$(CONFIG_SIOX)		+= siox/
 obj-$(CONFIG_GNSS)		+= gnss/
+obj-$(CONFIG_DRP)		+= drp/
 obj-$(CONFIG_INTERCONNECT)	+= interconnect/
 obj-$(CONFIG_COUNTER)		+= counter/
 obj-$(CONFIG_MOST)		+= most/
diff -uprN old/drivers/drp/Kconfig new/drivers/drp/Kconfig
--- old/drivers/drp/Kconfig	1970-01-01 09:00:00.000000000 +0900
+++ new/drivers/drp/Kconfig	2023-10-11 20:01:49.000000000 +0900
@@ -0,0 +1,26 @@
+#
+# DRP subsystem configuration
+#
+
+menu "DRP/DRP support"
+
+config DRP
+	bool "DRP support"
+	default y
+	help
+	  DRP is a peripheral hardware that accelerates image processing.
+	  If you want DRP support, you should say Y here.
+
+config DRP_SUPPORT_MULTI_OS
+       bool "Support Multiple OS System"
+       default n
+       help
+         If you want to use multiple OS system (assumed with RTOS), you should say Y here.
+
+config DRP_INIT_SHARED_MEMORY
+       bool "Initialize Shared Memory"
+       default n
+       help
+         If you want to initialize shard memory, you should say Y here.
+         When "Support Multiple OS System" is 'Y', this option is enable.  
+endmenu
diff -uprN old/drivers/drp/Makefile new/drivers/drp/Makefile
--- old/drivers/drp/Makefile	1970-01-01 09:00:00.000000000 +0900
+++ new/drivers/drp/Makefile	2023-10-10 16:02:45.000000000 +0900
@@ -0,0 +1,8 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for DRP/DRP.
+#
+
+obj-$(CONFIG_DRP)	+= drp-core.o drp-if.o lock_drp.o
+
+
diff -uprN old/drivers/drp/drp-core.c new/drivers/drp/drp-core.c
--- old/drivers/drp/drp-core.c	1970-01-01 09:00:00.000000000 +0900
+++ new/drivers/drp/drp-core.c	2024-02-15 18:32:16.000000000 +0900
@@ -0,0 +1,927 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifdef __KERNEL__
+#include <linux/types.h>  /* for stdint */
+#include <asm/io.h>       /* for ioread/iowrite */
+#include <linux/delay.h>  /* for mdelay */
+#include <linux/module.h> /* for MODULE macro */
+#else
+#include <stdint.h>
+#endif
+
+#include "drp-core.h"
+#include "drp-reg.h"
+
+//------------------------------------------------------------------------------------------------------------------
+// Parameter setting
+//------------------------------------------------------------------------------------------------------------------
+#define NUT_VERSION                 "2023.02.24.a"
+
+#define DRP_DFCENA                  (0x1)
+#define DRP_DIVFIX                  (0x02)
+#define DRP_MIN_DIVFIX              (0x02)
+#define DRP_ADDR_RELOCATABLE_ENA    (0x0)
+#define AIMAC_DIVFIX                (0x01)
+#define AIMAC_ADDR_RELOCATABLE_ENA  (0x0)
+#define DRP_ECC_ENA                 (0x1)
+#define DRP_CDCC_PRERE              (0x1)
+#define DRP_CDCC_HFCFGW             (0x1)
+#define INIT_SET_BP_MODE            (0)
+#define INIT_SET_BP_CSTART          (0)
+#define INIT_SET_BP_ITR             (0)
+#define INIT_SET_BP_INST            (0)
+#define STP_ERRINT_STATUS_REG_NUM   (5)
+
+//------------------------------------------------------------------------------------------------------------------
+// Do not change
+//------------------------------------------------------------------------------------------------------------------
+#define DEF_DRP_SIDE                (0)
+#define DEF_AIMAC_SIDE              (1)
+
+
+//------------------------------------------------------------------------------------------------------------------
+// for Linux
+//------------------------------------------------------------------------------------------------------------------
+#ifndef __KERNEL__
+#define ioread32(addr)              (*((volatile uint32_t *)(addr)))
+#define ioread16(addr)              (*((volatile uint16_t *)(addr)))
+#define ioread8(addr)               (*((volatile uint8_t *)(addr)))
+#define iowrite32(value, addr)      (*((volatile uint32_t *)(addr)) = (uint32_t)(value))
+#define iowrite16(value, addr)      (*((volatile uint16_t *)(addr)) = (uint16_t)(value))
+#define iowrite8(value, addr)       (*((volatile uint8_t *)(addr))  = (uint8_t)(value))
+#endif
+
+//------------------------------------------------------------------------------------------------------------------
+// Prototype
+//------------------------------------------------------------------------------------------------------------------
+static void set_drpclkgen_freq(addr_t drp_base_addr, uint32_t bit_divfix, uint32_t bit_dfcena);
+static void start_drp_clk(addr_t drp_base_addr);
+static void stop_drp_clk(addr_t drp_base_addr);
+static void disable_drp_swreset(addr_t drp_base_addr);
+static void enable_drp_swreset(addr_t drp_base_addr);
+static void enable_addr_relocatable(addr_t drp_base_addr, uint64_t* addr);
+static void disable_adrconv_drp(addr_t drp_base_addr);
+static void enable_adrconv_drp(addr_t drp_base_addr);
+static void disable_addr_relocatable_func(addr_t drp_base_addr);
+static void disable_addr_relocatable(addr_t addr);
+static int32_t stop_desc_prefetch(addr_t dmactl_addr);
+static int32_t dma_stop(addr_t dmactl_addr);
+static void start_drp_dmac(addr_t drp_base_addr);
+static int32_t stop_drp_dmac(addr_t drp_base_addr);
+static int32_t stop_drp_dmacw(addr_t drp_base_addr);
+static void disable_drp_intmask(addr_t drp_base_addr);
+static void enable_drp_intmask(addr_t drp_base_addr);
+static void setadrconv_drp(addr_t drp_base_addr, uint64_t* addr);
+static void setdmaoffset_drp(addr_t drp_base_addr);
+
+static void set_drp_maxfreq(addr_t drp_base_addr, uint32_t mindiv);
+
+static int32_t loop_w(addr_t raddr, uint32_t exp_data, uint32_t mask);
+static int32_t check_reg(addr_t raddr, uint32_t exp, uint32_t mask0, uint32_t mask1);
+static void cpg_set(addr_t addr, int32_t bit, uint32_t val);
+static int32_t cpg_check(addr_t addr, int32_t bit, uint32_t val);
+#ifndef __KERNEL__
+static void mdelay(uint32_t msecs);
+#endif
+
+const static uint32_t stp_errint_status_reg_tbl[STP_ERRINT_STATUS_REG_NUM] =
+{
+    DRP_ERRINT_STATUS_ADDR, IDIF_EINT_ADDR, ODIF_EINT_ADDR, IDMAC_INTSE_ADDR, ODMAC_INTSE_ADDR,
+};
+
+const static char* stp_errint_status_reg_name_tbl[STP_ERRINT_STATUS_REG_NUM] =
+{
+    "DRP_ERRINT_STATUS","IDIF_EINT", "ODIF_EINT", "IDMAC_INTSE", "ODMAC_INTSE",
+};
+
+//------------------------------------------------------------------------------------------------------------------
+// IF functions
+//------------------------------------------------------------------------------------------------------------------
+int32_t R_DRP_DRP_Open(addr_t drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    drp_bootseq_drp(drp_base_addr, 0);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_SetAdrConv(addr_t drp_base_addr, int32_t ch, uint64_t* addr)
+{
+
+    disable_adrconv_drp(drp_base_addr);
+    enable_addr_relocatable(drp_base_addr, addr);
+    enable_adrconv_drp(drp_base_addr);
+    
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_ResetDmaoffset(addr_t drp_base_addr, int32_t ch)
+{
+
+    setdmaoffset_drp(drp_base_addr);
+    
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_SetFreq(addr_t drp_base_addr, int32_t ch, uint32_t divfix)
+{
+    set_drp_maxfreq(drp_base_addr, divfix);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_GetLastDescAddr(addr_t drp_base_addr, int32_t page, uint64_t* addr)
+{
+    uint32_t r_data0, addr_conv_en, desc_page, desc_tbl_data;
+    int32_t ret = R_DRP_ERR_REG;
+    /* Check Addr Conv is enabled */
+    addr_conv_en = ioread32(drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL_EN);
+    if( ( addr_conv_en & 0x00000001) == 0x00000001) // Addr conv function is Enabled
+    {
+        /* Get Descriptor address */
+        r_data0 = ioread32(drp_base_addr + STP_DSCC_BADDR + DSCC_DPA_REG);      // Descriptor addr bit0  - 32
+        desc_page = (r_data0 >> 24) & 0xFF;
+        if( desc_page == page ){
+            desc_tbl_data = ioread32(drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL + page * 4);  //'4' means 'sizeof(ADRCONV_TBLn register)'
+            if( (desc_tbl_data & 0x00000071) == 0x00000001)  // Addr conv (each page) is Enabled, and Page size = 16MB
+            {
+                *addr = ((uint64_t)(desc_tbl_data & 0x0000FF00)) << 24 | (desc_tbl_data & 0xFF000000) | (r_data0 & 0x00FFFFFF);
+                ret = R_DRP_SUCCESS;
+            }
+        }
+    }
+
+    return ret;
+}
+
+int32_t R_DRP_DRP_Start(addr_t drp_base_addr, int32_t ch, uint64_t desc)
+{
+    set_drp_desc_drp(drp_base_addr, desc);
+    start_prefetch_drp_drp(drp_base_addr);
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_Stop(addr_t drp_base_addr, int32_t ch, spinlock_t *lock)
+{
+    int32_t ret = R_DRP_SUCCESS;
+
+    if (0 != stop_prefetch_drp_drp(drp_base_addr))
+    {
+        ret = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+int32_t R_DRP_DRP_Nmlint(addr_t drp_base_addr, int32_t ch, drp_odif_intcnto_t *odif_intcnto)
+{
+    uint32_t rdata;
+    rdata = ioread32(drp_base_addr + STP_STPC_BADDR + STPC_INT_STS);
+    
+    if( 1 == ((rdata >> 9) & 1) )
+    {
+        rdata = ioread32(drp_base_addr + STP_ODIF_BADDR + ODIF_INT_REG);
+        iowrite32(rdata,drp_base_addr + STP_ODIF_BADDR + ODIF_INT_REG);
+        rdata = ioread32(drp_base_addr + STP_ODIF_BADDR + ODIF_INT_REG);    //Blank read
+
+        odif_intcnto->ch0 = ioread32(drp_base_addr + STP_ODIF_BADDR + ODIF_INTCNTO0_REG);
+    }
+    else
+    {
+        odif_intcnto->ch0 = 0;
+        odif_intcnto->ch1 = 0;
+        odif_intcnto->ch2 = 0;
+        odif_intcnto->ch3 = 0;
+    }
+    return R_DRP_SUCCESS;
+}
+
+int32_t R_DRP_DRP_CLR_Nmlint(addr_t drp_base_addr, int32_t ch)
+{
+    return stop_desc_prefetch(drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+void R_DRP_DRP_Errint(addr_t drp_base_addr, int32_t ch)
+{
+    volatile uint32_t dscc_pamon;
+    volatile uint32_t stpc_errint_sts;
+    uint32_t index;
+    volatile uint32_t error_status;
+    volatile uint32_t dummy;
+
+    printk(KERN_ERR "DRP1 Error Interrupt\n");
+
+    dscc_pamon      = ioread32(drp_base_addr   + STP_DSCC_BADDR  + DSCC_PAMON_REG);
+
+    printk(KERN_ERR "DSCC_PAMON : 0x%08X\n",      dscc_pamon);
+
+    stpc_errint_sts = ioread32(drp_base_addr + STP_STPC_ERRINT_STS);
+    printk(KERN_ERR "STPC_ERRINT_STS : 0x%08X\n", stpc_errint_sts);
+
+    for (index = 0; index < STP_ERRINT_STATUS_REG_NUM; index++)
+    {
+        error_status = ioread32(drp_base_addr + stp_errint_status_reg_tbl[index]);
+        iowrite32(error_status, drp_base_addr + stp_errint_status_reg_tbl[index]);
+        dummy = ioread32(drp_base_addr + stp_errint_status_reg_tbl[index]);
+
+        printk(KERN_ERR "%s : 0x%08X\n", stp_errint_status_reg_name_tbl[index], error_status);
+    }
+}
+
+int32_t R_DRP_DRP_RegRead(addr_t drp_base_addr, uint32_t offset, uint32_t* pvalue)
+{
+    int32_t ret;
+
+    if (0 == pvalue)
+    {
+        ret = R_DRP_ERR_INVALID_ARG;
+    }
+    else
+    {
+        *pvalue = ioread32(drp_base_addr + offset);
+        ret = R_DRP_SUCCESS;
+    }
+
+    return ret;
+}
+
+void R_DRP_DRP_RegWrite(addr_t drp_base_addr, uint32_t offset, uint32_t value)
+{
+    iowrite32(value, drp_base_addr + offset);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// CLKGEN module setting
+//------------------------------------------------------------------------------------------------------------------
+
+static void set_drpclkgen_freq(addr_t drp_base_addr, uint32_t bit_divfix, uint32_t bit_dfcena)
+{
+    uint32_t BIT_STBYWT;
+
+    BIT_STBYWT = 0x1;
+    iowrite32(BIT_STBYWT,                       drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_STBYWAIT);
+    iowrite32((bit_divfix << 16) | bit_dfcena,  drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_DIV);
+    BIT_STBYWT = 0x0;
+    iowrite32(BIT_STBYWT,                       drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_STBYWAIT);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Enable/Disable debug function
+//------------------------------------------------------------------------------------------------------------------
+
+static void set_drp_dbgctrl(addr_t drp_base_addr)
+{
+    set_drp_maxfreq(drp_base_addr, DRP_MIN_DIVFIX);
+    iowrite32((DRP_CDCC_PRERE << 8) + 0x00000001,   drp_base_addr + DRP_CDCC_DBGCTL);
+    iowrite32(0x00070000 + DRP_CDCC_HFCFGW,         drp_base_addr + DRP_CDCC_CCCTL);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Enable/Disable DMA channel clock
+//------------------------------------------------------------------------------------------------------------------
+
+static void start_drp_clk(addr_t drp_base_addr)
+{
+    uint32_t BIT_CMN_CLKE  = 0x1;
+    uint32_t BIT_STBL_CLKE = 0x1;
+    uint32_t BIT_DSCC_CLKE = 0x1;
+    uint32_t BIT_CFGW_CLKE = 0x1;
+    uint32_t BIT_CHOx_CLKE = 0xF;
+    uint32_t BIT_CHIx_CLKE = 0xF;
+
+    iowrite32((BIT_STBL_CLKE << 29) |
+              (BIT_CMN_CLKE  << 28) |
+              (BIT_CHOx_CLKE << 16) |
+              (BIT_DSCC_CLKE <<  9) |
+              (BIT_CFGW_CLKE <<  8) |
+              (BIT_CHIx_CLKE <<  0),    drp_base_addr + STP_STPC_BADDR + STPC_CLKE);
+}
+
+static void stop_drp_clk(addr_t drp_base_addr)
+{
+    uint32_t BIT_CMN_CLKE  = 0x0;
+    uint32_t BIT_STBL_CLKE = 0x0;
+    uint32_t BIT_DSCC_CLKE = 0x0;
+    uint32_t BIT_CFGW_CLKE = 0x0;
+    uint32_t BIT_CHOx_CLKE = 0x0;
+    uint32_t BIT_CHIx_CLKE = 0x0;
+
+    iowrite32(0xFFFFFFFF & ((BIT_STBL_CLKE << 29) |
+                            (BIT_CMN_CLKE  << 28) |
+                            (BIT_CHOx_CLKE << 16) |
+                            (BIT_DSCC_CLKE <<  9) |
+                            (BIT_CFGW_CLKE <<  8) |
+                            (BIT_CHIx_CLKE <<  0)), drp_base_addr + STP_STPC_BADDR + STPC_CLKE);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Enable/Disable SW reset
+//------------------------------------------------------------------------------------------------------------------
+
+static void disable_drp_swreset(addr_t drp_base_addr)
+{
+    uint32_t BIT_DRP_RST    = 0x0;
+    uint32_t BIT_DRPOIF_RST = 0x0;
+    uint32_t BIT_DRPIIF_RST = 0x0;
+    uint32_t BIT_CMN_RST    = 0x0;
+    uint32_t BIT_STBL_RST   = 0x0;
+    uint32_t BIT_DSCC_RST   = 0x0;
+    uint32_t BIT_CFGW_RST   = 0x0;
+    uint32_t BIT_CHOx_RST   = 0x0;
+    uint32_t BIT_CHIx_RST   = 0x0;
+    
+    iowrite32(0xFFFFFFFF & ((BIT_DRP_RST   << 31) |
+                            (BIT_STBL_RST  << 29) |
+                            (BIT_CMN_RST   << 28) |
+                            (BIT_DRPOIF_RST<< 27) |
+                            (BIT_DRPIIF_RST<< 26) |
+                            (BIT_CHOx_RST  << 16) |
+                            (BIT_DSCC_RST  <<  9) |
+                            (BIT_CFGW_RST  <<  8) |
+                            (BIT_CHIx_RST  <<  0)), drp_base_addr + STP_STPC_BADDR + STPC_SFTRST);
+}
+
+static void enable_drp_swreset(addr_t drp_base_addr)
+{
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_STPC_BADDR + STPC_SFTRST);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Address relocatable
+//------------------------------------------------------------------------------------------------------------------
+
+static void disable_addr_relocatable_func(addr_t drp_base_addr)
+{
+    if (0 != drp_base_addr)
+    {
+        disable_addr_relocatable(drp_base_addr + STP_ADRCONV_BADDR);
+    }
+}
+
+static void disable_addr_relocatable(addr_t addr)
+{
+    iowrite32(0x00000000, addr + ADRCONV_TBL_EN);
+}
+
+static void enable_addr_relocatable(addr_t drp_base_addr, uint64_t* addr)
+{
+    int i;
+
+    for( i=0; i<256; i++ )
+    {
+        uint32_t bit32_24 = (uint32_t)(*addr)       & 0xFF000000;
+        uint32_t bit15_8  = (uint32_t)(*addr >> 24) & 0x0000FF00;
+        uint32_t bit6_4   = 0x00000000;
+        uint32_t bit0     = 0x00000001;
+        iowrite32(bit32_24 | bit15_8 | bit6_4 | bit0, drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL + i*4);
+        addr++;
+    }
+}
+
+static void disable_adrconv_drp(addr_t drp_base_addr)
+{
+    iowrite32(0, drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL_EN);
+}
+
+static void enable_adrconv_drp(addr_t drp_base_addr)
+{
+    iowrite32(1, drp_base_addr + STP_ADRCONV_BADDR + ADRCONV_TBL_EN);
+}
+
+static void setdmaoffset_drp(addr_t drp_base_addr)
+{
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRCW_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2CW_REG);
+
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRI0_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2I0_REG);
+
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRI1_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2I1_REG);
+
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRI2_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2I2_REG);
+
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADRI3_REG);
+    iowrite32(0, drp_base_addr + STP_IDIF_BADDR + IDIF_BADR2I3_REG);
+
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADRO0_REG);
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADR2O0_REG);
+
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADRO1_REG);
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADR2O1_REG);
+
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADRO2_REG);
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADR2O2_REG);
+
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADRO3_REG);
+    iowrite32(0, drp_base_addr + STP_ODIF_BADDR + ODIF_BADR2O3_REG);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// Start/Stop prefetch descriptor
+//------------------------------------------------------------------------------------------------------------------
+static int32_t stop_desc_prefetch(addr_t dmactl_addr)
+{
+    iowrite8(0x00, dmactl_addr);
+    return loop_w(dmactl_addr, 0x00000000, 0xFFFFFFFD);
+}
+
+static int32_t dma_stop(addr_t dmactl_addr)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    iowrite8(0x00, dmactl_addr + 0x2);
+    iowrite8(0x00, dmactl_addr + 0x0);
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(dmactl_addr, 0x00080000, 0x00000002, 0x00080000))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(dmactl_addr, 0x00080000, 0x00000002, 0x00080000))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+static void start_drp_dmac(addr_t drp_base_addr)
+{
+    uint32_t BIT_DEN       = 0x1;
+    uint32_t BIT_REQEN     = 0x1;
+    uint32_t BIT_DSEL_DESC = 0x0;
+    uint32_t BIT_DSEL_CMD  = 0x1;
+
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_DESC << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI0_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI1_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI2_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI3_REG);
+
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO0_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO1_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO2_REG);
+    iowrite32((BIT_REQEN << 18) | (BIT_DSEL_CMD  << 8) | (BIT_DEN << 0), drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO3_REG);
+
+    iowrite32((BIT_REQEN << 18) | (BIT_DEN << 0),                        drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLCW_REG);
+}
+
+static int32_t stop_drp_dmac(addr_t drp_base_addr)
+{
+    int32_t ret = 0;
+
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI2_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLI3_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO0_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO1_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO2_REG))
+    {
+        goto error_stop;
+    }
+    if (0 != dma_stop(drp_base_addr + STP_ODIF_BADDR + ODIF_DMACTLO3_REG))
+    {
+        goto error_stop;
+    }
+
+    goto end;
+
+error_stop:
+    ret = -1;
+    goto end;
+
+end:
+    return ret;
+}
+
+static int32_t stop_drp_dmacw(addr_t drp_base_addr)
+{
+    addr_t dmactl_addr = drp_base_addr + STP_IDIF_BADDR + IDIF_DMACTLCW_REG;
+
+    iowrite8(0x00, dmactl_addr);
+
+    return loop_w(dmactl_addr, 0x00000000, 0xFFFFFFFD);
+}
+
+//------------------------------------------------------------------------------------------------------------------
+// DRP-AI interrupt mask setting
+//------------------------------------------------------------------------------------------------------------------
+static void disable_drp_intmask(addr_t drp_base_addr)
+{
+#if (0 != DRP_ECC_ENA)
+    iowrite32(0x0000073F, drp_base_addr + DRP_ERRINT_ENABLE);
+#else
+    iowrite32(0x00000000, drp_base_addr + DRP_ERRINT_ENABLE);
+    iowrite32(0x00000007, drp_base_addr + DRP_ECC);
+#endif
+
+    iowrite32(0xF8F0F0F0, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFEFEFE, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFF0F0F0, drp_base_addr + STP_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFF8, drp_base_addr + STP_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFC, drp_base_addr + STP_ODMAC_BADDR + ODMAC_INTME_REG);
+
+    iowrite32(0xFFFFFFF0, drp_base_addr + STP_ODIF_BADDR + ODIF_INTMSK_REG);
+
+    // setting ELC0
+    iowrite32(0x0000000F, drp_base_addr + STP_ODIF_BADDR + ODIF_ELCCTL_REG);
+}
+
+static void enable_drp_intmask(addr_t drp_base_addr)
+{
+    // enable normal interrupt
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODIF_BADDR + ODIF_INTMSK_REG);
+
+    // disable DRP error interrupt
+    iowrite32(0x00000000, drp_base_addr + DRP_ERRINT_ENABLE);
+
+    // enable abnormal interrupt
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDIF_BADDR  + IDIF_EINTMSK_DSC_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODIF_BADDR  + ODIF_EINTMSK_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_IDMAC_BADDR + IDMAC_INTME_REG);
+    iowrite32(0xFFFFFFFF, drp_base_addr + STP_ODMAC_BADDR + ODMAC_INTME_REG);
+
+    // disable ELC0 output
+    iowrite32(0x00000000, drp_base_addr + STP_ODIF_BADDR + ODIF_ELCCTL_REG);
+}
+
+//==================================================================================================================
+// Initialize (DRP)
+//==================================================================================================================
+void drp_bootseq_drp(addr_t drp_base_addr, uint32_t *drp_addr_relocatable_tbl)
+{
+    uint32_t BIT_DRPCLKGEN_RST = 0x0;
+
+    // 1. release DRPCLKGEN module reset
+    iowrite32(BIT_DRPCLKGEN_RST, drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_RST);
+
+    // 2. setup DRP clock frequency
+    set_drpclkgen_freq(drp_base_addr, DRP_DIVFIX, DRP_DFCENA);
+
+    // 3. enable DMA channel clock
+    start_drp_clk(drp_base_addr);
+
+    // 4. release soft reset
+    disable_drp_swreset(drp_base_addr);
+
+    // debug on/off
+//    set_drp_dbgctrl(drp_base_addr);
+
+    // 5. initialize SYNCTBL
+    // Not required for V2H
+
+    // 6. setup address relocatable table
+    disable_addr_relocatable_func(drp_base_addr);
+
+    // 7. setup DMA channel
+    start_drp_dmac(drp_base_addr);
+
+    // 8. unmask interrupt
+    disable_drp_intmask(drp_base_addr);
+}
+
+//==================================================================================================================
+// Procedure of DRP/AIMAC
+//==================================================================================================================
+void set_drp_desc_drp(addr_t drp_base_addr, uint64_t drp_desc_addr)
+{
+    iowrite32(drp_desc_addr & 0xFFFFFFFF, drp_base_addr + STP_DSCC_BADDR + DSCC_DPA_REG);
+    iowrite32(drp_desc_addr >> 32,        drp_base_addr + STP_DSCC_BADDR + DSCC_DPA2_REG);
+}
+
+void start_prefetch_drp_drp(addr_t drp_base_addr)
+{
+    uint32_t BIT_DSCEN = 0x1;
+
+    iowrite32(BIT_DSCEN << 0, drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG);
+}
+
+//==================================================================================================================
+// Stop procedure
+//==================================================================================================================
+int32_t stop_prefetch_drp_drp(addr_t drp_base_addr)
+{
+    int32_t ret = 0;
+
+    // 1. Stop descriptor prefetch.
+    if( 0 != stop_desc_prefetch(drp_base_addr + STP_DSCC_BADDR + DSCC_DCTLI0_REG))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 2. Stop writing configuration data.
+    if (0 != stop_drp_dmacw(drp_base_addr))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 3. Mask interrput.
+    enable_drp_intmask(drp_base_addr);
+
+    // 4. Stop data input/output.
+    if (0 != stop_drp_dmac(drp_base_addr))
+    {
+        ret = -1;
+        goto end;
+    }
+
+    // 5. Disable address relocation table.
+    disable_addr_relocatable_func(drp_base_addr);
+
+    // 6. Set up DRP core to fixed frequency mode.
+    set_drpclkgen_freq(drp_base_addr, 0x7F, 0x0);
+
+    // 7. Software reset.
+    enable_drp_swreset(drp_base_addr);
+
+    // 8. Stop DMA channel clock.
+    stop_drp_clk(drp_base_addr);
+
+    // 9. Reset DRPCLKGEN module.
+    iowrite32(0x00000001, drp_base_addr + STP_STPC_BADDR + STPC_CLKGEN_RST);
+
+    // 10.System reset
+    /* DO NOTHING */
+    goto end;
+
+end:
+    return ret;
+}
+
+int32_t cpg_reset_drp(addr_t cpg_base_addr, int32_t ch)
+{
+    int32_t ret = R_DRP_SUCCESS;
+    int32_t BIT_NUM_RST    = (0 == ch) ? 13 : 12;
+    int32_t BIT_NUM_RSTMON = (0 == ch) ? 14 : 13;
+
+    // Reset on setting.
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, BIT_NUM_RST, 0x0u);
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, BIT_NUM_RSTMON, 0x1u))
+    {
+        ret = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+    // Reset off setting.
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, BIT_NUM_RST, 0x1u);
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, BIT_NUM_RSTMON, 0x0u))
+    {
+        ret = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    return ret;
+}
+
+//==================================================================================================================
+// Procedure of changing DRP-AI clock (for debug).
+//==================================================================================================================
+static void set_drp_maxfreq(addr_t drp_base_addr, uint32_t mindiv)
+{
+    iowrite32(mindiv, drp_base_addr + DRP_MINDIV);
+}
+
+//==================================================================================================================
+// reg check loop
+//==================================================================================================================
+static int32_t loop_w(addr_t raddr, uint32_t exp_data, uint32_t mask)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(raddr, exp_data, ~mask, 0))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(raddr, exp_data, ~mask, 0))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+//==================================================================================================================
+// CPG function
+//==================================================================================================================
+int32_t initialize_cpg_drp(addr_t cpg_base_addr)
+{
+    int32_t ret = R_DRP_SUCCESS;
+
+    // PLLETH
+    cpg_set(cpg_base_addr + CPG_PLLETH_STBY_REG, 0, 0x1u);
+
+    // PLLETH_MON
+    if (0 != loop_w(cpg_base_addr + CPG_PLLETH_MON_REG, 0x00000010u, 0xFFFFFFEFu))
+    {
+        goto error_init;
+    }
+
+    // MSTOP
+    cpg_set(cpg_base_addr + CPG_BUS_8_MSTOP_REG, 10, 0x0u);  // DRP
+
+    // CLK_ON
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 0, 0x1u);  // DRP.DCLKIN
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 1, 0x1u);  // DRP.ACLK
+    cpg_set(cpg_base_addr + CPG_CLKON_17_REG, 2, 0x1u);  // DRP.INITCLK
+
+    // CLK_MON
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 16, 0x1u))  // DRP.DCLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 17, 0x1u))  // DRP.ACLK
+    {
+        goto error_init;
+    }
+    if (0 != cpg_check(cpg_base_addr + CPG_CLKMON_8_REG, 18, 0x1u))  // DRP.INITCLK
+    {
+        goto error_init;
+    }
+                                                       
+    // Reset OFF
+    cpg_set(cpg_base_addr + CPG_RST_15_REG, 12, 0x1u);  // DRP.ARESETn
+
+    // RSTMON
+    if (0 != cpg_check(cpg_base_addr + CPG_RSTMON_7_REG, 13, 0x0u))  // DRP.ARESETn
+    {
+        goto error_init;
+    }
+
+    goto end;
+
+error_init:
+    ret = R_DRP_ERR_INIT;
+    goto end;
+
+end:
+    return ret;
+
+}
+
+static void cpg_set(addr_t addr, int32_t bit, uint32_t val)
+{
+    uint32_t rdata;
+
+    rdata = ioread32(addr);
+    rdata = (rdata >> bit) & 1;
+
+    if (rdata != val)
+    {
+        uint32_t wdata = (1 << (bit + 16)) + (val << bit);
+
+        iowrite32(wdata, addr);
+    }
+}
+
+static int32_t check_reg(addr_t raddr, uint32_t exp, uint32_t mask0, uint32_t mask1)
+{
+    int32_t result = -1;
+    uint32_t rdata = ioread32(raddr);
+
+    if ((0 != mask0) && (0 == mask1))
+    {
+        if ((rdata & mask0) == (exp & mask0))
+        {
+            result = 0;
+        }
+    }
+    else if ((0 == mask0) && (0 != mask1))
+    {
+        if ((rdata & mask1) == (exp & mask1))
+        {
+            result = 0;
+        }
+    }
+    else if ((0 != mask0) && (0 != mask1))
+    {
+        if (((rdata & mask0) == (exp & mask0)) || ((rdata & mask1) == (exp & mask1)))
+        {
+            result = 0;
+        }
+    }
+
+    return result;
+}
+
+static int32_t cpg_check(addr_t addr, int32_t bit, uint32_t val)
+{
+    int32_t ret = -1;
+    uint32_t loop;
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(addr, (val << bit), (1 << bit), 0))
+        {
+            ret = 0;
+            break;
+        }
+        udelay(1);
+        loop++;
+    }
+
+    loop = 0;
+    while ((100 > loop) && (0 != ret))
+    {
+        if (0 == check_reg(addr, (val << bit), (1 << bit), 0))
+        {
+            ret = 0;
+            break;
+        }
+        usleep_range(100, 200);
+        loop++;
+    }
+
+    return ret;
+}
+
+#ifndef __KERNEL__
+/* about 3.9 sec maximum. */
+static void mdelay(uint32_t msecs)
+{
+    volatile uint32_t i;
+
+    for (i = 0; i < msecs * 1100000; i++);
+}
+#endif
+
+#ifdef __KERNEL__
+#if defined(CONFIG_ARCH_R9A09G057)
+/* V2H conditional compilation */
+MODULE_DESCRIPTION("RZ/V2H DRPAI driver");
+#endif
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
+#endif
diff -uprN old/drivers/drp/drp-core.h new/drivers/drp/drp-core.h
--- old/drivers/drp/drp-core.h	1970-01-01 09:00:00.000000000 +0900
+++ new/drivers/drp/drp-core.h	2024-02-15 18:32:33.000000000 +0900
@@ -0,0 +1,148 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP-AI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef DRP__H
+#define DRP__H
+
+//------------------------------------------------------------------------------------------------------------------
+// include
+//------------------------------------------------------------------------------------------------------------------
+#ifdef __KERNEL__
+#include <linux/types.h>  /* for stdint */
+#else
+#include <stdint.h>
+#endif
+
+//------------------------------------------------------------------------------------------------------------------
+// Macro
+//------------------------------------------------------------------------------------------------------------------
+#define R_DRP_SUCCESS                     (0)
+#define R_DRP_ERR_INVALID_ARG             (-1)
+#define R_DRP_ERR_INIT                    (-2)
+#define R_DRP_ERR_INT                     (-3)
+#define R_DRP_ERR_STOP                    (-4)
+#define R_DRP_ERR_RESET                   (-5)
+#define R_DRP_ERR_REG                     (-6)
+
+/* reserved */
+#define DRP_RESERVED_STP_ODIF_INTCNTO0    (0)
+#define DRP_RESERVED_STP_ODIF_INTCNTO1    (1)
+#define DRP_RESERVED_STP_ODIF_INTCNTO2    (2)
+#define DRP_RESERVED_STP_ODIF_INTCNTO3    (3)
+#define DRP_RESERVED_EXD0_ODIF_INTCNTO0   (4)
+#define DRP_RESERVED_EXD0_ODIF_INTCNTO1   (5)
+#define DRP_RESERVED_EXD1_ODIF_INTCNTO0   (6)
+#define DRP_RESERVED_EXD1_ODIF_INTCNTO1   (7)
+#define DRP_RESERVED_STP_DSCC_PAMON       (8)  /* for debug */
+#define DRP_RESERVED_EXD0_DSCC_PAMON      (9)  /* for debug */
+#define DRP_RESERVED_AID0_DSCC_PAMON      (10) /* for debug */
+#define DRP_RESERVED_STP_ODIF_ELCPLS      (11) /* for debug (initial value) */
+#define DRP_RESERVED_EXD0_ODIF_ELCPLS     (12) /* for debug (initial value) */
+#define DRP_RESERVED_EXD1_ODIF_ELCPLS     (13) /* for debug (initial value) */
+
+/* for CPG reset */
+#define CPG_RESET_SUCCESS                   (0)
+#define RST_MAX_TIMEOUT                     (100)
+
+/* Debug macro (for only kernel) */
+//#define DRP_DRV_DEBUG
+#ifdef DRP_DRV_DEBUG
+#define DRP_DEBUG_PRINT(fmt, ...) \
+            pr_info("[%s: %d](pid: %d) "fmt, \
+                            __func__, __LINE__, current->pid, ##__VA_ARGS__)
+#else
+#define DRP_DEBUG_PRINT(...)
+#endif
+
+/* V2H CPG Control */
+#define DRP_CPG_CTL
+
+//------------------------------------------------------------------------------------------------------------------
+// typedef
+//------------------------------------------------------------------------------------------------------------------
+#ifdef __KERNEL__
+typedef void __iomem* addr_t;
+#else
+typedef uint64_t addr_t;
+#endif
+
+typedef struct drp_odif_intcnto
+{
+    uint32_t    ch0;
+    uint32_t    ch1;
+    uint32_t    ch2;
+    uint32_t    ch3;
+} drp_odif_intcnto_t;
+
+//------------------------------------------------------------------------------------------------------------------
+// Prototype
+//------------------------------------------------------------------------------------------------------------------
+int32_t R_DRP_DRP_Open(addr_t drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRP_DRP_Start(addr_t drp_base_addr, int32_t ch, uint64_t desc);
+int32_t R_DRP_DRP_Stop(addr_t drp_base_addr, int32_t ch, spinlock_t *lock);
+int32_t R_DRP_DRP_SetMaxFreq(addr_t drp_base_addr, int32_t ch, uint32_t mindiv);
+int32_t R_DRP_DRP_Nmlint(addr_t drp_base_addr, int32_t ch, drp_odif_intcnto_t *odif_intcnto);
+int32_t R_DRP_DRP_CLR_Nmlint(addr_t drp_base_addr, int32_t ch);
+void R_DRP_DRP_Errint(addr_t drp_base_addr, int32_t ch);
+int32_t R_DRP_AIMAC_Open(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_AIMAC_Start(addr_t aimac_base_addr, int32_t ch, uint64_t cmd_desc, uint64_t param_desc, spinlock_t *lock);
+int32_t R_DRP_AIMAC_Stop(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_AIMAC_SetFreq(addr_t aimac_base_addr, int32_t ch, uint32_t divfix);
+int32_t R_DRP_AIMAC_Nmlint(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_AIMAC_Errint(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_Status(addr_t drp_base_addr, addr_t aimac_base_addr, int32_t ch, uint32_t *reserved);
+int32_t R_DRP_AIMAC_Reset(addr_t aimac_base_addr, int32_t ch);
+int32_t R_DRP_DRP_RegRead(addr_t drp_base_addr, uint32_t offset, uint32_t* pvalue);
+void    R_DRP_DRP_RegWrite(addr_t drp_base_addr, uint32_t offset, uint32_t value);
+int32_t R_DRP_AIMAC_RegRead(addr_t aimac_base_addr, uint32_t offset, uint32_t* pvalue);
+void    R_DRP_AIMAC_RegWrite(addr_t aimac_base_addr, uint32_t offset, uint32_t value);
+int32_t R_DRP_DRP_SetAdrConv(addr_t drp_base_addr, int32_t ch, uint64_t* addr);
+int32_t R_DRP_DRP_ResetDmaoffset(addr_t drp_base_addr, int32_t ch);
+int32_t R_DRP_DRP_GetLastDescAddr(addr_t drp_base_addr, int32_t page, uint64_t* addr);
+int32_t R_DRP_SetFreq(addr_t drp_base_addr, int32_t ch, uint32_t divfix);
+int32_t R_DRP_DRP_RegRead(addr_t drp_base_addr, uint32_t offset, uint32_t* pvalue);
+void    R_DRP_DRP_RegWrite(addr_t drp_base_addr, uint32_t offset, uint32_t value);
+
+//------------------------------------------------------------------------------------------------------------------
+// Prototype(Preliminaly)
+//------------------------------------------------------------------------------------------------------------------
+void set_debug_mode(addr_t aimac_base_addr); /* for debug */
+
+void drp_bootseq_drp(addr_t drp_base_addr, uint32_t *drp_addr_relocatable_tbl);
+void aimac_bootseq(addr_t aimac_base_addr, uint32_t *aimac_addr_relocatable_tbl);
+void set_drp_desc_drp(addr_t drp_base_addr, uint64_t drp_desc_addr);
+void set_aimac_desc(addr_t aimac_base_addr, uint64_t cmd_desc_addr, uint64_t param_desc_addr);
+void start_prefetch_drp_drp(addr_t drp_base_addr);
+void start_prefetch_aimac(addr_t aimac_base_addr);
+int32_t drp_int_wait(addr_t drp_base_addr, uint32_t int_cnt, uint32_t wait_time);
+int32_t stop_prefetch_drp_drp(addr_t drp_base_addr);
+void stop_prefetch_aimac(addr_t aimac_base_addr);
+void drp_finalize(addr_t drp_base_addr);
+void aimac_finalize(addr_t aimac_base_addr);
+
+int32_t initialize_cpg_drp(addr_t cpg_base_addr);
+int32_t cpg_reset_drp(addr_t cpg_base_addr, int32_t ch);
+int32_t set_bus_clock(uint32_t div_set);
+int32_t check_drp_errsts(addr_t drp_base_addr, uint32_t *log);     /* log = uint32_t * 9 */
+int32_t check_aimac_errsts(addr_t aimac_base_addr, uint32_t *log); /* log = uint32_t * 24 */
+
+void drp_regdump(addr_t drp_base_addr, uint8_t** dump);   /* for debug */ /* uint8_t* dump[23]; max size = 0xB00000 */
+void aimac_regdump(addr_t aimac_regdump, uint8_t** dump); /* for debug */ /* uint8_t* dump[53]; max size = 0x200000 */
+void dump_vmem_hmem(addr_t drp_base_addr, uint16_t** vmem, uint16_t* hmem); /* for debug */ /* uint16_t* vmem[4]; max size = (under inv.) hmem = uint16 * (under inv.) */
+void get_aimac_info(addr_t drp_base_addr, addr_t aimac_base_addr, uint32_t* sync_tbl, uint64_t* cycle_counter); /* sync_tbl[32], cycle_counter[3] */
+
+
+#endif /* DRP__H */
diff -uprN old/drivers/drp/drp-if.c new/drivers/drp/drp-if.c
--- old/drivers/drp/drp-if.c	1970-01-01 09:00:00.000000000 +0900
+++ new/drivers/drp/drp-if.c	2024-02-15 18:11:52.000000000 +0900
@@ -0,0 +1,2157 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/cacheflush.h>
+#include <asm/current.h>
+#include <asm/io.h>
+#include <asm/uaccess.h>
+#include <linux/cdev.h>
+#include <linux/device.h>
+#include <linux/dma-mapping.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/interrupt.h>
+#include <linux/io.h>
+#include <linux/kernel.h>
+#include <linux/miscdevice.h>
+#include <linux/module.h>
+#include <linux/of.h>
+#include <linux/of_address.h>
+#include <linux/of_device.h>
+#include <linux/platform_device.h>
+#include <linux/pm.h>
+#include <linux/poll.h>
+#include <linux/sched.h>
+#include <linux/slab.h>
+#include <linux/types.h>
+#include <linux/uaccess.h>
+#include <linux/wait.h>
+#include <linux/fs.h>
+#include <asm/uaccess.h>
+#include <linux/buffer_head.h>
+#include <linux/dma-mapping.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <linux/reset.h>
+#include <linux/drp.h>    /* Header file for DRP-AI Driver */
+#include "drp-core.h"     /* Header file for DRP-AI Core */
+#include "lock_drp.h"     /* multi OS exclusion control */
+#include <generated/autoconf.h>
+
+// #define DRP_DRV_DEBUG_WAIT
+#ifdef DRP_DRV_DEBUG_WAIT
+#define DRP_DEBUG_WAIT(...) msleep(1100);
+#else
+#define DRP_DEBUG_WAIT(...)
+#endif
+
+#ifdef DRP_DRV_DEBUG
+#define DRP_DRV_DEBUG_MODE        " (Debug Mode ON)"
+#else
+#define DRP_DRV_DEBUG_MODE        ""
+#endif
+
+#ifdef DRP_DRV_DEBUG_WAIT
+#define DRP_DRV_DEBUG_WAIT_MODE   " (Debug Wait Mode ON)"
+#else
+#define DRP_DRV_DEBUG_WAIT_MODE   ""
+#endif
+
+/*Macro definitions*/
+#define SYS_SIZE                    (1024)
+#define SYS_DRP_BANK                (0x38)
+#define SYS_MASK_DRP                (0x00000300)
+#define SYS_SHIFT                   (24)
+
+#if defined(CONFIG_ARCH_R9A09G057)
+#define DRP_DRIVER_VERSION        "1.00 rel.4"
+#else
+#define DRP_DRIVER_VERSION        "2.00 rel.3"
+#endif
+#define DRP_DEV_NUM                (1)
+#define DRP_DRIVER_NAME            "drp"     /* Device name */
+#define DRP_64BYTE_ALIGN           (0x3F)      /* Check 64-byte alignment */
+#define DRP_STATUS_IDLE_RW         (10)
+#define DRP_STATUS_ASSIGN          (11)
+#define DRP_STATUS_READ_MEM        (13)
+#define DRP_STATUS_WRITE           (15)
+
+#define DRP_SGL_DRP_DESC_SIZE      (80)
+#define DRP_DESC_CMD_SIZE          (16)
+#define DRP_CMA_SIZE               ((DRP_SGL_DRP_DESC_SIZE * DRP_SEQ_NUM) + DRP_DESC_CMD_SIZE + 64)
+
+#define DRP_MAX_PROCESS_CFG        (1)
+#define MAX_SEM_TIMEOUT             (msecs_to_jiffies(1000))
+#define DRP_IRQ_CHECK_ENABLE        (1)
+#define DRP_IRQ_CHECK_DISABLE       (0)
+
+#if 1 /* for CPG direct access (preliminary) */
+#define CPG_SIZE                    (0x10000)
+#define CPG_BASE_ADDRESS            (0x10420000uLL)
+#endif
+
+/* from drp-core.h */
+#define DEVICE_RZV2MA               (0)
+#define DEVICE_RZV2H                (1)
+
+/* preliminary for V2H */
+#undef CONFIG_ARCH_R9A09G011GBG
+#undef CONFIG_ARCH_R9A09G055MA3GBG
+#undef CONFIG_ARCH_R9A07G054
+
+#if defined(CONFIG_ARCH_R9A09G057)
+/* V2H conditional compilation */
+#define DRP_CH_NUM                  (2)
+#elif defined(CONFIG_ARCH_R9A09G011GBG) 
+/* V2M conditional compilation */
+#define DRP_CH_NUM                  (1)
+#elif defined(CONFIG_ARCH_R9A09G055MA3GBG)
+/* V2MA conditional compilation */
+#define DRP_CH_NUM                  (2)
+#elif defined(CONFIG_ARCH_R9A07G054)
+/* V2L conditional compilation */
+#define DRP_CH_NUM                  (1)
+#endif
+
+/* drp device channel no */
+#define DRP_CH                      (1)     //(V2H) DRP-AI:0, DRP:1
+
+#define VAL_40BIT_OVER  (0x10000000000uLL)
+#define VAL_16M         (0x0000000001000000uLL)
+
+/* A function called from the kernel */
+static int drp_probe(struct platform_device *pdev);
+static int drp_remove(struct platform_device *pdev);
+static int drp_open(struct inode *inode, struct file *file);
+static int drp_close(struct inode *inode, struct file *file);
+static int drp_flush(struct file *file, fl_owner_t id);
+static ssize_t  drp_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos);
+static ssize_t  drp_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos);
+static long drp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg); 
+static unsigned int drp_poll( struct file* filp, poll_table* wait );
+static irqreturn_t irq_drp_nmlint(int irq, void *dev);
+static irqreturn_t irq_drp_errint(int irq, void *dev);
+
+/* Internal function */
+static int drp_regist_driver(void);
+static int drp_regist_device(struct platform_device *pdev);
+static void drp_unregist_driver(void);
+static void drp_unregist_device(void);
+static void drp_init_device(uint32_t ch);
+static int8_t drp_cpg_reset(uint32_t ch);
+static int8_t drp_stop_device(uint32_t ch);
+static long drp_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_get_codec_area(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_get_opencva_area(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_set_drp_freq(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_read_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+static long drp_ioctl_write_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg);
+
+static int drp_drp_cpg_init(void);
+static int drp_flag_test_and_set(unsigned int num);
+static void drp_flag_clear(unsigned int num);
+static int drp_flag_test(unsigned int num);
+
+/* Linux device driver initialization */
+static const unsigned int MINOR_BASE = 1;
+static const unsigned int MINOR_NUM  = DRP_DEV_NUM;       /* Minor number */
+static unsigned int drp_major;                    /* Major number (decided dinamically) */
+static struct cdev drp_cdev;                      /* Character device object */
+static struct class *drp_class = NULL;            /* class object */
+struct device *drp_device_array[DRP_DEV_NUM];
+
+/* for 40bit address */
+#define ADR_CONV_MASK   (0x000000FFFF000000uLL)
+#define ADR_LOW_24BIT   (0x00FFFFFFuL)
+#define MAX_IODATA_NUM  (PARAM_ADDRESS_NUM)
+#define ADRCONV_TBL_NUM  (256)
+static uint64_t drp_adrconv_tbl[ADRCONV_TBL_NUM];
+static uint64_t last_drp_config_address = 0;
+
+/* for Config load skip */
+#define LOAD_SKIP_OFFSET    (16)
+
+/* for change DRP frequency */
+#define DRP_DIVFIX_MIN      (2)
+#define DRP_DIVFIX_MAX      (127)
+
+/* for multi OS exclusion control */
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+static unsigned long long *drp_os_exclusion;
+static resource_size_t drp_region_drp_multi_os_base_addr = 0;
+static resource_size_t drp_region_drp_multi_os_size = 0;
+#define DRPFLAG_DRP_USED    (0)
+#define DRPFLAG_DRP_INIT    (1)
+#define DRPFLAG_CLK_STOP    (2)
+#endif
+static int drp_irqnum_nmlint;
+static int drp_irqnum_errint;
+
+struct drp_priv {
+    struct platform_device *pdev;
+    const char *dev_name;
+    spinlock_t lock;
+    void __iomem *drp_base;
+    struct semaphore sem;
+    uint32_t drp_irq_flag;
+    struct reset_control *rstc;
+    refcount_t count;
+    drp_status_t drp_status;
+    /* Set first proc flag */
+    uint32_t drp_first_proc_after_init;
+};
+
+struct drp_desc_info
+{
+    drp_seq_t seq;
+    char* vaddr;
+    uint64_t phyaddr;
+    uint64_t drp_desc_adr_40bit;
+    uint32_t drp_iodata_num;
+    uint32_t drp_load_force;
+    uint32_t drp_mindiv;
+};
+
+/* Virtual base address of register */
+static void __iomem *drp_base_addr[DRP_CH_NUM];
+#define DRP_CPG_CTL (1)     //for CPG direct access (preliminary)
+#ifdef DRP_CPG_CTL
+static void __iomem *cpg_base_address;
+static resource_size_t cpg_size;
+#endif
+static resource_size_t drp_size;
+#ifndef CONFIG_ARCH_R9A09G057
+static resource_size_t sysctrl_region_base_addr;
+#endif
+
+/* Virtual base address of register */
+static resource_size_t drp_size;
+static resource_size_t sysctrl_region_base_addr;
+static resource_size_t drp_region_codec_base_addr = 0;
+static resource_size_t drp_region_codec_size = 0;
+static resource_size_t drp_region_oca_base_addr = 0;
+static resource_size_t drp_region_oca_size = 0;
+
+/* handler table */
+static struct file_operations s_mydevice_fops = {
+    .open           = drp_open,
+    .release        = drp_close,
+    .write          = drp_write,
+    .read           = drp_read,
+    .unlocked_ioctl = drp_ioctl,
+    .compat_ioctl   = drp_ioctl, /* for 32-bit App */
+    .poll           = drp_poll,
+    .flush          = drp_flush,
+};
+
+static const struct of_device_id drp_match[] = {
+
+    { .compatible = "renesas,rzv2ma-drp",},
+    { .compatible = "renesas,rzv2h-drp",},
+    { /* sentinel */ }
+};
+static struct platform_driver drp_platform_driver = {
+    .driver = {
+        .name   = "drp-rz",
+        .of_match_table = drp_match,
+    },
+    .probe      = drp_probe,
+    .remove     = drp_remove,
+};
+
+static struct drp_priv *drp_priv;
+static DECLARE_WAIT_QUEUE_HEAD(read_q);
+static DEFINE_SEMAPHORE(rw_sem);
+static drp_data_t drp_data;
+static uint32_t rw_status;
+static uint32_t write_count;
+static uint32_t read_count;
+
+/* DRP single operation */
+static drp_data_t proc[DRP_SEQ_NUM * 2];
+/*DRP Descriptor*/
+// 1. Load drpcfg
+// 2. Set DRP core
+// 3. Read DRP param
+// 4. Start processing of DRP
+// 5. Link descriptor
+// 6. AIMAC descriptor
+static unsigned char drp_single_desc_bin[] =
+{
+  0x00, 0x02, 0x00, 0x11, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x07, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x88, 0x00, 0x01, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+static drp_seq_t seq;
+static drp_odif_intcnto_t odif_intcnto;
+
+static int drp_probe(struct platform_device *pdev)
+{
+    int ret;
+
+    ret = drp_regist_driver();
+    if (0 != ret)
+    {
+        return ret;
+    }
+
+    ret = drp_regist_device(pdev);
+    if (0 != ret)
+    {
+        drp_unregist_driver();
+        return ret;
+    }
+
+    return ret;
+}
+
+static int drp_remove(struct platform_device *pdev)
+{
+    drp_unregist_driver();
+    drp_unregist_device();
+
+    return 0;
+}
+
+static int drp_open(struct inode *inode, struct file *file)
+{
+    int result = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    struct drp_desc_info *desc_info;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    int flag_drp_used = -1;
+    int flag_drp_init = -1;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT)))
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    DRP_DEBUG_WAIT();
+
+    if(1 == refcount_read(&priv->count))
+    {
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        flag_drp_used = drp_flag_test_and_set(DRPFLAG_DRP_USED);
+        if( -1 == flag_drp_used)
+        {
+            /* DRPFLAG_DRP_USED is already set */
+            result = -EALREADY;
+            goto end;
+        }
+        if( 0 != flag_drp_used)
+        {
+            /* OS shared memory unavailable */
+            result = -ENODATA;
+            goto end;
+        }
+
+        flag_drp_init = drp_flag_test_and_set(DRPFLAG_DRP_INIT);
+        if( 0 != flag_drp_init)
+        {
+            /* DRPFLAG_DRP_INIT is already set */
+            /* DO NOTHING */
+        }
+        else
+        {
+#endif
+            /* Initialize CPG (DRP CPG On) */
+            if(R_DRP_SUCCESS != drp_drp_cpg_init())
+            {
+                result = -EIO;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+                drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+                goto end;
+            }
+
+            /* Initialize DRP procedure */
+            drp_init_device(DRP_CH);
+
+            /* Finalize DRP procedure */
+            if(R_DRP_SUCCESS != drp_stop_device(DRP_CH))
+            {
+                result = -EIO;
+                DRP_DEBUG_PRINT("Reset failed\n");
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+                drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+                goto end;
+            }
+            /* Reset DRP (CPG Reset)*/
+            if(R_DRP_SUCCESS != drp_cpg_reset(DRP_CH))
+            {
+                result = -EIO;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+                drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+                goto end;
+            }
+
+            /* Initialize DRP procedure */
+            drp_init_device(DRP_CH);
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+            drp_flag_clear(DRPFLAG_CLK_STOP);
+        }
+#endif
+
+        /* INIT -> IDLE */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_status.status = DRP_STATUS_IDLE;
+        /* Set first proc flag */
+        priv->drp_first_proc_after_init = 1;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        /* Initialization flag */
+        rw_status = DRP_STATUS_IDLE_RW;
+        
+    }
+
+    desc_info = kzalloc(sizeof(struct drp_desc_info), GFP_KERNEL);
+    if (!desc_info)
+    {
+        result = -ENOMEM;
+        goto end;
+    }
+
+    /* DRP single operation */
+    desc_info->vaddr = NULL;
+    desc_info->phyaddr = 0x0;
+    file->private_data = desc_info;
+    desc_info->drp_mindiv = 2;
+
+    /* Increment reference count */
+    refcount_inc(&priv->count);
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    goto end;
+end:
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    if( 0 == flag_drp_used)
+    {
+        drp_flag_clear(DRPFLAG_DRP_USED);
+    }
+#endif
+    if((-ETIMEDOUT != result))
+    {
+        up(&priv->sem);
+    }
+
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int drp_close(struct inode *inode, struct file *file)
+{
+    int result = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    int flag_drp_used = -1;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        /* Note: this errno won't be returned to user*/
+        result = -ETIMEDOUT;
+        DRP_DEBUG_PRINT("API semaphore obtained failed\n");
+        goto end;
+    }
+
+    DRP_DEBUG_WAIT();
+
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    if(2 == refcount_read(&priv->count))
+    {
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        flag_drp_used = drp_flag_test_and_set(DRPFLAG_DRP_USED);
+        if( 0 == flag_drp_used)
+        {
+#endif
+            /* Finalize DRP procedure */
+            if(R_DRP_SUCCESS != drp_stop_device(DRP_CH))
+            {
+                DRP_DEBUG_PRINT("Reset failed\n");
+            }
+            /* Reset DRP (CPG Reset)*/
+            if(R_DRP_SUCCESS != drp_cpg_reset(DRP_CH))
+            {
+                result = -EIO;
+            }
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+            drp_flag_clear(DRPFLAG_DRP_INIT);
+        }
+#endif
+        /* IDLE -> INIT */
+        /* RUN  -> INIT */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_status.status = DRP_STATUS_INIT;
+        priv->drp_status.err    = DRP_ERRINFO_SUCCESS;
+
+        /* IDLE_RW */
+        rw_status = DRP_STATUS_IDLE_RW;
+        spin_unlock_irqrestore(&priv->lock, flags);
+    }
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    DRP_DEBUG_WAIT();
+
+   /* Decrement referenece count */
+    refcount_dec(&priv->count);
+    goto end;
+end:
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    if( 0 == flag_drp_used)
+    {
+        drp_flag_clear(DRPFLAG_DRP_USED);
+    }
+#endif
+
+    if((-ETIMEDOUT != result))
+    {
+        up(&priv->sem);
+    if(file->private_data) 
+    {
+        DRP_DEBUG_PRINT("kfree is called\n");
+        kfree(file->private_data);
+        file->private_data = NULL;
+    }
+    }
+
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int drp_flush(struct file *file, fl_owner_t id)
+{
+    DRP_DEBUG_PRINT("start.\n");
+    DRP_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+static ssize_t  drp_write(struct file *filp, const char __user *buf, size_t count, loff_t *f_pos)
+{
+    ssize_t result = 0;
+    void *p_drp_cma = 0;
+    uint64_t addr;
+    struct drp_priv *priv = drp_priv;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    DRP_DEBUG_WAIT();
+
+    /* Check status */
+    if (!((DRP_STATUS_ASSIGN == rw_status) || (DRP_STATUS_WRITE == rw_status)))
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check Argument */
+    if (NULL == buf)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if (0 == count)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* DRP_STATUS_ASSIGN -> DRP_STATUS_WRITE */
+    /* DRP_STATUS_WRITE  -> DRP_STATUS_WRITE */
+    rw_status = DRP_STATUS_WRITE;
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    /* Expand to DRP for CMA */
+    addr = (uint64_t)drp_data.address;
+    p_drp_cma = phys_to_virt(addr + (uint64_t)write_count);
+    if (p_drp_cma == 0)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if ( !( drp_data.size >= (write_count + count) ) )
+    {
+        count = drp_data.size - write_count;
+    }
+    if (copy_from_user(p_drp_cma, buf, count))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    write_count = write_count + count;
+
+    /* DRP_STATUS_WRITE -> DRP_STATUS_IDLE_RW */
+    if (drp_data.size <= write_count)
+    {
+        p_drp_cma = phys_to_virt(addr);
+        if (p_drp_cma == 0)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        __flush_dcache_area(p_drp_cma, drp_data.size);
+        rw_status = DRP_STATUS_IDLE_RW;
+    }
+
+    result = count;
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRP_DEBUG_PRINT("status_rw3:%d\n", rw_status);
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static ssize_t drp_read(struct file *filp, char __user *buf, size_t count, loff_t *f_pos)
+{
+    ssize_t result = 0;
+    void *p_drp_cma = 0;
+    uint32_t i;
+    uint64_t addr;
+    struct drp_priv *priv = drp_priv;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    DRP_DEBUG_WAIT();
+
+    /* Check status */
+    if (!((DRP_STATUS_ASSIGN  == rw_status) ||
+        (DRP_STATUS_READ_MEM  == rw_status)))
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check Argument */
+    if (NULL == buf)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    if (0 == count)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* DRP_STATUS_ASSIGN -> DRP_STATUS_READ_MEM */
+    if (DRP_STATUS_ASSIGN == rw_status)
+    {
+        rw_status = DRP_STATUS_READ_MEM;
+    }
+    else
+    {
+        ; /* Do nothing */
+    }
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    /* Read DRP-AI memory */
+    if (DRP_STATUS_READ_MEM == rw_status)
+    {
+        addr = (uint64_t)drp_data.address;
+        p_drp_cma = phys_to_virt(addr + (uint64_t)read_count);
+        if (p_drp_cma == 0)
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        if ( !( drp_data.size >= (read_count + count) ) )
+        {
+            count = drp_data.size - read_count;
+        }
+        /* Copy arguments from kernel space to user space */
+        if (copy_to_user(buf, p_drp_cma, count))
+        {
+            result = -EFAULT;
+            goto end;
+        }
+        read_count = read_count + count;
+
+        /* DRP_STATUS_READ -> DRP_STATUS_IDLE_RW */
+        if (drp_data.size <= read_count)
+        {
+            rw_status = DRP_STATUS_IDLE_RW;
+        }
+        i = count;
+    }
+    else
+    {
+        ; /* Do nothing */
+    }
+
+    result = i;
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRP_DEBUG_PRINT("status_rw3:%d\n", rw_status);
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+
+    switch (cmd) {
+    case DRP_ASSIGN:
+        DRP_DEBUG_PRINT("ioctl(DRP_ASSIGN)\n");
+        result = drp_ioctl_assign(filp, cmd, arg);
+        break;
+    case DRP_START:
+        DRP_DEBUG_PRINT("ioctl(DRP_START)\n");
+        result = drp_ioctl_start(filp, cmd, arg);
+        break;
+    case DRP_RESET:
+        DRP_DEBUG_PRINT("ioctl(DRP_RESET)\n");
+        result = drp_ioctl_reset(filp, cmd, arg);
+        break;
+    case DRP_GET_STATUS:
+        DRP_DEBUG_PRINT("ioctl(DRP_GET_STATUS)\n");
+        result = drp_ioctl_get_status(filp, cmd, arg);
+        break;
+    case DRP_SET_SEQ:
+        DRP_DEBUG_PRINT("ioctl(DRP_SET_SEQ)\n");
+        result = drp_ioctl_set_seq(filp, cmd, arg);
+        break;
+    case DRP_GET_CODEC_AREA:
+        DRP_DEBUG_PRINT("ioctl(DRP_GET_CODEC_AREA)\n");
+        result = drp_ioctl_get_codec_area(filp, cmd, arg);
+        break;
+    case DRP_GET_OPENCVA_AREA:
+        DRP_DEBUG_PRINT("ioctl(DRP_GET_OPENCVA_AREA)\n");
+        result = drp_ioctl_get_opencva_area(filp, cmd, arg);
+        break;
+    case DRP_SET_DRP_MAX_FREQ:
+        DRP_DEBUG_PRINT("ioctl(DRP_SET_DRP_FREQ)\n");
+        result = drp_ioctl_set_drp_freq(filp, cmd, arg);
+        break;
+    case DRP_READ_DRP_REG:
+        DRP_DEBUG_PRINT("[ioctl(DRP_READ_DRP_REG)]\n");
+        result = drp_ioctl_read_drp_reg(filp, cmd, arg);
+        break;
+    case DRP_WRITE_DRP_REG:
+        DRP_DEBUG_PRINT("[ioctl(DRP_WRITE_DRP_REG)]\n");
+        result = drp_ioctl_write_drp_reg(filp, cmd, arg);
+        break;
+    default:
+        DRP_DEBUG_PRINT("unsupported command %d\n", cmd);
+        result = -EFAULT;
+        break;
+    }
+    goto end;
+
+end:
+    return result;
+}
+
+static unsigned int drp_poll( struct file* filp, poll_table* wait )
+{
+    unsigned int retmask = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    spin_lock_irqsave(&priv->lock, flags);
+    poll_wait( filp, &read_q,  wait );
+
+    if (DRP_IRQ_CHECK_DISABLE == priv->drp_irq_flag)
+    {
+        /* Notify wakeup to user */
+        retmask |= ( POLLIN  | POLLRDNORM );
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("end.\n");
+    return retmask;
+}
+static irqreturn_t irq_drp_nmlint(int irq, void *dev)
+{
+    drp_odif_intcnto_t local_odif_intcnto;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+
+    DRP_DEBUG_PRINT("start.\n");
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+
+    spin_lock_irqsave(&priv->lock, flags);
+    /* DRP normal interrupt processing */
+    R_DRP_DRP_Nmlint(drp_base_addr[0], 0, &local_odif_intcnto);
+
+    odif_intcnto.ch0 += local_odif_intcnto.ch0;
+
+    DRP_DEBUG_PRINT("ODIF_INTCNTO0 : 0x%08X\n", odif_intcnto.ch0);
+
+    if (seq.num == odif_intcnto.ch0)
+    {
+        int32_t drp_ret;
+         /* Internal state update */
+        priv->drp_status.status = DRP_STATUS_IDLE;
+        priv->drp_irq_flag  = DRP_IRQ_CHECK_DISABLE;
+
+        /* Wake up the process */
+        drp_ret = R_DRP_DRP_CLR_Nmlint(drp_base_addr[0], 0);
+        if( 0 != drp_ret )
+        {
+            /* Internal state update(ERROR) */
+            priv->drp_status.err    = DRP_ERRINFO_DRP_ERR;
+        }
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        drp_flag_clear(DRPFLAG_DRP_USED);
+#endif
+        wake_up_interruptible( &read_q );
+    }
+    else if(seq.num < odif_intcnto.ch0)
+    {
+        /* Internal state update(ERROR) */
+        priv->drp_status.err    = DRP_ERRINFO_DRP_ERR;
+        priv->drp_status.status = DRP_STATUS_IDLE;
+        priv->drp_irq_flag  = DRP_IRQ_CHECK_DISABLE;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        drp_flag_clear(DRPFLAG_DRP_USED);
+#endif
+        wake_up_interruptible( &read_q );
+    }
+    else
+    {
+        /* DO NOTHING */
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("end.\n");
+    return IRQ_HANDLED;
+}
+static irqreturn_t irq_drp_errint(int irq, void *dev)
+{
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+
+    DRP_DEBUG_PRINT("start.\n");
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+
+    spin_lock_irqsave(&priv->lock, flags);
+    /* DRP error interrupt processing */
+    R_DRP_DRP_Errint(drp_base_addr[0], 0);
+
+    /* Internal state update */
+    priv->drp_status.err    = DRP_ERRINFO_DRP_ERR;
+    priv->drp_status.status = DRP_STATUS_IDLE;
+    priv->drp_irq_flag  = DRP_IRQ_CHECK_DISABLE;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    drp_flag_clear(DRPFLAG_DRP_USED);
+#endif
+
+    /* Wake up the process */
+    wake_up_interruptible( &read_q );
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("end.\n");
+    return IRQ_HANDLED;
+}
+
+static int drp_regist_driver(void)
+{
+    int alloc_ret = 0;
+    int cdev_err = 0;
+    dev_t dev;
+    int minor;
+    int ptr_err;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Get free major number. */
+    alloc_ret = alloc_chrdev_region(&dev, MINOR_BASE, MINOR_NUM, DRP_DRIVER_NAME);
+    if (alloc_ret != 0) {
+        pr_err("DRP Driver: alloc_chrdev_region = %d\n", alloc_ret);
+        return -ENOMEM;
+    }
+
+    /* Save major number. */
+    drp_major = MAJOR(dev);
+    dev = MKDEV(drp_major, MINOR_BASE);
+
+    /* Initialize cdev and registration handler table. */
+    cdev_init(&drp_cdev, &s_mydevice_fops);
+    drp_cdev.owner = THIS_MODULE;
+
+    /* Registration cdev */
+    cdev_err = cdev_add(&drp_cdev, dev, MINOR_NUM);
+    if (cdev_err != 0) {
+        pr_err("DRP Driver: cdev_add = %d\n", cdev_err);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return -ENOMEM;
+    }
+
+    /* Cleate class "/sys/class/drp/" */
+    drp_class = class_create(THIS_MODULE, DRP_DRIVER_NAME);
+    if (IS_ERR(drp_class)) {
+        ptr_err = PTR_ERR(drp_class);
+        pr_err("DRP Driver: class_create = %d\n", ptr_err);
+        cdev_del(&drp_cdev);
+        unregister_chrdev_region(dev, MINOR_NUM);
+        return -ENOMEM;
+    }
+
+    /* Make "/sys/class/drp/drp*" */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        drp_device_array[minor - MINOR_BASE] =
+        device_create(drp_class, NULL, MKDEV(drp_major, minor), NULL, DRP_DRIVER_NAME "%d", minor);
+    }
+
+    DRP_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+static int drp_regist_device(struct platform_device *pdev)
+{
+    struct resource *res;
+    struct resource reserved_res;
+    struct device_node *np;
+    int ret;
+    struct drp_priv *priv;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    priv = devm_kzalloc(&pdev->dev, sizeof(struct drp_priv), GFP_KERNEL);
+    if (!priv) {
+        dev_err(&pdev->dev, "cannot allocate private data\n");
+        return -ENOMEM;
+    }
+
+    /*Initialize DRP private structure*/
+    platform_set_drvdata(pdev, priv);
+    priv->pdev = pdev;
+    priv->dev_name = dev_name(&pdev->dev);
+    spin_lock_init(&priv->lock);
+    sema_init(&priv->sem, DRP_DEV_NUM);
+    priv->drp_irq_flag = DRP_IRQ_CHECK_DISABLE;
+    drp_priv = priv;
+    refcount_set(&priv->count, 1);
+
+    dev_info(&pdev->dev, "DRP Driver version : %s V2H\n", DRP_DRIVER_VERSION DRP_DRV_DEBUG_MODE DRP_DRV_DEBUG_WAIT_MODE);
+
+    /* Convert DRP base address from physical to virtual */
+    res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+    if (!res) {
+        dev_err(&pdev->dev, "cannot get resources (reg)\n");
+        return -EINVAL;
+    }
+    priv->drp_base = devm_ioremap(&pdev->dev, res->start, resource_size(res));
+    if (!priv->drp_base) {
+        dev_err(&pdev->dev, "cannot ioremap\n");
+        return -EINVAL;
+    }
+    drp_base_addr[0] = priv->drp_base;
+    drp_size = resource_size(res);
+    dev_info(&pdev->dev, "DRP base address 0x%08llX, size 0x%08llX\n", res->start, drp_size);
+
+    /* Registering an interrupt handler */
+    drp_irqnum_nmlint = platform_get_irq(pdev, 0);
+    ret = devm_request_irq(&pdev->dev, drp_irqnum_nmlint, irq_drp_nmlint, 0, "drp nmlint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+    drp_irqnum_errint = platform_get_irq(pdev, 1);
+    ret = devm_request_irq(&pdev->dev, drp_irqnum_errint, irq_drp_errint, 0, "drp errint", priv);
+    if (ret) {
+        dev_err(&pdev->dev, "Failed to claim IRQ!\n");
+        return ret;
+    }
+
+#ifdef DRP_CPG_CTL
+    cpg_size = CPG_SIZE;
+    cpg_base_address = ioremap(CPG_BASE_ADDRESS, cpg_size);
+    if (cpg_base_address == 0)
+    {
+        pr_info("[%s: %d](pid: %d) failed to get cpg_base_address\n", __func__, __LINE__, current->pid);
+        return -EINVAL;
+    }
+#endif
+    /* Get reset controller info */
+    priv->rstc = devm_reset_control_get(&pdev->dev, NULL);
+    if (IS_ERR(priv->rstc))
+    {
+        dev_err(&pdev->dev, "Failed to get DRP CPG reset controller\n");
+#if DRP_CPG_CTL
+        iounmap(cpg_base_address);
+#endif
+        return PTR_ERR(priv->rstc);
+    }
+    else
+    {
+        DRP_DEBUG_PRINT("Get DRP CPG reset controller\n");      
+    } 
+
+    /* Status initialization */
+    priv->drp_status.status = DRP_STATUS_INIT;
+
+    {
+        struct device_node *np;
+
+        drp_region_codec_base_addr = 0;
+        drp_region_codec_size = 0;
+        drp_region_oca_base_addr = 0;
+        drp_region_oca_size = 0;
+
+        np = of_parse_phandle(pdev->dev.of_node, "memory-region", 0);
+        if (!np) 
+        {
+            dev_err(&pdev->dev, "No %s specified\n", "memory-region");
+        }
+        else 
+        {
+           /* Convert memory region to a struct resource */
+            ret = of_address_to_resource(np, 0, &reserved_res);
+            if (ret) 
+            {
+                dev_err(&pdev->dev, "DRP(CODEC) memory was not assigned to the region\n");
+            }
+            else
+            {
+                drp_region_codec_base_addr = reserved_res.start;
+                drp_region_codec_size = resource_size(&reserved_res);
+                dev_info(&pdev->dev, "DRP(CODEC) memory region start 0x%016llX, size 0x%08llX\n", drp_region_codec_base_addr, drp_region_codec_size);
+            }
+        }
+
+        np = of_parse_phandle(pdev->dev.of_node, "memory-oca-region", 0);
+        if (!np) 
+        {
+            dev_err(&pdev->dev, "No %s specified\n", "memory-oca-region");
+        }
+        else 
+        {
+           /* Convert memory region to a struct resource */
+            ret = of_address_to_resource(np, 0, &reserved_res);
+            if (ret) 
+            {
+                dev_err(&pdev->dev, "DRP(OpenCVA) memory was not assigned to the region\n");
+            }
+            else
+            {
+                drp_region_oca_base_addr = reserved_res.start;
+                drp_region_oca_size = resource_size(&reserved_res);
+                dev_info(&pdev->dev, "DRP(OpenCVA) memory region start 0x%016llX, size 0x%08llX\n", drp_region_oca_base_addr, drp_region_oca_size);
+            }
+        }
+        
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        drp_os_exclusion = NULL;
+        np = of_parse_phandle(pdev->dev.of_node, "memory-shared", 0);
+        if (!np) 
+        {
+            dev_err(&pdev->dev, "No %s specified\n", "memory-shared");
+        }
+        else 
+        {
+           /* Convert memory region to a struct resource */
+            ret = of_address_to_resource(np, 0, &reserved_res);
+            if (ret) 
+            {
+                dev_err(&pdev->dev, "DRP(OS shared) memory was not assigned to the region\n");
+            }
+            else
+            {
+                drp_region_drp_multi_os_base_addr = reserved_res.start;
+                drp_region_drp_multi_os_size = resource_size(&reserved_res);
+                dev_info(&pdev->dev, "DRP(OS shared) memory region start 0x%016llX, size 0x%08llX\n", drp_region_drp_multi_os_base_addr, drp_region_drp_multi_os_size);
+                if( drp_region_drp_multi_os_size >= 8 )
+                {
+                    drp_os_exclusion = phys_to_virt(drp_region_drp_multi_os_base_addr);
+#ifdef CONFIG_DRP_INIT_SHARED_MEMORY
+                    *drp_os_exclusion = 0;
+#endif
+                }
+                else
+                {
+                    dev_err(&pdev->dev, "DRP(OS shared) memory is too small\n");
+                }
+            }
+        }
+#endif
+
+    }
+
+    DRP_DEBUG_PRINT("end.\n");
+    return 0;
+}
+
+static void drp_unregist_driver(void)
+{
+    dev_t dev = MKDEV(drp_major, MINOR_BASE);
+    int minor;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Delete "/sys/class/mydevice/mydevice*". */
+    for (minor = MINOR_BASE; minor < MINOR_BASE + MINOR_NUM; minor++) {
+        device_destroy(drp_class, MKDEV(drp_major, minor));
+    }
+
+    /* Destroy "/sys/class/mydevice/". */
+    class_destroy(drp_class);
+
+    /* Delete cdev from kernel. */
+    cdev_del(&drp_cdev);
+
+    /* Unregistration */
+    unregister_chrdev_region(dev, MINOR_NUM);
+    DRP_DEBUG_PRINT("end.\n");
+}
+
+static void drp_unregist_device(void)
+{
+#if DRP_CPG_CTL
+        iounmap(cpg_base_address);
+#endif
+}
+
+static void drp_init_device(uint32_t ch)
+{
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    DRP_DEBUG_PRINT("start.\n");
+
+
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drp_irq_flag = DRP_IRQ_CHECK_DISABLE;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    
+    (void)R_DRP_DRP_Open(drp_base_addr[0], 0, &priv->lock);
+
+    DRP_DEBUG_PRINT("end.\n");
+}
+
+static long drp_ioctl_assign(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    void *p_virt_address = 0;
+    uint64_t addr, size;
+    struct drp_priv *priv = drp_priv;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_trylock(&rw_sem)))
+    {
+        result = -ERESTART;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRP_STATUS_IDLE_RW != rw_status)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&drp_data, (void __user *)arg, sizeof(drp_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    /* Check Argument */
+    addr = (uint64_t)drp_data.address;
+    size = (uint64_t)drp_data.size;
+    if (0 != (addr & DRP_64BYTE_ALIGN))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    /* Check size over */
+    if (addr >= VAL_40BIT_OVER)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Data cache invalidate. DRP-AI W -> CPU R */
+    addr = (uint64_t)drp_data.address;
+    p_virt_address = phys_to_virt(addr);
+
+    if (p_virt_address == 0)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    __inval_dcache_area(p_virt_address, drp_data.size);
+
+    /* Initialization of read / write processing variables */
+    rw_status   = DRP_STATUS_ASSIGN;
+    write_count = 0;
+    read_count  = 0;
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ERESTART != result)
+    {
+        up(&rw_sem);
+    }
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_start(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    int result = 0;
+    int i;
+    int j;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    struct drp_desc_info *desc_info = filp->private_data;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    int flag_drp_used = -1;
+    int flag_drp_init = -1;
+    int flag_drp_clkstop = -1;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if(NULL == desc_info->vaddr)
+    {
+        result = -EACCES;
+        goto end;
+    }
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRP_STATUS_RUN == priv->drp_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&proc[0], (void __user *)arg, sizeof(proc)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    spin_lock_irqsave(&priv->lock, flags);
+    odif_intcnto.ch0 = 0;
+    odif_intcnto.ch1 = 0;
+    odif_intcnto.ch2 = 0;
+    odif_intcnto.ch3 = 0;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    /* Check Argument */
+    for (i = 0; i < (desc_info->seq.num * 2); i++)
+    {
+        if (0 != (proc[i].address & DRP_64BYTE_ALIGN))
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if( proc[i].address + proc[i].size >= VAL_40BIT_OVER )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if( proc[i].size > VAL_16M )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if( 0 == proc[i].size )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+        if( 0 == proc[i].address )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+
+    }
+
+    /* DRP config address(32bit) and size settings to descriptor */
+    /* (From here on, the code assumes seq.num == 1. It does not support seq.num >= 2.) */
+    *(uint32_t*)(desc_info->vaddr + 4) =  (uint32_t)(proc[0].address & ADR_LOW_24BIT);
+    *(uint32_t*)(desc_info->vaddr + 8) =  proc[0].size;
+
+    /* DRP parameter address(32bit) and size settings to descriptor */
+    *(uint32_t*)(desc_info->vaddr + 20) = (uint32_t)((proc[1].address & ADR_LOW_24BIT) | 0x02000000);
+    *(uint32_t*)(desc_info->vaddr + 24) =  proc[1].size;
+
+    /* LV disable */
+    *(desc_info->vaddr + 51) = 0x0A;
+
+    __flush_dcache_area(desc_info->vaddr, DRP_CMA_SIZE);
+
+    /* Set AdrConv Table */
+    /* drp_adrconv_tbl[Page] : 40-bit physical address associated for Page */
+
+    /* Page 00 - 01:For DRP config address */
+    int adrconv_cnt = 0;
+    drp_adrconv_tbl[adrconv_cnt++] = proc[0].address & ADR_CONV_MASK;
+    drp_adrconv_tbl[adrconv_cnt++] = drp_adrconv_tbl[0] + VAL_16M;
+
+    /* Page 02 - 03:For DRP parameter address */
+    drp_adrconv_tbl[adrconv_cnt++] = proc[1].address & ADR_CONV_MASK;
+    drp_adrconv_tbl[adrconv_cnt++] = drp_adrconv_tbl[2] + VAL_16M;
+
+    /* Page 04 - 05:For Descriptor address */
+    drp_adrconv_tbl[adrconv_cnt++] = desc_info->drp_desc_adr_40bit & ADR_CONV_MASK;
+    drp_adrconv_tbl[adrconv_cnt++] = drp_adrconv_tbl[4] + VAL_16M;
+
+    /* Page 06 -   :For DRP Input/Output data address in DRP parameters*/
+    char *param_addr = (char *)phys_to_virt(proc[1].address);
+    for( i = 0; i<desc_info->drp_iodata_num ; i++ )
+    {
+        uint64_t io_adr_start = desc_info->seq.iodata[i].address;
+        uint64_t io_adr_end   = desc_info->seq.iodata[i].address + desc_info->seq.iodata[i].size - 1;
+        uint32_t use_tbl_num  = (io_adr_end >> 24) - (io_adr_start >> 24) + 1;
+        uint32_t set_addr;
+        
+        if( adrconv_cnt + use_tbl_num > ADRCONV_TBL_NUM )
+        {
+            result = -ENOMEM;
+            goto end;
+        }
+        if( desc_info->seq.iodata[i].pos > proc[1].size - 4 )
+        {
+            result = -ENOSPC;
+            goto end;
+        }
+        set_addr = (adrconv_cnt << 24) | (uint32_t)(io_adr_start & ADR_LOW_24BIT);
+        param_addr[desc_info->seq.iodata[i].pos   ] = set_addr         & 0xFF;
+        param_addr[desc_info->seq.iodata[i].pos +1] = (set_addr >> 8)  & 0xFF;
+        param_addr[desc_info->seq.iodata[i].pos +2] = (set_addr >> 16) & 0xFF;
+        param_addr[desc_info->seq.iodata[i].pos +3] = (set_addr >> 24) & 0xFF;
+        for( j = 0; j < use_tbl_num; j++ )
+        {
+            drp_adrconv_tbl[adrconv_cnt++] = (io_adr_start & ADR_CONV_MASK) + j * VAL_16M;
+        }
+    }
+    __flush_dcache_area(param_addr, proc[1].size);
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    flag_drp_used = drp_flag_test_and_set(DRPFLAG_DRP_USED);
+    if( 0 != flag_drp_used)
+    {
+        /* DRPFLAG_DRP_USED is already set */
+        result = -EALREADY;
+        goto end;
+    }
+
+    flag_drp_init = drp_flag_test_and_set(DRPFLAG_DRP_INIT);
+    if( 0 == flag_drp_init)
+    {
+        /* Initialize CPG (DRP CPG On) */
+        if(R_DRP_SUCCESS != drp_drp_cpg_init())
+        {
+            result = -EIO;
+            drp_flag_clear(DRPFLAG_DRP_INIT);
+            goto end;
+        }
+
+        /* Reset DRP (CPG Reset)*/
+        if(R_DRP_SUCCESS != drp_cpg_reset(DRP_CH))
+        {
+            result = -EIO;
+            drp_flag_clear(DRPFLAG_DRP_INIT);
+            goto end;
+        }
+
+        /* Initialize DRP procedure */
+        drp_init_device(DRP_CH);
+
+        /* Set first proc flag */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_first_proc_after_init = 1;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        drp_flag_clear(DRPFLAG_CLK_STOP);
+    }
+
+    flag_drp_clkstop = drp_flag_test(DRPFLAG_CLK_STOP);
+    if( 0 != flag_drp_clkstop)
+    {
+        /* DRPFLAG_CLK_STOP is already set */
+        result = -EOPNOTSUPP;
+        goto end;
+    }
+#endif
+    /* Init drp_status.err */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drp_status.err = DRP_ERRINFO_SUCCESS;
+
+    /* IDLE -> RUN */
+    priv->drp_status.status = DRP_STATUS_RUN;
+    priv->drp_irq_flag  = DRP_IRQ_CHECK_ENABLE;
+    memcpy(&seq, &desc_info->seq, sizeof(drp_seq_t));
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+
+    /* Kick */
+    {
+        uint64_t last_descaddr;
+        uint32_t noload_offset = 0;
+        int32_t drp_ret;
+        uint32_t first_proc;
+        spin_lock_irqsave(&priv->lock, flags);
+        first_proc = priv->drp_first_proc_after_init;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        /* Check first proc */
+        if( first_proc != 0 ){
+            /* LOAD (Executed first time after initialization) */
+        }
+        else if( 0 != desc_info->drp_load_force )
+        {
+            /* LOAD (Forcefully) */
+        }
+        else
+        {
+            /* Get Descriptor Address (from DRP Register) */
+            drp_ret = R_DRP_DRP_GetLastDescAddr(drp_base_addr[0], 4, &last_descaddr);   /* Page 04:Descriptor address page*/
+            if( R_DRP_SUCCESS != drp_ret )
+            {
+                /* LOAD (Descriptor addres could no be obtained) */
+            }
+            else if( ( desc_info->phyaddr == last_descaddr ) || ( desc_info->phyaddr + LOAD_SKIP_OFFSET == last_descaddr ) )
+            {
+                /* Descriptor address matched the last one */
+                if( last_drp_config_address == proc[0].address )
+                {
+                    /* DRP Config address matched the last one */
+                    noload_offset = LOAD_SKIP_OFFSET; /* NOLOAD */
+                }
+            }
+            else
+            {
+                /* LOAD (DRP Config address is not determined) */
+            }
+        }
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        irq_set_affinity( drp_irqnum_nmlint, cpu_online_mask );
+        irq_set_affinity( drp_irqnum_errint, cpu_online_mask );
+        (void)R_DRP_DRP_ResetDmaoffset(drp_base_addr[0], 0);
+#endif
+        (void)R_DRP_DRP_SetAdrConv(drp_base_addr[0], 0, &drp_adrconv_tbl[0]);
+
+        (void)R_DRP_SetFreq(drp_base_addr[0], 0, desc_info->drp_mindiv);
+
+        /* Start DRP procedure */
+        (void)R_DRP_DRP_Start(drp_base_addr[0], 0, ((desc_info->phyaddr & ADR_LOW_24BIT) | 0x04000000) + noload_offset);
+
+        /* Clear first proc flag */
+        spin_lock_irqsave(&priv->lock, flags);
+        priv->drp_first_proc_after_init = 0;
+        spin_unlock_irqrestore(&priv->lock, flags);
+
+        /* Backup last config address */
+        last_drp_config_address = proc[0].address;
+    }
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    if( ( 0 == flag_drp_used) && (0 != result) )
+    {
+        drp_flag_clear(DRPFLAG_DRP_USED);
+    }
+#endif
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_reset(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    int flag_drp_used = -1;
+#endif
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+
+    DRP_DEBUG_PRINT("status1:   %d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw1:%d\n", rw_status);
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    flag_drp_used = drp_flag_test_and_set(DRPFLAG_DRP_USED);
+    if( 0 != flag_drp_used)
+    {
+        /* DRPFLAG_DRP_USED is already set */
+        result = -EALREADY;
+        goto end;
+    }
+    drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+
+    /* Finalize DRP procedure */
+    if(R_DRP_SUCCESS != drp_stop_device(DRP_CH))
+    {
+        result = -EIO;
+        DRP_DEBUG_PRINT("Reset failed\n");
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+        drp_flag_clear(DRPFLAG_DRP_INIT);
+#endif
+        goto end;
+    }
+
+    /* Initialize CPG (DRP CPG On) */
+    if(R_DRP_SUCCESS != drp_drp_cpg_init())
+    {
+        result = -EIO;
+        goto end;
+    }
+
+    /* Reset DRP (CPG Reset)*/
+    if(R_DRP_SUCCESS != drp_cpg_reset(DRP_CH))
+    {
+        result = -EIO;
+        goto end;
+    }
+
+    /* Initialize DRP procedure */
+    drp_init_device(DRP_CH);
+
+    /* Set first proc flag */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drp_first_proc_after_init = 1;
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    (void)drp_flag_test_and_set(DRPFLAG_DRP_INIT);
+    drp_flag_clear(DRPFLAG_CLK_STOP);
+#endif
+    /* Update internal state */
+    spin_lock_irqsave(&priv->lock, flags);
+    priv->drp_status.err    = DRP_ERRINFO_RESET;
+    priv->drp_status.status = DRP_STATUS_IDLE;
+
+    /* Wake up the process */
+    wake_up_interruptible( &read_q );
+    spin_unlock_irqrestore(&priv->lock, flags);
+
+    DRP_DEBUG_PRINT("status2:   %d\n", priv->drp_status.status);
+    DRP_DEBUG_PRINT("status_rw2:%d\n", rw_status);
+
+    result = 0;
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+    if( 0 == flag_drp_used)
+    {
+        drp_flag_clear(DRPFLAG_DRP_USED);
+    }
+#endif
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_get_status(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    drp_status_t local_drp_status;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRP_STATUS_RUN == priv->drp_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+
+    /* Copy arguments from kernel space to user space */
+    local_drp_status = priv->drp_status;
+    spin_unlock_irqrestore(&priv->lock, flags);
+    if (copy_to_user((void __user *)arg, &local_drp_status, sizeof(drp_status_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check DRP H/W error */
+    if (DRP_ERRINFO_DRP_ERR == local_drp_status.err)
+    {
+        result = -EIO;
+        goto end;
+    }
+
+    DRP_DEBUG_WAIT();
+    goto end;
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int8_t drp_cpg_reset(uint32_t ch)
+{
+    int8_t retval = R_DRP_SUCCESS;
+    struct drp_priv *priv = drp_priv;
+    int r_data;
+    int32_t i = 0;
+    bool is_stop = false;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    r_data = reset_control_status(priv->rstc);
+    DRP_DEBUG_PRINT("CPG reset_control_status before %d \n", r_data);
+
+    /* Access reset controller interface */
+    reset_control_reset(priv->rstc);
+
+    /* Check reset status */
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        udelay(1);
+        i++;
+        r_data = reset_control_status(priv->rstc);
+        DRP_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    i = 0;
+    while((RST_MAX_TIMEOUT > i) && (false == is_stop))
+    {
+        usleep_range(100, 200);
+        i++;
+        r_data = reset_control_status(priv->rstc);
+        DRP_DEBUG_PRINT("CPG reset_control_status %d \n", r_data);
+        if(CPG_RESET_SUCCESS == r_data)
+        {
+            is_stop = true;
+            break;
+        }
+    }
+
+    if(true != is_stop)
+    {
+        DRP_DEBUG_PRINT("CPG Reset failed. Reset Control Status: %d\n", r_data);
+        goto err_reset;
+    }
+
+    goto end;
+
+err_reset:
+    retval = R_DRP_ERR_RESET;
+    goto end;
+end:
+    DRP_DEBUG_PRINT("end.\n");
+
+    return retval;
+}
+
+static int8_t drp_stop_device(uint32_t ch)
+{
+    int8_t retval = R_DRP_SUCCESS;
+    struct drp_priv *priv = drp_priv;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Stop DRP */
+    if(R_DRP_SUCCESS != R_DRP_DRP_Stop(drp_base_addr[0], ch, &priv->lock)) 
+    {
+        retval = R_DRP_ERR_RESET;
+        goto end;
+    }
+
+    goto end;
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return retval;
+}
+
+static long drp_ioctl_set_seq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    int i;
+    struct drp_priv *priv = drp_priv;
+    struct drp_desc_info *desc_info = filp->private_data;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    DRP_DEBUG_PRINT("status1:%d\n", priv->drp_status.status);
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    if (DRP_STATUS_RUN == priv->drp_status.status)
+    {
+        result = -EBUSY;
+        goto end;
+    }
+
+    /* Copy arguments from user space to kernel space */
+    if (copy_from_user(&desc_info->seq, (void __user *)arg, sizeof(drp_seq_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    /* Check Argument DRP Single */
+    if (DRP_MAX_PROCESS_CFG != desc_info->seq.num)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if (0 != (desc_info->seq.address & DRP_64BYTE_ALIGN))
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if (desc_info->seq.address >= VAL_40BIT_OVER)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    for (i = 0; i < desc_info->seq.num; i++)
+    {
+        if( (desc_info->seq.order[i] & 0xFF) != DRP_EXE_DRP_40BIT )
+        {
+            result = -EINVAL;
+            goto end;
+        }
+        if( (desc_info->seq.order[i] & DRP_OPMASK_FORCE_LOAD) == 0 )
+        {
+            desc_info->drp_load_force = 0;
+        }
+        else
+        {
+            /* Force Load */
+            desc_info->drp_load_force = 1;
+        }
+    }
+
+    /*Initialize DRPcfg descriptor*/
+    desc_info->phyaddr = (uint64_t)desc_info->seq.address;
+    desc_info->vaddr = (char *)phys_to_virt(desc_info->phyaddr);
+    if (!desc_info->vaddr)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+    DRP_DEBUG_PRINT("dmabuf:0x%016llX, dmaphys:0x%016llX\n", desc_info->vaddr, desc_info->phyaddr);
+    /* Deploy drp_single_desc */   
+    for (i = 0; i < DRP_SEQ_NUM; i++)
+    {
+        memcpy(desc_info->vaddr + (DRP_SGL_DRP_DESC_SIZE * i), &drp_single_desc_bin[0], sizeof(drp_single_desc_bin));
+    }
+    __flush_dcache_area(desc_info->vaddr, DRP_CMA_SIZE);
+
+    desc_info->drp_desc_adr_40bit = desc_info->seq.address;
+    desc_info->drp_iodata_num = desc_info->seq.iodata_num;
+    if (desc_info->drp_iodata_num>MAX_IODATA_NUM)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+    if( desc_info->drp_iodata_num > 0 )
+    {
+        for (i = 0; i < desc_info->drp_iodata_num; i++)
+        {
+            if( desc_info->seq.iodata[i].address + desc_info->seq.iodata[i].size >= VAL_40BIT_OVER )
+            {
+                result = -EINVAL;
+                goto end;
+            }
+            if( desc_info->seq.iodata[i].size == 0 )
+            {
+                result = -EINVAL;
+                goto end;
+            }
+        }
+    }
+
+    DRP_DEBUG_PRINT("status2:%d\n", priv->drp_status.status);
+
+    DRP_DEBUG_WAIT();
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+static long drp_ioctl_get_codec_area(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drp_data_t local_drp_data;
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    local_drp_data.address = drp_region_codec_base_addr;
+    local_drp_data.size    = drp_region_codec_size;
+
+    if (copy_to_user((void __user *)arg, &local_drp_data, sizeof(drp_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_get_opencva_area(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drp_data_t local_drp_data;
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    local_drp_data.address = drp_region_oca_base_addr;
+    local_drp_data.size    = drp_region_oca_size;
+
+    if (copy_to_user((void __user *)arg, &local_drp_data, sizeof(drp_data_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_set_drp_freq(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    unsigned int divfix;
+    struct drp_priv *priv = drp_priv;
+    unsigned long flags;
+    struct drp_desc_info *desc_info = filp->private_data;
+
+    DRP_DEBUG_PRINT("start.\n");
+    if(unlikely(down_timeout(&priv->sem, MAX_SEM_TIMEOUT))) 
+    {
+        result = -ETIMEDOUT;
+        goto end;
+    }
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&divfix, (void __user *)arg, sizeof(unsigned int)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if( (divfix < DRP_DIVFIX_MIN) || (divfix > DRP_DIVFIX_MAX) )
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    /* Check status */
+    /* Get the internal state */
+    spin_lock_irqsave(&priv->lock, flags);
+    if (DRP_STATUS_RUN == priv->drp_status.status)
+    {
+        spin_unlock_irqrestore(&priv->lock, flags);
+        result = -EBUSY;
+        goto end;
+    }
+    spin_unlock_irqrestore(&priv->lock, flags);
+    
+    desc_info->drp_mindiv = divfix;
+
+end:
+    if(-ETIMEDOUT != result)
+    {
+        up(&priv->sem);
+    }
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_read_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drp_reg_t drp_reg;
+    int32_t ret;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drp_reg, (void __user *)arg, sizeof(drp_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((drp_size - sizeof(uint32_t)) < drp_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    ret = R_DRP_DRP_RegRead(drp_base_addr[0], drp_reg.offset, &drp_reg.value);
+    if (R_DRP_SUCCESS != ret)
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if (copy_to_user((void __user *)arg, &drp_reg, sizeof(drp_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    goto end;
+
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static long drp_ioctl_write_drp_reg(struct file *filp, unsigned int cmd, unsigned long arg)
+{
+    long result = 0;
+    drp_reg_t drp_reg;
+
+    DRP_DEBUG_PRINT("start.\n");
+
+    /* Check NULL */
+    if (0 == arg)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    if (copy_from_user(&drp_reg, (void __user *)arg, sizeof(drp_reg_t)))
+    {
+        result = -EFAULT;
+        goto end;
+    }
+
+    if ((drp_size - sizeof(uint32_t)) < drp_reg.offset)
+    {
+        result = -EINVAL;
+        goto end;
+    }
+
+    R_DRP_DRP_RegWrite(drp_base_addr[0], drp_reg.offset, drp_reg.value);
+
+    goto end;
+
+end:
+    DRP_DEBUG_PRINT("end.\n");
+    return result;
+}
+
+static int drp_drp_cpg_init(void)
+{
+    int result;
+    DRP_DEBUG_PRINT("start.\n");
+
+    result =  R_DRP_SUCCESS;
+#ifdef DRP_CPG_CTL
+    initialize_cpg_drp(cpg_base_address);
+#else
+    // undefined
+#endif
+    
+    DRP_DEBUG_PRINT("end.\n");
+
+    return result;
+}
+#ifdef CONFIG_DRP_SUPPORT_MULTI_OS
+static int drp_flag_test_and_set( unsigned int num )
+{
+    return lock_drp( drp_os_exclusion, num );
+}
+
+static void drp_flag_clear( unsigned int num )
+{
+    unlock_drp( drp_os_exclusion, num );
+}
+
+static int drp_flag_test( unsigned int num )
+{
+    int ret = lock_drp( drp_os_exclusion, num );
+    if( 0 == ret)
+    {
+        unlock_drp( drp_os_exclusion, num );
+    }
+    return ret;
+}
+#endif
+module_platform_driver(drp_platform_driver);
+MODULE_DEVICE_TABLE(of, drp_match);
+MODULE_DESCRIPTION("RZ/V2MA DRP driver");
+MODULE_AUTHOR("Renesas Electronics Corporation");
+MODULE_LICENSE("GPL v2");
+
diff -uprN old/drivers/drp/drp-reg.h new/drivers/drp/drp-reg.h
--- old/drivers/drp/drp-reg.h	1970-01-01 09:00:00.000000000 +0900
+++ new/drivers/drp/drp-reg.h	2023-10-10 16:02:45.000000000 +0900
@@ -0,0 +1,1071 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP-AI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+//==================================================================================================================
+// DRP-AI
+//==================================================================================================================
+
+#ifndef DRP_REG__H
+#define DRP_REG__H
+
+#define DRP0_BADDR                  (0x17000000uLL)
+#define DRP1_BADDR                  (0x18000000uLL)
+#define AIMAC0_BADDR                (0x16800000uLL)
+
+//==================================================================================================================
+// BaseAddress
+//==================================================================================================================
+// drp core
+#define DRPCORE_BADDR               (0x00000000uLL)
+#define DRPINIF_BADDR               (0x003FE000uLL)
+#define DRPOUTIF_BADDR              (0x003FE800uLL)
+#define CFGLIF_BADDR                (0x003FF000uLL)
+#define DRP_CDCC_BADDR              (0x003FF800uLL)
+
+// spa4dma
+#define STP_DRPIN_BADDR             (0x00F00000uLL)
+#define STP_DRPOUT_BADDR            (0x00F08000uLL)
+#define STP_CFGL_BADDR              (0x00F10000uLL)
+#define STP_DSCC_BADDR              (0x00F18000uLL)
+#define STP_IDIF_BADDR              (0x00F19000uLL)
+#define STP_ODIF_BADDR              (0x00F1A000uLL)
+#define STP_IDMAC_BADDR             (0x00F1B000uLL)
+#define STP_ODMAC_BADDR             (0x00F1C000uLL)
+#define STP_RAC_BADDR               (0x00F1D000uLL)
+#define STP_STPC_BADDR              (0x00F1D800uLL)
+#define STP_SYNCTBL_BADDR           (0x00F1E000uLL)
+#define STP_ADRCONV_BADDR           (0x00F0C000uLL)
+
+// aimac
+#define EXD0_DRPIN_M_BADDR          (0x00000000uLL)
+#define EXD0_DRPOUT_M_BADDR         (0x00008000uLL)
+#define EXD0_ADRCONV_BADDR          (0x0000C000uLL)
+#define EXD0_DSCC_BADDR             (0x00018000uLL)
+#define EXD0_IDIF_BADDR             (0x00019000uLL)
+#define EXD0_ODIF_BADDR             (0x0001A000uLL)
+#define EXD0_IDMAC_BADDR            (0x0001B000uLL)
+#define EXD0_ODMAC_BADDR            (0x0001C000uLL)
+#define EXD0_RAC_BADDR              (0x0001D000uLL)
+#define EXD0_STPC_BADDR             (0x0001D800uLL)
+#define EXD0_DRPIN_A_BADDR          (0x00020000uLL)
+#define EXD0_DRPOUT_A_BADDR         (0x00030000uLL)
+
+#define EXD1_DRPIN_M_BADDR          (0x00040000uLL)
+#define EXD1_DRPOUT_M_BADDR         (0x00048000uLL)
+#define EXD1_IDIF_BADDR             (0x00059000uLL)
+#define EXD1_ODIF_BADDR             (0x0005A000uLL)
+#define EXD1_IDMAC_BADDR            (0x0005B000uLL)
+#define EXD1_ODMAC_BADDR            (0x0005C000uLL)
+#define EXD1_RAC_BADDR              (0x0005D000uLL)
+#define EXD1_STPC_BADDR             (0x0005D800uLL)
+#define EXD1_DRPIN_A_BADDR          (0x00060000uLL)
+#define EXD1_DRPOUT_A_BADDR         (0x00070000uLL)
+
+#define AID0_DRPIN_BADDR            (0x00100000uLL)
+#define AID0_DSCC_BADDR             (0x00118000uLL)
+#define AID0_IDIF_BADDR             (0x00119000uLL)
+#define AID0_IDIF2_BADDR            (0x0011A000uLL)
+#define AID0_IDMAC_BADDR            (0x0011B000uLL)
+#define AID1_DRPIN_BADDR            (0x000C0000uLL)
+#define AID1_DSCC_BADDR             (0x000D8000uLL)
+#define AID1_IDIF_BADDR             (0x000D9000uLL)
+#define AID1_IDIF2_BADDR            (0x000DA000uLL)
+#define AID1_IDMAC_BADDR            (0x000DB000uLL)
+
+#define AID_AREG_BADDR              (0x0011D800uLL)
+#define CMDSEL_BADDR                (0x00140000uLL)
+#define SYNCTBL_BADDR               (0x00140800uLL)
+#define INTMON_BADR                 (0x00141000uLL)
+#define CLKRSTCON_BADDR             (0x00141800uLL)
+#define MAC4K_BASE_ADDRESS          (0x00180000uLL)
+#define MACCTL_BADDR                (0x001C0000uLL)
+#define MACCTL_DCLK_BADDR           (0x001D0000uLL)
+#define FMBUF_BADDR                 (0x001E0000uLL)
+#define PRAM_BADDR                  (0x00200000uLL)
+
+#define EXD0_ODIF_BASE_ADDRESS      (EXD0_ODIF_BADDR)
+#define EXD1_ODIF_BASE_ADDRESS      (EXD1_ODIF_BADDR)
+#define AID0_IDIF_BASE_ADDRESS      (AID0_IDIF_BADDR)
+#define AID0_IDIF2_BASE_ADDRESS     (AID0_IDIF2_BADDR)
+#define AID1_IDIF_BASE_ADDRESS      (AID1_IDIF_BADDR)
+#define AID1_IDIF2_BASE_ADDRESS     (AID1_IDIF2_BADDR)
+
+//==================================================================================================================
+// AreaSize
+//==================================================================================================================
+// drp core
+#define DRPCORE_AREASIZE            (0x3FE000uLL)
+#define DRPINIF_AREASIZE            (0x000800uLL)
+#define DRPOUTIF_AREASIZE           (0x000800uLL)
+#define CFGLIF_AREASIZE             (0x001000uLL)
+// dmac
+#define DRPIN_M_AREASIZE            (0x002000uLL)
+#define DRPOUT_M_AREASIZE           (0x002000uLL)
+#define CFGL_AREASIZE               (0x008000uLL)
+#define DSCC_AREASIZE               (0x001000uLL)
+#define IDIF_AREASIZE               (0x001000uLL)
+#define ODIF_AREASIZE               (0x001000uLL)
+#define IDMAC_AREASIZE              (0x001000uLL)
+#define ODMAC_AREASIZE              (0x001000uLL)
+#define RAC_AREASIZE                (0x000800uLL)
+#define STPC_AREASIZE               (0x000800uLL)
+#define SYNCTBL_AREASIZE            (0x020000uLL)
+#define DRPIN_A_AREASIZE            (0x010000uLL)
+#define DRPOUT_A_AREASIZE           (0x010000uLL)
+
+// aimac
+#define AID_AREG_AREASIZE           (0x000080uLL)
+#define CMDSEL_AREASIZE             (0x000600uLL)
+#define INTMON_AREASIZE             (0x000010uLL)
+#define CLKRSTCON_AREASIZE          (0x000010uLL)
+//#define PRAM_AREASIZE               (0x201000uLL)
+//#define PRAM_AREASIZE               (0x400000uLL)
+#define PRAM_AREASIZE               (0x1000uLL)
+#define MACCTL_AREASIZE             (0x007200uLL)
+
+//==================================================================================================================
+// Address
+//==================================================================================================================
+
+//------------------------------------------------------------------------------------------------------------------
+// DRP
+//------------------------------------------------------------------------------------------------------------------
+#define DRP_MINDIV                  (0x398000uLL)
+#define DRP_ECC                     (0x398038uLL)
+#define DRP_ERRINT_ENABLE           (0x3B0038uLL)
+#define DRP_CDCC_DBGCTL             (0x3FF830uLL)
+#define DRP_CDCC_CCCTL              (0x3FF804uLL)
+
+#define CDCC_CCE                    ((DRP_CDCC_BADDR) + 0x000uLL)
+#define CDCC_CCCTL                  ((DRP_CDCC_BADDR) + 0x004uLL)
+#define CDCC_CFGFWCTL               ((DRP_CDCC_BADDR) + 0x010uLL)
+#define CDCC_DBGCTL                 ((DRP_CDCC_BADDR) + 0x030uLL)
+#define CDCC_DBGCTL2                ((DRP_CDCC_BADDR) + 0x034uLL)
+#define CDCC_PFCNTCTL               ((DRP_CDCC_BADDR) + 0x040uLL)
+#define CDCC_PFCNTCLR               ((DRP_CDCC_BADDR) + 0x044uLL)
+#define CDCC_PFCNTSEL               ((DRP_CDCC_BADDR) + 0x048uLL)
+#define CDCC_PFCNT0                 ((DRP_CDCC_BADDR) + 0x060uLL)
+#define CDCC_PFCNT1                 ((DRP_CDCC_BADDR) + 0x064uLL)
+#define CDCC_PFCNT2                 ((DRP_CDCC_BADDR) + 0x068uLL)
+#define CDCC_PFCNT3                 ((DRP_CDCC_BADDR) + 0x06cuLL)
+#define CDCC_DBGMON                 ((DRP_CDCC_BADDR) + 0x0c0uLL)
+#define CDCC_ECC_MODE               ((DRP_CDCC_BADDR) + 0x0d0uLL)
+#define CDCC_INT_STATUS             ((DRP_CDCC_BADDR) + 0x0e0uLL)
+#define CDCC_ERR_INT_STATUS         ((DRP_CDCC_BADDR) + 0x0e8uLL)
+#define CDCC_INT_MASK               ((DRP_CDCC_BADDR) + 0x0f0uLL)
+#define CDCC_ERR_INT_MASK           ((DRP_CDCC_BADDR) + 0x0f4uLL)
+#define CDCC_CCINFO0                ((DRP_CDCC_BADDR) + 0x100uLL)
+
+#define DRPCORE_REGCLKSEL           (0x3b0018uLL)
+#define DRPCORE_REGPARITYEN         (0x398038uLL)
+#define DRPCORE_REGCFGMREADEN       (0x398040uLL)
+#define DRPCORE_REGCONFIGEN         (0x398048uLL)
+#define DRPCORE_REGRESET            (0x398010uLL)
+#define DRPCORE_REGPRESET           (0x398050uLL)
+#define DRPCORE_REGRUN              (0x398008uLL)
+#define DRPCORE_REGSTATE            (0x398020uLL)
+#define DRPCORE_REGCLEARCOUNT       (0x398060uLL)
+#define DRPCORE_REGCTRLMASK         (0x3b0000uLL)
+#define DRPCORE_REGCODEAWE          (0x3b0010uLL)
+#define DRPCORE_REGINTMODE          (0x3b0028uLL)
+#define DRPCORE_REGINTMASK          (0x3b0030uLL)
+#define DRPCORE_REGERRINTMASK       (0x3b0038uLL)
+#define DRPCORE_INTSTATUS           (0x3b0040uLL)
+#define DRPCORE_ERRINTSTATUS        (0x3b0048uLL)
+#define DRPCORE_REGCHIPMODE         (0x398030uLL)
+#define DRPCORE_VMEMREG             (0x110000uLL)
+#define DRPCORE_REGMINDIV           (0x398000uLL)
+#define DRPCORE_REGFPRND            (0x398058uLL)
+#define DRPCORE_REGCALCERREN        (0x398078uLL)
+
+#define DRPCORE_STCSTATUS           (0x0f8010uLL)  // StcStatus
+#define DRPCORE_STCSTATUS_10        ((DRPCORE_STCSTATUS) + (10uLL << 6)) // StcStatus(Sel=10)
+#define DRPCORE_STCSTATUS_11        ((DRPCORE_STCSTATUS) + (11uLL << 6)) // StcStatus(Sel=11)
+#define DRPCORE_STCSTATUS_12        ((DRPCORE_STCSTATUS) + (12uLL << 6)) // StcStatus(Sel=12)
+#define DRPCORE_STCSTATUS_26        ((DRPCORE_STCSTATUS) + (26uLL << 6)) // StcStatus(Sel=26)
+#define DRPCORE_STCSTATUS_28        ((DRPCORE_STCSTATUS) + (28uLL << 6)) // StcStatus(Sel=28)
+#define DRPCORE_STCSTATUS_34        ((DRPCORE_STCSTATUS) + (34uLL << 6)) // StcStatus(Sel=34)
+
+#define DRPCORE_STCSTBL             (0x280000uLL)  // StcSTbl
+#define DRPCORE_VMEMIU              (0x000000uLL)  // PeIu+VmemIu
+#define DRPCORE_STCIU               (0x0C0000uLL)  // StcIu
+#define DRPCORE_VMEMRFU             (0x100000uLL)  // PeRfu+VmemRfu
+#define DRPCORE_VMEMVMU             (0x120000uLL)  // VmemVmu
+#define DRPCORE_HMEMHMU             (0x180000uLL)  // Hmu
+
+#define DRPCORE_INSEL_RCSIZE        (0x31C500uLL)  // Dout0W0-3_out
+#define DRPCORE_INSEL_RCADDR        (0x31C504uLL)  // Dout0W4-7_out
+#define DRPCORE_INSEL_RCSTRD        (0x31C508uLL)  // Dout1W2-3_out
+#define DRPCORE_INSEL_RCCMD         (0x31C50CuLL)  // Dout1W4-5_out
+
+#define DRPCORE_OUTSEL_DATA0_L      (0x31C700uLL)  // Dout0E0-3_out
+#define DRPCORE_OUTSEL_DATA0_H      (0x31C704uLL)  // Dout0E4-7_out
+#define DRPCORE_OUTSEL_DATA1_L      (0x31C708uLL)  // Dout1E0-3_out
+#define DRPCORE_OUTSEL_DATA1_H      (0x31C70CuLL)  // Dout1E4-7_out
+#define DRPCORE_OUTSEL_STRB         (0x31C714uLL)  // Dout2E4-5_out
+
+//------------------------------------------------------------------------------------------------------------------
+// DSCC
+//------------------------------------------------------------------------------------------------------------------
+#define DSCC_INT_REG                (0x000uLL)
+#define DSCC_DCTLI0_REG             (0x100uLL)
+#define DSCC_DPFC                   (0x104uLL)
+#define DSCC_DPA_REG                (0x108uLL)
+#define DSCC_DPA2_REG               (0x10CuLL)
+#define DSCC_PAMON_REG              (0x118uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// IDMACIF
+//------------------------------------------------------------------------------------------------------------------
+#define IDIF_INT_REG                (0x000uLL)
+#define IDIF_INTMSK_REG             (0x004uLL)
+#define IDIF_EINT_REG               (0x008uLL)
+#define IDIF_EINTMSK_REG            (0x00CuLL)
+#define IDIF_EINT_DSC_REG           (0x010uLL)
+#define IDIF_EINTMSK_DSC_REG        (0x014uLL)
+#define IDIF_DMACTLI0_REG           (0x100uLL)
+#define IDIF_BADRI0_REG             (0x108uLL)
+#define IDIF_BADR2I0_REG            (0x10CuLL)
+#define IDIF_DMACTLI1_REG           (0x200uLL)
+#define IDIF_BADRI1_REG             (0x208uLL)
+#define IDIF_BADR2I1_REG            (0x20CuLL)
+#define IDIF_DMACTLI2_REG           (0x300uLL)
+#define IDIF_BADRI2_REG             (0x308uLL)
+#define IDIF_BADR2I2_REG            (0x30CuLL)
+#define IDIF_DMACTLI3_REG           (0x400uLL)
+#define IDIF_BADRI3_REG             (0x408uLL)
+#define IDIF_BADR2I3_REG            (0x40CuLL)
+#define IDIF_DMACTLI4_REG           (0x500uLL)
+#define IDIF_DMACTLI5_REG           (0x600uLL)
+#define IDIF_DMACTLI6_REG           (0x700uLL)
+#define IDIF_DMACTLI7_REG           (0x800uLL)
+#define IDIF_DMACTLCW_REG           (0x900uLL)
+#define IDIF_BADRCW_REG             (0x908uLL)
+#define IDIF_BADR2CW_REG            (0x90CuLL)
+#define IDIF_DMACTLMCMD_REG         (0x300uLL)
+#define IDIF_DMACTPCMD_REG          (0x100uLL)
+
+#define STP_IDIF_INT_REG            ((STP_IDIF_BADDR) + (IDIF_INT_REG))
+#define STP_IDIF_INTMSK_REG         ((STP_IDIF_BADDR) + (IDIF_INTMSK_REG))
+#define STP_IDIF_EINT_REG           ((STP_IDIF_BADDR) + (IDIF_EINT_REG))
+#define STP_IDIF_EINTMSK_REG        ((STP_IDIF_BADDR) + (IDIF_EINTMSK_REG))
+#define STP_IDIF_EINT_DSC_REG       ((STP_IDIF_BADDR) + (IDIF_EINT_DSC_REG))
+#define STP_IDIF_EINTMSK_DSC_REG    ((STP_IDIF_BADDR) + (IDIF_EINTMSK_DSC_REG))
+#define STP_IDIF_DMACTLI0_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI0_REG))
+#define STP_IDIF_DMACTLI1_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI1_REG))
+#define STP_IDIF_DMACTLI2_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI2_REG))
+#define STP_IDIF_DMACTLI3_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI3_REG))
+#define STP_IDIF_DMACTLI4_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI4_REG))
+#define STP_IDIF_DMACTLI5_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI5_REG))
+#define STP_IDIF_DMACTLI6_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI6_REG))
+#define STP_IDIF_DMACTLI7_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLI7_REG))
+#define STP_IDIF_DMACTLCW_REG       ((STP_IDIF_BADDR) + (IDIF_DMACTLCW_REG))
+#define STP_IDIF_DMACTLMCMD_REG     ((STP_IDIF_BADDR) + (IDIF_DMACTLMCMD_REG))
+#define STP_IDIF_DMACTPCMD_REG      ((STP_IDIF_BADDR) + (IDIF_DMACTPCMD_REG))
+
+//------------------------------------------------------------------------------------------------------------------
+// ODMACIF
+//------------------------------------------------------------------------------------------------------------------
+#define ODIF_INT_REG                (0x000uLL)
+#define ODIF_INTMSK_REG             (0x004uLL)
+#define ODIF_EINT_REG               (0x008uLL)
+#define ODIF_EINTMSK_REG            (0x00CuLL)
+#define ODIF_DMACTLO0_REG           (0x100uLL)
+#define ODIF_BADRO0_REG             (0x108uLL)
+#define ODIF_BADR2O0_REG            (0x10CuLL)
+#define ODIF_DMACTLO1_REG           (0x200uLL)
+#define ODIF_BADRO1_REG             (0x208uLL)
+#define ODIF_BADR2O1_REG            (0x20CuLL)
+#define ODIF_DMACTLO2_REG           (0x300uLL)
+#define ODIF_BADRO2_REG             (0x308uLL)
+#define ODIF_BADR2O2_REG            (0x30CuLL)
+#define ODIF_DMACTLO3_REG           (0x400uLL)
+#define ODIF_BADRO3_REG             (0x408uLL)
+#define ODIF_BADR2O3_REG            (0x40CuLL)
+#define ODIF_INTCNTO0_REG           (0x118uLL)
+#define ODIF_INTCNTO1_REG           (0x218uLL)
+#define ODIF_INTCNTO2_REG           (0x318uLL)
+#define ODIF_INTCNTO3_REG           (0x418uLL)
+#define ODIF_INTCNTO4_REG           (0x518uLL)
+#define ODIF_INTCNTO5_REG           (0x618uLL)
+#define ODIF_INTCNTO6_REG           (0x718uLL)
+#define ODIF_INTCNTO7_REG           (0x818uLL)
+#define ODIF_INTCNTCR_REG           (0x918uLL)
+#define ODIF_ELCCTL_REG             (0x060uLL)
+#define ODIF_ELCPLS_REG             (0x064uLL)
+#define ODIF_ELCDBG_REG             (0x070uLL)
+#define ODIF_ELCCNT_REG             (0x074uLL)
+#define ODIF_ELCOUT_REG             (0x078uLL)
+
+#define STP_ODIF_INT_REG            ((STP_ODIF_BADDR) + (ODIF_INT_REG))
+#define STP_ODIF_INTMSK_REG         ((STP_ODIF_BADDR) + (ODIF_INTMSK_REG))
+#define STP_ODIF_EINT_REG           ((STP_ODIF_BADDR) + (ODIF_EINT_REG))
+#define STP_ODIF_EINTMSK_REG        ((STP_ODIF_BADDR) + (ODIF_EINTMSK_REG))
+#define STP_ODIF_DMACTLO0_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO0_REG))
+#define STP_ODIF_DMACTLO1_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO1_REG))
+#define STP_ODIF_DMACTLO2_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO2_REG))
+#define STP_ODIF_DMACTLO3_REG       ((STP_ODIF_BADDR) + (ODIF_DMACTLO3_REG))
+#define STP_ODIF_INTCNTO0_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO0_REG))
+#define STP_ODIF_INTCNTO1_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO1_REG))
+#define STP_ODIF_INTCNTO2_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO2_REG))
+#define STP_ODIF_INTCNTO3_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO3_REG))
+#define STP_ODIF_INTCNTO4_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO4_REG))
+#define STP_ODIF_INTCNTO5_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO5_REG))
+#define STP_ODIF_INTCNTO6_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO6_REG))
+#define STP_ODIF_INTCNTO7_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTO7_REG))
+#define STP_ODIF_INTCNTCR_REG       ((STP_ODIF_BADDR) + (ODIF_INTCNTCR_REG))
+#define STP_ODIF_ELCCTL_REG         ((STP_ODIF_BADDR) + (ODIF_ELCCTL_REG))
+#define STP_ODIF_ELCPLS_REG         ((STP_ODIF_BADDR) + (ODIF_ELCPLS_REG))
+#define STP_ODIF_ELCDBG_REG         ((STP_ODIF_BADDR) + (ODIF_ELCDBG_REG))
+#define STP_ODIF_ELCCNT_REG         ((STP_ODIF_BADDR) + (ODIF_ELCCNT_REG))
+#define STP_ODIF_ELCOUT_REG         ((STP_ODIF_BADDR) + (ODIF_ELCOUT_REG))
+
+#define EXD1_ODIF_INT_REG           ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INT_REG))
+#define EXD1_ODIF_INTCNTO1_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO1_REG))
+#define EXD1_ODIF_INTCNTO2_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO2_REG))
+#define EXD1_ODIF_INTCNTO3_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO3_REG))
+#define EXD1_ODIF_INTCNTO4_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO4_REG))
+#define EXD1_ODIF_INTCNTO5_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO5_REG))
+#define EXD1_ODIF_INTCNTO6_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO6_REG))
+#define EXD1_ODIF_INTCNTO7_REG      ((EXD1_ODIF_BASE_ADDRESS) + (ODIF_INTCNTO7_REG))
+
+//------------------------------------------------------------------------------------------------------------------
+// IDMAC
+//------------------------------------------------------------------------------------------------------------------
+#define IDMAC_INTME_REG             (0x024uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// ODMAC
+//------------------------------------------------------------------------------------------------------------------
+#define ODMAC_INTME_REG             (0x024uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// DRPIN
+//------------------------------------------------------------------------------------------------------------------
+#define DRPIN_DUMMY                 (0x000uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// STPC
+//------------------------------------------------------------------------------------------------------------------
+#define STPC_SFTRST                 (0x000uLL)
+#define STPC_RSTCON_RST             (0x000uLL) // alias for old version
+#define STPC_INT_STS                (0x004uLL)
+#define STPC_ERRINT_STS             (0x008uLL)
+#define STPC_CLKE                   (0x010uLL)
+#define STPC_CLKGEN_RST             (0x040uLL)
+#define STPC_CLKGEN_STBY            (0x044uLL)
+#define STPC_CLKGEN_DIV             (0x048uLL)
+#define STPC_CLKGEN_STS             (0x04CuLL)
+#define STPC_CLKGEN_BYPASS          (0x050uLL)
+#define STPC_CLKGEN_HDIV            (0x054uLL)
+#define STPC_CLKGEN_DIVLAT          (0x058uLL)
+#define STPC_CLKGEN_STBYWAIT        (0x060uLL)
+#define STPC_CLKSW_CONFIG           (0x064uLL)
+#define STPC_CLKSW_CONFIG2          (0x068uLL)
+#define STPC_CLKSW_ACK              (0x06CuLL)
+#define STPC_PFCNTCTL               (0x080uLL)
+#define STPC_PFCNTCLR               (0x084uLL)
+#define STPC_CNT0                   (0x088uLL)
+#define STPC_CNT1                   (0x08CuLL)
+#define STPC_DRPCMD_MSK             (0x0C0uLL)
+#define STPC_MONI0                  (0x100uLL)
+#define STPC_MONI1                  (0x104uLL)
+#define STPC_MONI2                  (0x108uLL)
+#define STPC_MONI3                  (0x10CuLL)
+#define STPC_CTRLPLS0               (0x110uLL)
+#define STPC_CTRLPLS1               (0x114uLL)
+#define STPC_CTRLPLS2               (0x118uLL)
+#define STPC_CTRLPLS3               (0x11CuLL)
+#define STPC_CTRL0                  (0x120uLL)
+#define STPC_CTRL1                  (0x124uLL)
+#define STPC_CTRL2                  (0x128uLL)
+#define STPC_CTRL3                  (0x12CuLL)
+#define STPC_CLKGEN_CTRL            (0x130uLL)
+
+#define STP_STPC_SFTRST             ((STP_STPC_BADDR) + (STPC_SFTRST))
+#define STP_STPC_RSTCON_RST         ((STP_STPC_BADDR) + (STPC_RSTCON_RST))
+#define STP_STPC_INT_STS            ((STP_STPC_BADDR) + (STPC_INT_STS))
+#define STP_STPC_ERRINT_STS         ((STP_STPC_BADDR) + (STPC_ERRINT_STS))
+#define STP_STPC_CLKE               ((STP_STPC_BADDR) + (STPC_CLKE))
+#define STP_STPC_CLKGEN_RST         ((STP_STPC_BADDR) + (STPC_CLKGEN_RST))
+#define STP_STPC_CLKGEN_STBY        ((STP_STPC_BADDR) + (STPC_CLKGEN_STBY))
+#define STP_STPC_CLKGEN_DIV         ((STP_STPC_BADDR) + (STPC_CLKGEN_DIV))
+#define STP_STPC_CLKGEN_STS         ((STP_STPC_BADDR) + (STPC_CLKGEN_STS))
+#define STP_STPC_CLKGEN_BYPASS      ((STP_STPC_BADDR) + (STPC_CLKGEN_BYPASS))
+#define STP_STPC_CLKGEN_HDIV        ((STP_STPC_BADDR) + (STPC_CLKGEN_HDIV))
+#define STP_STPC_CLKGEN_DIVLAT      ((STP_STPC_BADDR) + (STPC_CLKGEN_DIVLAT))
+#define STP_STPC_CLKGEN_STBYWAIT    ((STP_STPC_BADDR) + (STPC_CLKGEN_STBYWAIT))
+#define STP_STPC_CLKSW_CONFIG       ((STP_STPC_BADDR) + (STPC_CLKSW_CONFIG))
+#define STP_STPC_CLKSW_CONFIG2      ((STP_STPC_BADDR) + (STPC_CLKSW_CONFIG2))
+#define STP_STPC_CLKSW_ACK          ((STP_STPC_BADDR) + (STPC_CLKSW_ACK))
+#define STP_STPC_PFCNTCTL           ((STP_STPC_BADDR) + (STPC_PFCNTCTL))
+#define STP_STPC_PFCNTCLR           ((STP_STPC_BADDR) + (STPC_PFCNTCLR))
+#define STP_STPC_CNT0               ((STP_STPC_BADDR) + (STPC_CNT0))
+#define STP_STPC_CNT1               ((STP_STPC_BADDR) + (STPC_CNT1))
+#define STP_STPC_DRPCMD_MSK         ((STP_STPC_BADDR) + (STPC_DRPCMD_MSK))
+#define STP_STPC_MONI0              ((STP_STPC_BADDR) + (STPC_MONI0))
+#define STP_STPC_MONI1              ((STP_STPC_BADDR) + (STPC_MONI1))
+#define STP_STPC_MONI2              ((STP_STPC_BADDR) + (STPC_MONI2))
+#define STP_STPC_MONI3              ((STP_STPC_BADDR) + (STPC_MONI3))
+#define STP_STPC_CTRLPLS0           ((STP_STPC_BADDR) + (STPC_CTRLPLS0))
+#define STP_STPC_CTRLPLS1           ((STP_STPC_BADDR) + (STPC_CTRLPLS1))
+#define STP_STPC_CTRLPLS2           ((STP_STPC_BADDR) + (STPC_CTRLPLS2))
+#define STP_STPC_CTRLPLS3           ((STP_STPC_BADDR) + (STPC_CTRLPLS3))
+#define STP_STPC_CTRL0              ((STP_STPC_BADDR) + (STPC_CTRL0))
+#define STP_STPC_CTRL1              ((STP_STPC_BADDR) + (STPC_CTRL1))
+#define STP_STPC_CTRL2              ((STP_STPC_BADDR) + (STPC_CTRL2))
+#define STP_STPC_CTRL3              ((STP_STPC_BADDR) + (STPC_CTRL3))
+#define STP_STPC_CLKGEN_CTRL        ((STP_STPC_BADDR) + (STPC_CLKGEN_CTRL))
+
+#define EXD0_STPC_CLKSW_CONFIG      ((EXD0_STPC_BADDR) + (STPC_CLKSW_CONFIG))
+
+//------------------------------------------------------------------------------------------------------------------
+// ADRCONV
+//------------------------------------------------------------------------------------------------------------------
+#define ADRCONV_TBL_EN              (0x1FFCuLL)
+#define ADRCONV_TBL                 (0x2000uLL)
+#define ADRCONV_CTL_REG             (0x1FFCuLL)
+#define ADRCONV_TBLn_REG            (0xE000uLL)
+
+#define STP_ADRCONV_TBL_EN          ((STP_ADRCONV_BADDR) + (ADRCONV_TBL_EN))
+#define STP_ADRCONV_TBL             ((STP_ADRCONV_BADDR) + (ADRCONV_TBL))
+
+#define EXD0_ADRCONV_TBL_EN         ((EXD0_ADRCONV_BADDR) + (ADRCONV_TBL_EN))
+#define EXD0_ADRCONV_TBL            ((EXD0_ADRCONV_BADDR) + (ADRCONV_TBL))
+
+//------------------------------------------------------------------------------------------------------------------
+// SYNC TBL
+//------------------------------------------------------------------------------------------------------------------
+#define STP_STBL_TBL0               ((STP_SYNCTBL_BADDR) + 0x000uLL)
+#define STP_STBL_TBL1               ((STP_SYNCTBL_BADDR) + 0x004uLL)
+#define STP_STBL_TBL2               ((STP_SYNCTBL_BADDR) + 0x008uLL)
+#define STP_STBL_TBL3               ((STP_SYNCTBL_BADDR) + 0x00CuLL)
+#define STP_STBL_TBL4               ((STP_SYNCTBL_BADDR) + 0x010uLL)
+#define STP_STBL_TBL5               ((STP_SYNCTBL_BADDR) + 0x014uLL)
+#define STP_STBL_TBL6               ((STP_SYNCTBL_BADDR) + 0x018uLL)
+#define STP_STBL_TBL7               ((STP_SYNCTBL_BADDR) + 0x01CuLL)
+#define STP_STBL_TBL8               ((STP_SYNCTBL_BADDR) + 0x020uLL)
+#define STP_STBL_TBL9               ((STP_SYNCTBL_BADDR) + 0x024uLL)
+#define STP_STBL_TBL10              ((STP_SYNCTBL_BADDR) + 0x028uLL)
+#define STP_STBL_TBL11              ((STP_SYNCTBL_BADDR) + 0x02CuLL)
+#define STP_STBL_TBL12              ((STP_SYNCTBL_BADDR) + 0x030uLL)
+#define STP_STBL_TBL13              ((STP_SYNCTBL_BADDR) + 0x034uLL)
+#define STP_STBL_TBL14              ((STP_SYNCTBL_BADDR) + 0x038uLL)
+#define STP_STBL_TBL15              ((STP_SYNCTBL_BADDR) + 0x03CuLL)
+#define STP_STBL_TBL16              ((STP_SYNCTBL_BADDR) + 0x040uLL)
+#define STP_STBL_TBL17              ((STP_SYNCTBL_BADDR) + 0x044uLL)
+#define STP_STBL_TBL18              ((STP_SYNCTBL_BADDR) + 0x048uLL)
+#define STP_STBL_TBL19              ((STP_SYNCTBL_BADDR) + 0x04CuLL)
+#define STP_STBL_TBL20              ((STP_SYNCTBL_BADDR) + 0x050uLL)
+#define STP_STBL_TBL21              ((STP_SYNCTBL_BADDR) + 0x054uLL)
+#define STP_STBL_TBL22              ((STP_SYNCTBL_BADDR) + 0x058uLL)
+#define STP_STBL_TBL23              ((STP_SYNCTBL_BADDR) + 0x05CuLL)
+#define STP_STBL_TBL24              ((STP_SYNCTBL_BADDR) + 0x060uLL)
+#define STP_STBL_TBL25              ((STP_SYNCTBL_BADDR) + 0x064uLL)
+#define STP_STBL_TBL26              ((STP_SYNCTBL_BADDR) + 0x068uLL)
+#define STP_STBL_TBL27              ((STP_SYNCTBL_BADDR) + 0x06CuLL)
+#define STP_STBL_TBL28              ((STP_SYNCTBL_BADDR) + 0x070uLL)
+#define STP_STBL_TBL29              ((STP_SYNCTBL_BADDR) + 0x074uLL)
+#define STP_STBL_TBL30              ((STP_SYNCTBL_BADDR) + 0x078uLL)
+#define STP_STBL_TBL31              ((STP_SYNCTBL_BADDR) + 0x07CuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// CLKRSTCON
+//------------------------------------------------------------------------------------------------------------------
+#define CLKRSTCON_SFTRST_REG        (0x000uLL)
+#define CLKRSTCON_CLKE_REG          (0x008uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// PRAM
+//------------------------------------------------------------------------------------------------------------------
+#define PRAM_INT                    ((PRAM_BADDR) + 0x00000000uLL)
+#define PRAM_INTMSK                 ((PRAM_BADDR) + 0x00000008uLL)
+#define PRAM_CTRL                   ((PRAM_BADDR) + 0x00000100uLL)
+#define PRAM_STATE0                 ((PRAM_BADDR) + 0x00000110uLL)
+#define PRAM_STATE1                 ((PRAM_BADDR) + 0x00000114uLL)
+#define PRAM_CNT0                   ((PRAM_BADDR) + 0x00000200uLL)
+#define PRAM_CNT1                   ((PRAM_BADDR) + 0x00000204uLL)
+#define PRAM_CNT2                   ((PRAM_BADDR) + 0x00000208uLL)
+#define PRAM_CNT3                   ((PRAM_BADDR) + 0x0000020CuLL)
+#define PRAM_CNT4                   ((PRAM_BADDR) + 0x00000210uLL)
+#define PRAM_CNT5                   ((PRAM_BADDR) + 0x00000214uLL)
+#define PRAM_CNT6                   ((PRAM_BADDR) + 0x00000218uLL)
+#define PRAM_CNT7                   ((PRAM_BADDR) + 0x0000021CuLL)
+#define PRAM_CNTSEL0                ((PRAM_BADDR) + 0x00000220uLL)
+#define PRAM_CNTSEL1                ((PRAM_BADDR) + 0x00000224uLL)
+#define PRAM_CNTSEL2                ((PRAM_BADDR) + 0x00000228uLL)
+#define PRAM_CNTSEL3                ((PRAM_BADDR) + 0x0000022CuLL)
+#define PRAM_CNTSEL4                ((PRAM_BADDR) + 0x00000230uLL)
+#define PRAM_CNTSEL5                ((PRAM_BADDR) + 0x00000234uLL)
+#define PRAM_CNTSEL6                ((PRAM_BADDR) + 0x00000238uLL)
+#define PRAM_CNTSEL7                ((PRAM_BADDR) + 0x0000023CuLL)
+#define PRAM_CNT_EN                 ((PRAM_BADDR) + 0x00000240uLL)
+#define PRAM_CHICKEN                ((PRAM_BADDR) + 0x00000840uLL)
+#define PRAM_DBGCTRL                ((PRAM_BADDR) + 0x00000F00uLL)
+#define PRAM_INFO                   ((PRAM_BADDR) + 0x00000F04uLL)
+#define PRAM_WDINFO                 ((PRAM_BADDR) + 0x00000F10uLL)
+#define PRAM_RDINFO                 ((PRAM_BADDR) + 0x00000F14uLL)
+#define PRAM_FSM                    ((PRAM_BADDR) + 0x00000F30uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// MACTOP
+//------------------------------------------------------------------------------------------------------------------
+#define MACTOP_MACCTL_INT_STS       ((MACCTL_BADDR) + 0x00000000uLL)
+#define MACTOP_MACCTL_INT_MSK       ((MACCTL_BADDR) + 0x00000004uLL)
+#define MACTOP_MACCTL_ERR_STS       ((MACCTL_BADDR) + 0x00000008uLL)
+#define MACTOP_MACCTL_ERR_MSK       ((MACCTL_BADDR) + 0x0000000CuLL)
+#define MACTOP_MACCTL_SETTING       ((MACCTL_BADDR) + 0x00000400uLL)
+#define MACTOP_MACCTL_ADD_NOP       ((MACCTL_BADDR) + 0x00000410uLL)
+#define MACTOP_MACCTL_FERR_STS      ((MACCTL_BADDR) + 0x00000800uLL)
+#define MACTOP_MACCTL_FERR_LOG1     ((MACCTL_BADDR) + 0x00000900uLL)
+#define MACTOP_MACCTL_FERR_LOG2     ((MACCTL_BADDR) + 0x00000904uLL)
+#define MACTOP_MACCTL_FERR_LOG3     ((MACCTL_BADDR) + 0x00000908uLL)
+#define MACTOP_MACCTL_STS0_0        ((MACCTL_BADDR) + 0x00001000uLL)
+#define MACTOP_MACCTL_STS0_1        ((MACCTL_BADDR) + 0x00001004uLL)
+#define MACTOP_MACCTL_STS0_2        ((MACCTL_BADDR) + 0x00001008uLL)
+#define MACTOP_MACCTL_STS1_0        ((MACCTL_BADDR) + 0x00001100uLL)
+#define MACTOP_MACCTL_STS1_1        ((MACCTL_BADDR) + 0x00001104uLL)
+#define MACTOP_MACCTL_STS1_2        ((MACCTL_BADDR) + 0x00001108uLL)
+#define MACTOP_MACCTL_STS1_3        ((MACCTL_BADDR) + 0x0000110CuLL)
+#define MACTOP_MACCTL_STS2_0        ((MACCTL_BADDR) + 0x00001180uLL)
+#define MACTOP_MACCTL_STS2_1        ((MACCTL_BADDR) + 0x00001184uLL)
+#define MACTOP_MACCTL_STS2_2        ((MACCTL_BADDR) + 0x00001188uLL)
+#define MACTOP_MACCTL_STS2_3        ((MACCTL_BADDR) + 0x0000118CuLL)
+#define MACTOP_MACCTL_STS2_4        ((MACCTL_BADDR) + 0x00001190uLL)
+#define MACTOP_MACCTL_STS3_0        ((MACCTL_BADDR) + 0x00001200uLL)
+#define MACTOP_MACCTL_STS3_1        ((MACCTL_BADDR) + 0x00001204uLL)
+#define MACTOP_MACCTL_STS3_2        ((MACCTL_BADDR) + 0x00001208uLL)
+#define MACTOP_MACCTL_STS3_3        ((MACCTL_BADDR) + 0x0000120CuLL)
+#define MACTOP_MACCTL_STS3_4        ((MACCTL_BADDR) + 0x00001210uLL)
+#define MACTOP_MACCTL_STS3_5        ((MACCTL_BADDR) + 0x00001214uLL)
+#define MACTOP_MACCTL_STS3_6        ((MACCTL_BADDR) + 0x00001218uLL)
+#define MACTOP_MACCTL_STS3_7        ((MACCTL_BADDR) + 0x0000121CuLL)
+#define MACTOP_MACCTL_STS3_8        ((MACCTL_BADDR) + 0x00001220uLL)
+#define MACTOP_MACCTL_STS3_9        ((MACCTL_BADDR) + 0x00001224uLL)
+#define MACTOP_MACCTL_STS3_10       ((MACCTL_BADDR) + 0x00001228uLL)
+#define MACTOP_MACCTL_STS4_0        ((MACCTL_BADDR) + 0x00001280uLL)
+#define MACTOP_MACCTL_STS4_1        ((MACCTL_BADDR) + 0x00001284uLL)
+#define MACTOP_MACCTL_STS4_2        ((MACCTL_BADDR) + 0x00001288uLL)
+#define MACTOP_MACCTL_STS4_3        ((MACCTL_BADDR) + 0x0000128CuLL)
+#define MACTOP_MACCTL_STS4_4        ((MACCTL_BADDR) + 0x00001290uLL)
+#define MACTOP_MACCTL_STS4_5        ((MACCTL_BADDR) + 0x00001294uLL)
+#define MACTOP_MACCTL_STS4_6        ((MACCTL_BADDR) + 0x00001298uLL)
+#define MACTOP_MACCTL_STS4_7        ((MACCTL_BADDR) + 0x0000129CuLL)
+#define MACTOP_MACCTL_STS4_8        ((MACCTL_BADDR) + 0x000012A0uLL)
+#define MACTOP_MACCTL_STS4_9        ((MACCTL_BADDR) + 0x000012A4uLL)
+#define MACTOP_MACCTL_STS4_10       ((MACCTL_BADDR) + 0x000012A8uLL)
+#define MACTOP_MACCTL_STS5_0        ((MACCTL_BADDR) + 0x00001300uLL)
+#define MACTOP_MACCTL_STS5_1        ((MACCTL_BADDR) + 0x00001304uLL)
+#define MACTOP_MACCTL_STS5_2        ((MACCTL_BADDR) + 0x00001308uLL)
+#define MACTOP_MACCTL_STS5_3        ((MACCTL_BADDR) + 0x0000130CuLL)
+#define MACTOP_MACCTL_STS5_4        ((MACCTL_BADDR) + 0x00001310uLL)
+#define MACTOP_MACCTL_STS5_5        ((MACCTL_BADDR) + 0x00001314uLL)
+#define MACTOP_MACCTL_STS5_6        ((MACCTL_BADDR) + 0x00001318uLL)
+#define MACTOP_MACCTL_STS5_7        ((MACCTL_BADDR) + 0x0000131CuLL)
+#define MACTOP_MACCTL_STS5_8        ((MACCTL_BADDR) + 0x00001320uLL)
+#define MACTOP_MACCTL_STS5_9        ((MACCTL_BADDR) + 0x00001324uLL)
+#define MACTOP_MACCTL_STS5_10       ((MACCTL_BADDR) + 0x00001328uLL)
+#define MACTOP_MACCTL_STS5_11       ((MACCTL_BADDR) + 0x0000132CuLL)
+#define MACTOP_MACCTL_STS5_12       ((MACCTL_BADDR) + 0x00001330uLL)
+#define MACTOP_MACCTL_STS5_13       ((MACCTL_BADDR) + 0x00001334uLL)
+#define MACTOP_MACCTL_STS5_14       ((MACCTL_BADDR) + 0x00001338uLL)
+#define MACTOP_MACCTL_STS5_15       ((MACCTL_BADDR) + 0x0000133CuLL)
+#define MACTOP_MACCTL_STS5_16       ((MACCTL_BADDR) + 0x00001340uLL)
+#define MACTOP_MACCTL_STS5_17       ((MACCTL_BADDR) + 0x00001344uLL)
+#define MACTOP_MACCTL_STS6_0        ((MACCTL_BADDR) + 0x00001380uLL)
+#define MACTOP_MACCTL_STS6_1        ((MACCTL_BADDR) + 0x00001384uLL)
+#define MACTOP_MACCTL_STS6_2        ((MACCTL_BADDR) + 0x00001388uLL)
+#define MACTOP_MACCTL_STS6_3        ((MACCTL_BADDR) + 0x0000138CuLL)
+#define MACTOP_MACCTL_STS6_4        ((MACCTL_BADDR) + 0x00001390uLL)
+#define MACTOP_MACCTL_STS6_5        ((MACCTL_BADDR) + 0x00001394uLL)
+#define MACTOP_MACCTL_STS6_6        ((MACCTL_BADDR) + 0x00001398uLL)
+#define MACTOP_MACCTL_STS6_7        ((MACCTL_BADDR) + 0x0000139CuLL)
+#define MACTOP_MACCTL_STS6_8        ((MACCTL_BADDR) + 0x000013A0uLL)
+#define MACTOP_MACCTL_STS6_9        ((MACCTL_BADDR) + 0x000013A4uLL)
+#define MACTOP_MACCTL_STS6_10       ((MACCTL_BADDR) + 0x000013A8uLL)
+#define MACTOP_MACCTL_STS6_11       ((MACCTL_BADDR) + 0x000013ACuLL)
+#define MACTOP_MACCTL_STS6_12       ((MACCTL_BADDR) + 0x000013B0uLL)
+#define MACTOP_MACCTL_MONITOR1_CTL  ((MACCTL_BADDR) + 0x00001400uLL)
+#define MACTOP_MACCTL_MONITOR2_CTL  ((MACCTL_BADDR) + 0x00001404uLL)
+#define MACTOP_MACCTL_MONITOR1L     ((MACCTL_BADDR) + 0x00001500uLL)
+#define MACTOP_MACCTL_MONITOR1H     ((MACCTL_BADDR) + 0x00001504uLL)
+#define MACTOP_MACCTL_MONITOR2L     ((MACCTL_BADDR) + 0x00001508uLL)
+#define MACTOP_MACCTL_MONITOR2H     ((MACCTL_BADDR) + 0x0000150CuLL)
+#define MACTOP_MACCTL_DBG_LOG_CTL   ((MACCTL_BADDR) + 0x00001700uLL)
+#define MACTOP_MACCTL_DBG_LOG_NUM   ((MACCTL_BADDR) + 0x00001704uLL)
+#define MACTOP_MACCTL_DBG_LOG_RDAT  ((MACCTL_BADDR) + 0x00001708uLL)
+#define MACTOP_MACCTL_DBG_LOG_RSIZE ((MACCTL_BADDR) + 0x0000170CuLL)
+#define MACTOP_MACCTL_DBG_LOG_LID   ((MACCTL_BADDR) + 0x00001710uLL)
+#define MACTOP_MACCTL_DBG_LOG_CID0  ((MACCTL_BADDR) + 0x00001714uLL)
+#define MACTOP_MACCTL_DBG_LOG_CID1  ((MACCTL_BADDR) + 0x00001718uLL)
+
+#define MACTOP_MACCTL_SCNT          ((MACCTL_BADDR) + 0x00001800uLL)
+#define MACTOP_MACCTL_CCNT          ((MACCTL_BADDR) + 0x00001804uLL)
+#define MACTOP_MACCTL_INST_EN       ((MACCTL_BADDR) + 0x00002000uLL)
+#define MACTOP_MACCTL_INST_NUM_M1   ((MACCTL_BADDR) + 0x00002004uLL)
+#define MACTOP_MACCTL_INST_DATA     ((MACCTL_BADDR) + 0x00002100uLL)
+#define MACTOP_MACCTL_BP_MODE       ((MACCTL_BADDR) + 0x00003000uLL)
+#define MACTOP_MACCTL_BP_CTL        ((MACCTL_BADDR) + 0x00003004uLL)
+#define MACTOP_MACCTL_BP_DONE       ((MACCTL_BADDR) + 0x00003008uLL)
+#define MACTOP_MACCTL_BP_CSTART     ((MACCTL_BADDR) + 0x0000300CuLL)
+#define MACTOP_MACCTL_BP_ITR        ((MACCTL_BADDR) + 0x00003010uLL)
+#define MACTOP_MACCTL_BP_INST       ((MACCTL_BADDR) + 0x00003014uLL)
+#define MAC64_0_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00010000uLL)
+#define MAC64_1_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00011000uLL)
+#define MAC64_2_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00012000uLL)
+#define MAC64_3_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00013000uLL)
+#define MAC64_4_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00014000uLL)
+#define MAC64_5_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00015000uLL)
+#define MAC64_6_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00016000uLL)
+#define MAC64_7_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00017000uLL)
+#define MAC64_8_STATUS_REG_BASE     ((MACCTL_BADDR) + 0x00018000uLL)
+                                     
+// MACTOP DCLK
+#define DOFIFO0_STS                 ((MACCTL_DCLK_BADDR) + 0x0000F800uLL)
+#define DOFIFO0_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000F900uLL)
+#define DOFIFO0_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000F904uLL)
+#define DOFIFO0_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000F9F0uLL)
+#define DOFIFO0_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000F9F4uLL)
+#define DOFIFO1_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FA00uLL)
+#define DOFIFO1_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FB00uLL)
+#define DOFIFO1_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FB04uLL)
+#define DOFIFO1_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FBF0uLL)
+#define DOFIFO1_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FBF4uLL)
+#define DOFIFO2_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FC00uLL)
+#define DOFIFO2_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FD00uLL)
+#define DOFIFO2_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FD04uLL)
+#define DOFIFO2_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FDF0uLL)
+#define DOFIFO2_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FDF4uLL)
+#define DOFIFO3_STS                 ((MACCTL_DCLK_BADDR) + 0x0000FE00uLL)
+#define DOFIFO3_RD0_L               ((MACCTL_DCLK_BADDR) + 0x0000FF00uLL)
+#define DOFIFO3_RD0_U               ((MACCTL_DCLK_BADDR) + 0x0000FF04uLL)
+#define DOFIFO3_RD15_L              ((MACCTL_DCLK_BADDR) + 0x0000FFF0uLL)
+#define DOFIFO3_RD15_U              ((MACCTL_DCLK_BADDR) + 0x0000FFF4uLL)
+
+//MACTOP MCLK
+#define DIFIFO0_STS                 ((MACCTL_BADDR) + 0x00008000uLL)
+#define DIFIFO0_RD0_L               ((MACCTL_BADDR) + 0x00008100uLL)
+#define DIFIFO0_RD0_U               ((MACCTL_BADDR) + 0x00008104uLL)
+#define DIFIFO0_RD15_L              ((MACCTL_BADDR) + 0x000081F0uLL)
+#define DIFIFO0_RD15_U              ((MACCTL_BADDR) + 0x000081F4uLL)
+#define DIFIFO1_STS                 ((MACCTL_BADDR) + 0x00008200uLL)
+#define DIFIFO1_RD0_L               ((MACCTL_BADDR) + 0x00008300uLL)
+#define DIFIFO1_RD0_U               ((MACCTL_BADDR) + 0x00008304uLL)
+#define DIFIFO1_RD15_L              ((MACCTL_BADDR) + 0x000083F0uLL)
+#define DIFIFO1_RD15_U              ((MACCTL_BADDR) + 0x000083F4uLL)
+#define DIFIFO2_STS                 ((MACCTL_BADDR) + 0x00008400uLL)
+#define DIFIFO2_RD0_L               ((MACCTL_BADDR) + 0x00008500uLL)
+#define DIFIFO2_RD0_U               ((MACCTL_BADDR) + 0x00008504uLL)
+#define DIFIFO2_RD15_L              ((MACCTL_BADDR) + 0x000085F0uLL)
+#define DIFIFO2_RD15_U              ((MACCTL_BADDR) + 0x000085F4uLL)
+#define DIFIFO3_STS                 ((MACCTL_BADDR) + 0x00008600uLL)
+#define DIFIFO3_RD0_L               ((MACCTL_BADDR) + 0x00008700uLL)
+#define DIFIFO3_RD0_U               ((MACCTL_BADDR) + 0x00008704uLL)
+#define DIFIFO3_RD15_L              ((MACCTL_BADDR) + 0x000087F0uLL)
+#define DIFIFO3_RD15_U              ((MACCTL_BADDR) + 0x000087F4uLL)
+#define MACCTL_INT_STS              ((MACCTL_BADDR) + 0x00000000uLL)
+#define MACCTL_INT_MSK              ((MACCTL_BADDR) + 0x00000004uLL)
+#define MACCTL_ERR_STS              ((MACCTL_BADDR) + 0x00000008uLL)
+#define MACCTL_ERR_MSK              ((MACCTL_BADDR) + 0x0000000CuLL)
+#define MACCTL_INT_CNT              ((MACCTL_BADDR) + 0x00000100uLL)
+#define MACCTL_ERR_CNT              ((MACCTL_BADDR) + 0x00000104uLL)
+#define MACCTL_SETTING              ((MACCTL_BADDR) + 0x00000400uLL)
+#define MACCTL_ADD_NOP              ((MACCTL_BADDR) + 0x00000410uLL)
+#define MACCTL_EXT_HOLD_PERIOD      ((MACCTL_BADDR) + 0x00000420uLL)
+#define MACCTL_EXT_HOLD_TH          ((MACCTL_BADDR) + 0x00000424uLL)
+#define MACCTL_NZNUM_CLR            ((MACCTL_BADDR) + 0x00000430uLL)
+#define MACCTL_NZNUM_TH             ((MACCTL_BADDR) + 0x00000434uLL)
+#define MACCTL_NZNUM_SET            ((MACCTL_BADDR) + 0x00000438uLL)
+#define MACCTL_PPU_NOP              ((MACCTL_BADDR) + 0x00000440uLL)
+#define MACCTL_WAIT_IM_NUM          ((MACCTL_BADDR) + 0x00000444uLL)
+#define MACCTL_INST_EBL             ((MACCTL_BADDR) + 0x00000450uLL)
+#define MACCTL_MAC_DATA_EBL         ((MACCTL_BADDR) + 0x00000460uLL)
+#define MACCTL_SET_PRAM_TH          ((MACCTL_BADDR) + 0x00000470uLL)
+#define MACCTL_GUARD                ((MACCTL_BADDR) + 0x00000480uLL)
+#define MACCTL_WAIT_IM_READY        ((MACCTL_BADDR) + 0x00000490uLL)
+#define MACCTL_FMA_OP_LIMIT2        ((MACCTL_BADDR) + 0x000004A0uLL)
+#define MACCTL_FERR_STS             ((MACCTL_BADDR) + 0x00000800uLL)
+#define MACCTL_FERR_LOG1            ((MACCTL_BADDR) + 0x00000900uLL)
+#define MACCTL_FERR_LOG2            ((MACCTL_BADDR) + 0x00000904uLL)
+#define MACCTL_FERR_LOG3            ((MACCTL_BADDR) + 0x00000908uLL)
+#define MACCTL_STS0_0               ((MACCTL_BADDR) + 0x00001000uLL)
+#define MACCTL_STS0_1               ((MACCTL_BADDR) + 0x00001004uLL)
+#define MACCTL_STS0_2               ((MACCTL_BADDR) + 0x00001008uLL)
+#define MACCTL_STS1_0               ((MACCTL_BADDR) + 0x00001100uLL)
+#define MACCTL_STS1_1               ((MACCTL_BADDR) + 0x00001104uLL)
+#define MACCTL_STS1_2               ((MACCTL_BADDR) + 0x00001108uLL)
+#define MACCTL_STS1_3               ((MACCTL_BADDR) + 0x0000110CuLL)
+#define MACCTL_STS2_0               ((MACCTL_BADDR) + 0x00001180uLL)
+#define MACCTL_STS2_1               ((MACCTL_BADDR) + 0x00001184uLL)
+#define MACCTL_STS2_2               ((MACCTL_BADDR) + 0x00001188uLL)
+#define MACCTL_STS2_3               ((MACCTL_BADDR) + 0x0000118CuLL)
+#define MACCTL_STS2_4               ((MACCTL_BADDR) + 0x00001190uLL)
+#define MACCTL_STS3_0               ((MACCTL_BADDR) + 0x00001200uLL)
+#define MACCTL_STS3_1               ((MACCTL_BADDR) + 0x00001204uLL)
+#define MACCTL_STS3_2               ((MACCTL_BADDR) + 0x00001208uLL)
+#define MACCTL_STS3_3               ((MACCTL_BADDR) + 0x0000120CuLL)
+#define MACCTL_STS3_4               ((MACCTL_BADDR) + 0x00001210uLL)
+#define MACCTL_STS3_5               ((MACCTL_BADDR) + 0x00001214uLL)
+#define MACCTL_STS3_6               ((MACCTL_BADDR) + 0x00001218uLL)
+#define MACCTL_STS3_7               ((MACCTL_BADDR) + 0x0000121CuLL)
+#define MACCTL_STS3_8               ((MACCTL_BADDR) + 0x00001220uLL)
+#define MACCTL_STS3_9               ((MACCTL_BADDR) + 0x00001224uLL)
+#define MACCTL_STS3_10              ((MACCTL_BADDR) + 0x00001228uLL)
+#define MACCTL_STS4_0               ((MACCTL_BADDR) + 0x00001280uLL)
+#define MACCTL_STS4_1               ((MACCTL_BADDR) + 0x00001284uLL)
+#define MACCTL_STS4_2               ((MACCTL_BADDR) + 0x00001288uLL)
+#define MACCTL_STS4_3               ((MACCTL_BADDR) + 0x0000128CuLL)
+#define MACCTL_STS4_4               ((MACCTL_BADDR) + 0x00001290uLL)
+#define MACCTL_STS4_5               ((MACCTL_BADDR) + 0x00001294uLL)
+#define MACCTL_STS4_6               ((MACCTL_BADDR) + 0x00001298uLL)
+#define MACCTL_STS4_7               ((MACCTL_BADDR) + 0x0000129CuLL)
+#define MACCTL_STS4_8               ((MACCTL_BADDR) + 0x000012A0uLL)
+#define MACCTL_STS4_9               ((MACCTL_BADDR) + 0x000012A4uLL)
+#define MACCTL_STS4_10              ((MACCTL_BADDR) + 0x000012A8uLL)
+#define MACCTL_STS5_0               ((MACCTL_BADDR) + 0x00001300uLL)
+#define MACCTL_STS5_1               ((MACCTL_BADDR) + 0x00001304uLL)
+#define MACCTL_STS5_2               ((MACCTL_BADDR) + 0x00001308uLL)
+#define MACCTL_STS5_3               ((MACCTL_BADDR) + 0x0000130CuLL)
+#define MACCTL_STS5_4               ((MACCTL_BADDR) + 0x00001310uLL)
+#define MACCTL_STS5_5               ((MACCTL_BADDR) + 0x00001314uLL)
+#define MACCTL_STS5_6               ((MACCTL_BADDR) + 0x00001318uLL)
+#define MACCTL_STS5_7               ((MACCTL_BADDR) + 0x0000131CuLL)
+#define MACCTL_STS5_8               ((MACCTL_BADDR) + 0x00001320uLL)
+#define MACCTL_STS5_9               ((MACCTL_BADDR) + 0x00001324uLL)
+#define MACCTL_STS5_10              ((MACCTL_BADDR) + 0x00001328uLL)
+#define MACCTL_STS5_11              ((MACCTL_BADDR) + 0x0000132CuLL)
+#define MACCTL_STS5_12              ((MACCTL_BADDR) + 0x00001330uLL)
+#define MACCTL_STS5_13              ((MACCTL_BADDR) + 0x00001334uLL)
+#define MACCTL_STS5_14              ((MACCTL_BADDR) + 0x00001338uLL)
+#define MACCTL_STS5_15              ((MACCTL_BADDR) + 0x0000133CuLL)
+#define MACCTL_STS5_16              ((MACCTL_BADDR) + 0x00001340uLL)
+#define MACCTL_STS5_17              ((MACCTL_BADDR) + 0x00001344uLL)
+#define MACCTL_STS6_0               ((MACCTL_BADDR) + 0x00001380uLL)
+#define MACCTL_STS6_1               ((MACCTL_BADDR) + 0x00001384uLL)
+#define MACCTL_STS6_2               ((MACCTL_BADDR) + 0x00001388uLL)
+#define MACCTL_STS6_3               ((MACCTL_BADDR) + 0x0000138CuLL)
+#define MACCTL_STS6_4               ((MACCTL_BADDR) + 0x00001390uLL)
+#define MACCTL_STS6_5               ((MACCTL_BADDR) + 0x00001394uLL)
+#define MACCTL_STS6_6               ((MACCTL_BADDR) + 0x00001398uLL)
+#define MACCTL_STS6_7               ((MACCTL_BADDR) + 0x0000139CuLL)
+#define MACCTL_STS6_8               ((MACCTL_BADDR) + 0x000013A0uLL)
+#define MACCTL_STS6_9               ((MACCTL_BADDR) + 0x000013A4uLL)
+#define MACCTL_STS6_10              ((MACCTL_BADDR) + 0x000013A8uLL)
+#define MACCTL_STS6_11              ((MACCTL_BADDR) + 0x000013ACuLL)
+#define MACCTL_STS6_12              ((MACCTL_BADDR) + 0x000013B0uLL)
+#define MACCTL_MONITOR1_CTL         ((MACCTL_BADDR) + 0x00001400uLL)
+#define MACCTL_MONITOR2_CTL         ((MACCTL_BADDR) + 0x00001404uLL)
+#define MACCTL_MONITOR1L            ((MACCTL_BADDR) + 0x00001500uLL)
+#define MACCTL_MONITOR1H            ((MACCTL_BADDR) + 0x00001504uLL)
+#define MACCTL_MONITOR2L            ((MACCTL_BADDR) + 0x00001508uLL)
+#define MACCTL_MONITOR2H            ((MACCTL_BADDR) + 0x0000150CuLL)
+#define MACCTL_DBG_LOG_CTL          ((MACCTL_BADDR) + 0x00001700uLL)
+#define MACCTL_DBG_LOG_NUM          ((MACCTL_BADDR) + 0x00001704uLL)
+#define MACCTL_DBG_LOG_RDAT         ((MACCTL_BADDR) + 0x00001708uLL)
+#define MACCTL_SCNT                 ((MACCTL_BADDR) + 0x00001800uLL)
+#define MACCTL_CCNT                 ((MACCTL_BADDR) + 0x00001804uLL)
+#define MACCTL_INST_EN              ((MACCTL_BADDR) + 0x00002000uLL)
+#define MACCTL_INST_NUM_M1          ((MACCTL_BADDR) + 0x00002004uLL)
+#define MACCTL_INST                 ((MACCTL_BADDR) + 0x00002100uLL)
+#define MACCTL_BP_MODE              ((MACCTL_BADDR) + 0x00003000uLL)
+#define MACCTL_BP_CTL               ((MACCTL_BADDR) + 0x00003004uLL)
+#define MACCTL_BP_DONE              ((MACCTL_BADDR) + 0x00003008uLL)
+#define MACCTL_BP_CSTART            ((MACCTL_BADDR) + 0x0000300CuLL)
+#define MACCTL_BP_ITR               ((MACCTL_BADDR) + 0x00003010uLL)
+#define MACCTL_BP_INST              ((MACCTL_BADDR) + 0x00003014uLL)
+#define CFIFO_STS                   ((MACCTL_BADDR) + 0x00007000uLL)
+#define CFIFO_RD0_L                 ((MACCTL_BADDR) + 0x00007100uLL)
+#define CFIFO_RD0_LM                ((MACCTL_BADDR) + 0x00007104uLL)
+#define CFIFO_RD0_UM                ((MACCTL_BADDR) + 0x00007108uLL)
+#define CFIFO_RD0_U                 ((MACCTL_BADDR) + 0x0000710CuLL)
+#define CFIFO_RD1_L                 ((MACCTL_BADDR) + 0x00007110uLL)
+#define CFIFO_RD1_LM                ((MACCTL_BADDR) + 0x00007114uLL)
+#define CFIFO_RD1_UM                ((MACCTL_BADDR) + 0x00007118uLL)
+#define CFIFO_RD1_U                 ((MACCTL_BADDR) + 0x0000711CuLL)
+#define CFIFO_RD2_L                 ((MACCTL_BADDR) + 0x00007120uLL)
+#define CFIFO_RD2_LM                ((MACCTL_BADDR) + 0x00007124uLL)
+#define CFIFO_RD2_UM                ((MACCTL_BADDR) + 0x00007128uLL)
+#define CFIFO_RD2_U                 ((MACCTL_BADDR) + 0x0000712CuLL)
+#define CFIFO_RD3_L                 ((MACCTL_BADDR) + 0x00007130uLL)
+#define CFIFO_RD3_LM                ((MACCTL_BADDR) + 0x00007134uLL)
+#define CFIFO_RD3_UM                ((MACCTL_BADDR) + 0x00007138uLL)
+#define CFIFO_RD3_U                 ((MACCTL_BADDR) + 0x0000713CuLL)
+#define CFIFO_RD4_L                 ((MACCTL_BADDR) + 0x00007140uLL)
+#define CFIFO_RD4_LM                ((MACCTL_BADDR) + 0x00007144uLL)
+#define CFIFO_RD4_UM                ((MACCTL_BADDR) + 0x00007148uLL)
+#define CFIFO_RD4_U                 ((MACCTL_BADDR) + 0x0000714CuLL)
+#define CFIFO_RD5_L                 ((MACCTL_BADDR) + 0x00007150uLL)
+#define CFIFO_RD5_LM                ((MACCTL_BADDR) + 0x00007154uLL)
+#define CFIFO_RD5_UM                ((MACCTL_BADDR) + 0x00007158uLL)
+#define CFIFO_RD5_U                 ((MACCTL_BADDR) + 0x0000715CuLL)
+#define CFIFO_RD6_L                 ((MACCTL_BADDR) + 0x00007160uLL)
+#define CFIFO_RD6_LM                ((MACCTL_BADDR) + 0x00007164uLL)
+#define CFIFO_RD6_UM                ((MACCTL_BADDR) + 0x00007168uLL)
+#define CFIFO_RD6_U                 ((MACCTL_BADDR) + 0x0000716CuLL)
+#define CFIFO_RD7_L                 ((MACCTL_BADDR) + 0x00007170uLL)
+#define CFIFO_RD7_LM                ((MACCTL_BADDR) + 0x00007174uLL)
+#define CFIFO_RD7_UM                ((MACCTL_BADDR) + 0x00007178uLL)
+#define CFIFO_RD7_U                 ((MACCTL_BADDR) + 0x0000717CuLL)
+#define CFIFO_RD8_L                 ((MACCTL_BADDR) + 0x00007180uLL)
+#define CFIFO_RD8_LM                ((MACCTL_BADDR) + 0x00007184uLL)
+#define CFIFO_RD8_UM                ((MACCTL_BADDR) + 0x00007188uLL)
+#define CFIFO_RD8_U                 ((MACCTL_BADDR) + 0x0000718CuLL)
+#define CFIFO_RD9_L                 ((MACCTL_BADDR) + 0x00007190uLL)
+#define CFIFO_RD9_LM                ((MACCTL_BADDR) + 0x00007194uLL)
+#define CFIFO_RD9_UM                ((MACCTL_BADDR) + 0x00007198uLL)
+#define CFIFO_RD9_U                 ((MACCTL_BADDR) + 0x0000719CuLL)
+#define CFIFO_RD10_L                ((MACCTL_BADDR) + 0x000071A0uLL)
+#define CFIFO_RD10_LM               ((MACCTL_BADDR) + 0x000071A4uLL)
+#define CFIFO_RD10_UM               ((MACCTL_BADDR) + 0x000071A8uLL)
+#define CFIFO_RD10_U                ((MACCTL_BADDR) + 0x000071ACuLL)
+#define CFIFO_RD11_L                ((MACCTL_BADDR) + 0x000071B0uLL)
+#define CFIFO_RD11_LM               ((MACCTL_BADDR) + 0x000071B4uLL)
+#define CFIFO_RD11_UM               ((MACCTL_BADDR) + 0x000071B8uLL)
+#define CFIFO_RD11_U                ((MACCTL_BADDR) + 0x000071BCuLL)
+#define CFIFO_RD12_L                ((MACCTL_BADDR) + 0x000071C0uLL)
+#define CFIFO_RD12_LM               ((MACCTL_BADDR) + 0x000071C4uLL)
+#define CFIFO_RD12_UM               ((MACCTL_BADDR) + 0x000071C8uLL)
+#define CFIFO_RD12_U                ((MACCTL_BADDR) + 0x000071CCuLL)
+#define CFIFO_RD13_L                ((MACCTL_BADDR) + 0x000071D0uLL)
+#define CFIFO_RD13_LM               ((MACCTL_BADDR) + 0x000071D4uLL)
+#define CFIFO_RD13_UM               ((MACCTL_BADDR) + 0x000071D8uLL)
+#define CFIFO_RD13_U                ((MACCTL_BADDR) + 0x000071DCuLL)
+#define CFIFO_RD14_L                ((MACCTL_BADDR) + 0x000071E0uLL)
+#define CFIFO_RD14_LM               ((MACCTL_BADDR) + 0x000071E4uLL)
+#define CFIFO_RD14_UM               ((MACCTL_BADDR) + 0x000071E8uLL)
+#define CFIFO_RD14_U                ((MACCTL_BADDR) + 0x000071ECuLL)
+#define CFIFO_RD15_L                ((MACCTL_BADDR) + 0x000071F0uLL)
+#define CFIFO_RD15_LM               ((MACCTL_BADDR) + 0x000071F4uLL)
+#define CFIFO_RD15_UM               ((MACCTL_BADDR) + 0x000071F8uLL)
+#define CFIFO_RD15_U                ((MACCTL_BADDR) + 0x000071FCuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// MAC64 (stp/b1top/env/bench/v/reg_address_mac4k.v)
+//------------------------------------------------------------------------------------------------------------------
+#define MAC64_0_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x000000uLL)
+#define MAC64_1_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x001000uLL)
+#define MAC64_2_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x002000uLL)
+#define MAC64_3_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x003000uLL)
+#define MAC64_4_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x004000uLL)
+#define MAC64_5_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x005000uLL)
+#define MAC64_6_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x006000uLL)
+#define MAC64_7_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x007000uLL)
+#define MAC64_8_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x008000uLL)
+#define MAC64_9_BASE_ADDRESS        ((MAC4K_BASE_ADDRESS) + 0x009000uLL)
+#define MAC64_10_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00A000uLL)
+#define MAC64_11_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00B000uLL)
+#define MAC64_12_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00C000uLL)
+#define MAC64_13_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00D000uLL)
+#define MAC64_14_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00E000uLL)
+#define MAC64_15_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x00F000uLL)
+
+#define MAC64_16_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x010000uLL)
+#define MAC64_17_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x011000uLL)
+#define MAC64_18_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x012000uLL)
+#define MAC64_19_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x013000uLL)
+#define MAC64_20_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x014000uLL)
+#define MAC64_21_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x015000uLL)
+#define MAC64_22_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x016000uLL)
+#define MAC64_23_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x017000uLL)
+#define MAC64_24_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x018000uLL)
+#define MAC64_25_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x019000uLL)
+#define MAC64_26_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01A000uLL)
+#define MAC64_27_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01B000uLL)
+#define MAC64_28_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01C000uLL)
+#define MAC64_29_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01D000uLL)
+#define MAC64_30_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01E000uLL)
+#define MAC64_31_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x01F000uLL)
+
+#define MAC64_32_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x020000uLL)
+#define MAC64_33_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x021000uLL)
+#define MAC64_34_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x022000uLL)
+#define MAC64_35_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x023000uLL)
+#define MAC64_36_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x024000uLL)
+#define MAC64_37_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x025000uLL)
+#define MAC64_38_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x026000uLL)
+#define MAC64_39_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x027000uLL)
+#define MAC64_40_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x028000uLL)
+#define MAC64_41_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x029000uLL)
+#define MAC64_42_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02A000uLL)
+#define MAC64_43_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02B000uLL)
+#define MAC64_44_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02C000uLL)
+#define MAC64_45_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02D000uLL)
+#define MAC64_46_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02E000uLL)
+#define MAC64_47_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x02F000uLL)
+
+#define MAC64_48_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x030000uLL)
+#define MAC64_49_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x031000uLL)
+#define MAC64_50_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x032000uLL)
+#define MAC64_51_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x033000uLL)
+#define MAC64_52_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x034000uLL)
+#define MAC64_53_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x035000uLL)
+#define MAC64_54_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x036000uLL)
+#define MAC64_55_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x037000uLL)
+#define MAC64_56_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x038000uLL)
+#define MAC64_57_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x039000uLL)
+#define MAC64_58_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03A000uLL)
+#define MAC64_59_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03B000uLL)
+#define MAC64_60_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03C000uLL)
+#define MAC64_61_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03D000uLL)
+#define MAC64_62_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03E000uLL)
+#define MAC64_63_BASE_ADDRESS       ((MAC4K_BASE_ADDRESS) + 0x03F000uLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// FMBUF
+//------------------------------------------------------------------------------------------------------------------
+#define FMBUF_ERR_STS               ((FMBUF_BADDR) + 0x00000000uLL)
+#define FMBUF_ERR_MSK               ((FMBUF_BADDR) + 0x00000004uLL)
+#define FMBUF_FMAP_CTRL             ((FMBUF_BADDR) + 0x00000100uLL)
+#define FMBUF_FMAP_IM_ARB           ((FMBUF_BADDR) + 0x00000104uLL)
+#define FMBUF_EXTIN_CTRL            ((FMBUF_BADDR) + 0x00000118uLL)
+#define FMBUF_EXTOUT_CTRL           ((FMBUF_BADDR) + 0x00000120uLL)
+#define FMBUF_FB_W_INTERVAL0        ((FMBUF_BADDR) + 0x00000130uLL)
+#define FMBUF_FB_W_INTERVAL1        ((FMBUF_BADDR) + 0x00000134uLL)
+#define FMBUF_FB_W_INTERVAL2        ((FMBUF_BADDR) + 0x00000138uLL)
+#define FMBUF_FB_W_INTERVAL3        ((FMBUF_BADDR) + 0x0000013CuLL)
+#define FMBUF_FB_W_INTERVAL4        ((FMBUF_BADDR) + 0x00000140uLL)
+#define FMBUF_FB_W_INTERVAL5        ((FMBUF_BADDR) + 0x00000144uLL)
+#define FMBUF_STS0                  ((FMBUF_BADDR) + 0x00000200uLL)
+#define FMBUF_STS1                  ((FMBUF_BADDR) + 0x00000204uLL)
+#define FMBUF_STS2                  ((FMBUF_BADDR) + 0x00000208uLL)
+#define FMBUF_STS3                  ((FMBUF_BADDR) + 0x0000020CuLL)
+#define FMBUF_STS4                  ((FMBUF_BADDR) + 0x00000210uLL)
+#define FMBUF_STS5                  ((FMBUF_BADDR) + 0x00000214uLL)
+#define FMBUF_STS6                  ((FMBUF_BADDR) + 0x00000218uLL)
+#define FMBUF_DEBUG                 ((FMBUF_BADDR) + 0x00000E00uLL)
+#define FMBUF_CNTER_CLR             ((FMBUF_BADDR) + 0x00000E04uLL)
+#define FMBUF_CNTER_SEL0            ((FMBUF_BADDR) + 0x00000E10uLL)
+#define FMBUF_CNTER_SEL1            ((FMBUF_BADDR) + 0x00000E14uLL)
+#define FMBUF_CNTER_SEL2            ((FMBUF_BADDR) + 0x00000E18uLL)
+#define FMBUF_CNTER_SEL3            ((FMBUF_BADDR) + 0x00000E1CuLL)
+#define FMBUF_CALC_START_CNT        ((FMBUF_BADDR) + 0x00000E20uLL)
+#define FMBUF_TARGET                ((FMBUF_BADDR) + 0x00000E24uLL)
+#define FMBUF_CNT0                  ((FMBUF_BADDR) + 0x00000E30uLL)
+#define FMBUF_CNT1                  ((FMBUF_BADDR) + 0x00000E34uLL)
+#define FMBUF_CNT2                  ((FMBUF_BADDR) + 0x00000E38uLL)
+#define FMBUF_CNT3                  ((FMBUF_BADDR) + 0x00000E3CuLL)
+#define FMBUF_CNT4                  ((FMBUF_BADDR) + 0x00000E40uLL)
+#define FMBUF_CNT5                  ((FMBUF_BADDR) + 0x00000E44uLL)
+#define FMBUF_CNT6                  ((FMBUF_BADDR) + 0x00000E48uLL)
+#define FMBUF_CNT7                  ((FMBUF_BADDR) + 0x00000E4CuLL)
+#define FMBUF_CNT8                  ((FMBUF_BADDR) + 0x00000E50uLL)
+#define FMBUF_CNT9                  ((FMBUF_BADDR) + 0x00000E54uLL)
+#define FMBUF_CNT10                 ((FMBUF_BADDR) + 0x00000E58uLL)
+#define FMBUF_CNT11                 ((FMBUF_BADDR) + 0x00000E5CuLL)
+#define FMBUF_CNT12                 ((FMBUF_BADDR) + 0x00000E60uLL)
+#define FMBUF_CNT13                 ((FMBUF_BADDR) + 0x00000E64uLL)
+#define FMBUF_CNT14                 ((FMBUF_BADDR) + 0x00000E68uLL)
+#define FMBUF_CNT15                 ((FMBUF_BADDR) + 0x00000E6CuLL)
+#define FMBUF_MMON_CTRL             ((FMBUF_BADDR) + 0x00000E80uLL)
+#define FMBUF_MEMLOG                ((FMBUF_BADDR) + 0x00000E84uLL)
+#define FMBUF_CHICKEN0              ((FMBUF_BADDR) + 0x00000F00uLL)
+#define FMBUF_CHICKEN1              ((FMBUF_BADDR) + 0x00000F04uLL)
+#define FMBUF_CLK_CTRL              ((FMBUF_BADDR) + 0x00000F08uLL)
+                                                 
+//------------------------------------------------------------------------------------------------------------------
+// AIDMAC
+//------------------------------------------------------------------------------------------------------------------
+#define AID0_IDIF2_INT_REG              ((AID0_IDIF2_BADDR) + 0x000uLL)
+#define AID0_IDIF2_INTMSK_REG           ((AID0_IDIF2_BADDR) + 0x004uLL)
+#define AID0_IDIF2_EINT_REG             ((AID0_IDIF2_BADDR) + 0x008uLL)
+#define AID0_IDIF2_EINTMSK_REG          ((AID0_IDIF2_BADDR) + 0x00CuLL)
+#define AID0_IDIF2_EINT_DSC_REG         ((AID0_IDIF2_BADDR) + 0x010uLL)
+#define AID0_IDIF2_EINTMSK_DSC_REG      ((AID0_IDIF2_BADDR) + 0x014uLL)
+#define AID0_IDIF2_INTMSKSET_REG        ((AID0_IDIF2_BADDR) + 0x020uLL)
+#define AID0_IDIF2_INTMSKCLR_REG        ((AID0_IDIF2_BADDR) + 0x024uLL)
+#define AID0_IDIF2_EINTMSKSET_REG       ((AID0_IDIF2_BADDR) + 0x030uLL)
+#define AID0_IDIF2_EINTMSKCLR_REG       ((AID0_IDIF2_BADDR) + 0x034uLL)
+#define AID0_IDIF2_EINTMSKDSCSET_REG    ((AID0_IDIF2_BADDR) + 0x038uLL)
+#define AID0_IDIF2_EINTMSKDSCCLR_REG    ((AID0_IDIF2_BADDR) + 0x03CuLL)
+
+//------------------------------------------------------------------------------------------------------------------
+// INTMON
+//------------------------------------------------------------------------------------------------------------------
+#define INTM_INT_REG                ((INTMON_BADR) + 0x000uLL)
+#define INTM_ERRINT_REG             ((INTMON_BADR) + 0x008uLL)
+                                                 
+//------------------------------------------------------------------------------------------------------------------
+// CPG
+//------------------------------------------------------------------------------------------------------------------
+#define CPG_BADDR                   (0x10420000uLL)
+
+// PLLETH
+#define CPG_PLLETH_STBY_REG         (0x0A0uLL)
+#define CPG_PLLETH_MON_REG          (0x0B0uLL)
+
+// MSTOP
+#define CPG_BUS_8_MSTOP_REG         (0xD1CuLL)     // 0=module operating(initial),1=stopF[8]=AIMAC, [9]=STP, [10]=DRP
+#define CPG_BUS_9_MSTOP_REG         (0xD20uLL)
+
+// BUS
+#define CPG_BUS_12_MSTOP_REG        (0xD2CuLL)
+
+// ACLK dividing ratio setting
+#define CPG_CDDIV2_REG              (0x408uLL)      // PLLCM33_CST400_GEAR dividing ratio setting
+#define CPG_CLKON_1_REG             (0x604uLL)
+#define CPG_CLKON_17_REG            (0x644uLL)      // CLK_ON(0=OFF(initial),1=ON) : [0]=DRP.DCLKIN, [1]=DRP.ACLK, [2]=DRP.INITCLK, [3]=DRPAI.DCLKIN, [4]=DRPAI.ACLK, [5]=DRPAI.INITCLK, [6]=DRPAI.MCLK
+#define CPG_CLKSTATUS0_REG          (0x700uLL)      // PLLCM33_CST400_GEAR status check
+#define CPG_CLKMON_0_REG            (0x800uLL)      // Clock monitor
+#define CPG_CLKMON_8_REG            (0x820uLL)      // Clock monitor
+
+// RESETn
+#define CPG_RST_3_REG               (0x90CuLL)
+#define CPG_RST_4_REG               (0x910uLL)
+#define CPG_RST_15_REG              (0x93CuLL)      // reset control (0=ResetON(initial), 1=OFF):[12]=DRP.ARESETn, [13]=DRPAI.ARESETn)
+#define CPG_RSTMON_1_REG            (0xA04uLL)      // reset monitor
+#define CPG_RSTMON_7_REG            (0xA1CuLL)      // reset monitor
+
+
+//------------------------------------------------------------------------------------------------------------------
+// Error Status Register
+//------------------------------------------------------------------------------------------------------------------
+//[drp error status]
+#define STPC_ERRINT_STS_ADDR        (0x00F1D808uLL)
+#define DRP_ERRINT_STATUS_ADDR      (0x003B0048uLL)
+#define IDIF_EINT_ADDR              (0x00F19008uLL)
+#define IDIF_EINT_DSC_ADDR          (0x00F19010uLL)
+#define ODIF_EINT_ADDR              (0x00F1A008uLL)
+#define IDMAC_INTSE_ADDR            (0x00F1B020uLL)
+#define IDMAC_AERS_ADDR             (0x00F1B030uLL)
+#define ODMAC_INTSE_ADDR            (0x00F1C020uLL)
+#define ODMAC_AERS_ADDR             (0x00F1C030uLL)
+//[aimac error status]
+#define INTMON_ERRINT_ADDR          (0x00141008uLL)
+#define AID0_IDIF_EINT_ADDR         (0x00119008uLL)
+#define AID0_IDIF2_EINT_DSC_ADDR    (0x0011A010uLL)
+#define AID0_IDMAC_INTSE_ADDR       (0x0011B020uLL)
+#define AID0_IDMAC_AERS_ADDR        (0x0011B030uLL)
+#define AID1_IDIF_EINT_ADDR         (0x000D9008uLL)
+#define AID1_IDMAC_INTSE_ADDR       (0x000DB020uLL)
+#define AID1_IDMAC_AERS_ADDR        (0x000DB030uLL)
+#define EXD0_IDIF_EINT_ADDR         (0x00019008uLL)
+#define EXD0_IDIF_DSC_ADDR          (0x00019010uLL)
+#define EXD0_ODIF_EINT_ADDR         (0x0001A008uLL)
+#define EXD0_IDMAC_INTSE_ADDR       (0x0001B020uLL)
+#define EXD0_IDMAC_AERS_ADDR        (0x0001B030uLL)
+#define EXD0_ODMAC_INTSE_ADDR       (0x0001C020uLL)
+#define EXD0_ODMAC_AERS_ADDR        (0x0001C030uLL)
+#define EXD1_IDIF_EINT_ADDR         (0x00059008uLL)
+#define EXD1_ODIF_EINT_ADDR         (0x0005A008uLL)
+#define EXD1_IDMAC_INTSE_ADDR       (0x0005B020uLL)
+#define EXD1_IDMAC_AERS_ADDR        (0x0005B030uLL)
+#define EXD1_ODMAC_INTSE_ADDR       (0x0005C020uLL)
+#define EXD1_ODMAC_AERS_ADDR        (0x0005C030uLL)
+#define PRAM_INT_ADDR               (0x00200000uLL)
+#define FMBUF_ERR_STS_ADDR          (0x001E0000uLL)
+#define MACCTL_ERR_STS_ADDR         (0x001C0008uLL)
+
+#endif /* DRP_REG__H */
diff -uprN old/drivers/drp/lock_drp.c new/drivers/drp/lock_drp.c
--- old/drivers/drp/lock_drp.c	1970-01-01 09:00:00.000000000 +0900
+++ new/drivers/drp/lock_drp.c	2023-10-10 16:02:45.000000000 +0900
@@ -0,0 +1,58 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP-AI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#include <stddef.h>
+#include "lock_drp.h"
+
+int lock_drp(unsigned long long *addr, unsigned int num)
+{
+	int result = 0;
+	unsigned long long old_value;
+
+	/* Check Arguments. */
+	if ((NULL == addr) || (((unsigned long long)addr & 0x7uLL) != 0) || (num >= 64))
+	{
+		result = -2;
+	}
+	else
+	{
+		/* set the specified bit. */
+		old_value = __sync_fetch_and_or(addr, (1uLL << num));
+		/* Check previous value. */
+		if ((old_value & (1uLL << num)) != 0)
+		{
+		  result = -1;
+		}
+	}
+
+	return result;
+}
+
+int unlock_drp(unsigned long long *addr, unsigned int num)
+{
+	int result = 0;
+
+	/* Check Arguments. */
+	if ((NULL == addr) || (((unsigned long long)addr & 0x7uLL) != 0) || (num >= 64))
+	{
+		result = -2;
+	}
+	else
+	{
+		/* Clear the specified bit. */
+		(void)__sync_fetch_and_and(addr, ~(1uLL << num));
+	}
+	return result;
+}
diff -uprN old/drivers/drp/lock_drp.h new/drivers/drp/lock_drp.h
--- old/drivers/drp/lock_drp.h	1970-01-01 09:00:00.000000000 +0900
+++ new/drivers/drp/lock_drp.h	2024-01-31 17:31:53.000000000 +0900
@@ -0,0 +1,30 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP-AI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef R_DRP_LOCK_H
+#define R_DRP_LOCK_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+ int lock_drp(unsigned long long *addr, unsigned int num);
+ int unlock_drp(unsigned long long * addr, unsigned int num);
+ 
+#ifdef __cplusplus
+}
+#endif /* __cplusplus */
+
+#endif /* R_DRP_LOCK_H */
diff -uprN old/include/linux/drp.h new/include/linux/drp.h
--- old/include/linux/drp.h	1970-01-01 09:00:00.000000000 +0900
+++ new/include/linux/drp.h	2023-08-22 16:15:57.000000000 +0900
@@ -0,0 +1,22 @@
+/*
+ * Driver for the Renesas RZ/V2H DRP unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _DRP_H
+#define _DRP_H
+
+#include <uapi/linux/drp.h>
+
+#endif /* _DRP_H */
diff -uprN old/include/uapi/linux/drp.h new/include/uapi/linux/drp.h
--- old/include/uapi/linux/drp.h	1970-01-01 09:00:00.000000000 +0900
+++ new/include/uapi/linux/drp.h	2023-11-29 18:11:03.000000000 +0900
@@ -0,0 +1,95 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Driver for the Renesas RZ/V2H DRPI unit
+ *
+ * Copyright (C) 2023 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI__DRP_H
+#define _UAPI__DRP_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <linux/ioctl.h>
+
+#define DRP_IO_TYPE               (46)
+#define DRP_ASSIGN                _IOW (DRP_IO_TYPE, 0, drp_data_t)
+#define DRP_START                 _IOW (DRP_IO_TYPE, 1, drp_data_t)
+#define DRP_RESET                 _IO  (DRP_IO_TYPE, 2)
+#define DRP_GET_STATUS            _IOR (DRP_IO_TYPE, 3, drp_status_t)
+#define DRP_SET_SEQ               _IOW (DRP_IO_TYPE, 6, drp_seq_t)           /* Since the sturecture size is different,            */
+#define DRP_GET_CODEC_AREA        _IOR (DRP_IO_TYPE, 11, drp_data_t)
+#define DRP_GET_OPENCVA_AREA      _IOR (DRP_IO_TYPE, 12, drp_data_t)
+#define DRP_SET_DRP_MAX_FREQ      _IOW (DRP_IO_TYPE, 13, uint32_t)
+#define DRP_READ_DRP_REG          _IOWR(DRP_IO_TYPE, 64, drp_reg_t)
+#define DRP_WRITE_DRP_REG         _IOW (DRP_IO_TYPE, 65, drp_reg_t)
+
+#define DRP_STATUS_INIT                   (0)
+#define DRP_STATUS_IDLE                   (1)
+#define DRP_STATUS_RUN                    (2)
+#define DRP_ERRINFO_SUCCESS               (0)
+#define DRP_ERRINFO_DRP_ERR               (-1)
+#define DRP_ERRINFO_RESET                 (-3)
+#define DRP_RESERVED_NUM                  (10)
+#define DRP_SEQ_NUM                       (20)
+#define DRP_EXE_DRP_40BIT                 (3)
+#define DRP_OPMASK_FORCE_LOAD             (0x8000)
+#define PARAM_ADDRESS_NUM                 (120)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drp_data
+{
+    uint64_t        address;
+    uint32_t        size;
+} drp_data_t;
+
+typedef struct drp_status
+{
+    uint32_t        status;
+    int32_t         err;
+    uint32_t        reserved[DRP_RESERVED_NUM];
+} drp_status_t;
+
+typedef struct iodata_info
+{
+    uint64_t        address;
+    uint32_t        size;
+    uint32_t        pos;
+} iodata_info_st;
+
+typedef struct drp_seq
+{
+    uint32_t        num;
+    uint32_t        order[DRP_SEQ_NUM];
+    uint64_t        address;
+    uint32_t        iodata_num;
+    iodata_info_st  iodata[PARAM_ADDRESS_NUM];
+} drp_seq_t;
+
+typedef struct drp_reg
+{
+    uint32_t        offset;
+    uint32_t        value;
+} drp_reg_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UAPI__DRP_H */
