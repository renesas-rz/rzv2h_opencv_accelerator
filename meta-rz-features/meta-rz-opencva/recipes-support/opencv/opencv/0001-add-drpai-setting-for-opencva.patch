diff -uprN old/modules/core/include/opencv2/core/base.hpp new/modules/core/include/opencv2/core/base.hpp
--- old/modules/core/include/opencv2/core/base.hpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/core/include/opencv2/core/base.hpp	2023-11-07 14:01:15.000000000 +0900
@@ -120,8 +120,9 @@ enum Code {
     OpenCLApiCallError=        -220, //!< OpenCL API call error
     OpenCLDoubleNotSupported=  -221,
     OpenCLInitError=           -222, //!< OpenCL initialization error
-    OpenCLNoAMDBlasFft=        -223
-};
+    OpenCLNoAMDBlasFft=        -223,
+    OpenCVADRPConflict=        -501, //!< OpenCVA DRP conflict error
+    };
 } //Error
 
 //! @} core_utils
@@ -642,9 +643,6 @@ static inline void setUseIPP_NE(bool fla
 
 //! @} core_utils
 
-
-
-
 } // cv
 
 #include "opencv2/core/neon_utils.hpp"
diff -uprN old/modules/core/src/persistence_json.cpp new/modules/core/src/persistence_json.cpp
--- old/modules/core/src/persistence_json.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/core/src/persistence_json.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -296,8 +296,6 @@ public:
 
         while ( is_eof == false && is_completed == false )
         {
-            if (!ptr)
-                CV_PARSE_ERROR_CPP("Invalid input");
             switch ( *ptr )
             {
                 /* comment */
@@ -383,7 +381,6 @@ public:
         if ( is_eof || !is_completed )
         {
             ptr = fs->bufferStart();
-            CV_Assert(ptr);
             *ptr = '\0';
             fs->setEof();
             if( !is_completed )
@@ -395,9 +392,6 @@ public:
 
     char* parseKey( char* ptr, FileNode& collection, FileNode& value_placeholder )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         if( *ptr != '"' )
             CV_PARSE_ERROR_CPP( "Key must start with \'\"\'" );
 
@@ -436,9 +430,6 @@ public:
 
     char* parseValue( char* ptr, FileNode& node )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid value input");
-
         ptr = skipSpaces( ptr );
         if( !ptr || !*ptr )
             CV_PARSE_ERROR_CPP( "Unexpected End-Of-File" );
@@ -578,14 +569,10 @@ public:
                             sz = (int)(ptr - beg);
                             if( sz > 0 )
                             {
-                                if (i + sz >= CV_FS_MAX_LEN)
-                                    CV_PARSE_ERROR_CPP("string is too long");
                                 memcpy(buf + i, beg, sz);
                                 i += sz;
                             }
                             ptr++;
-                            if (i + 1 >= CV_FS_MAX_LEN)
-                                CV_PARSE_ERROR_CPP("string is too long");
                             switch ( *ptr )
                             {
                             case '\\':
@@ -609,8 +596,6 @@ public:
                             sz = (int)(ptr - beg);
                             if( sz > 0 )
                             {
-                                if (i + sz >= CV_FS_MAX_LEN)
-                                    CV_PARSE_ERROR_CPP("string is too long");
                                 memcpy(buf + i, beg, sz);
                                 i += sz;
                             }
@@ -626,8 +611,6 @@ public:
                             sz = (int)(ptr - beg);
                             if( sz > 0 )
                             {
-                                if (i + sz >= CV_FS_MAX_LEN)
-                                    CV_PARSE_ERROR_CPP("string is too long");
                                 memcpy(buf + i, beg, sz);
                                 i += sz;
                             }
@@ -834,9 +817,6 @@ public:
 
     bool parse( char* ptr )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         ptr = skipSpaces( ptr );
         if ( !ptr || !*ptr )
             return false;
diff -uprN old/modules/core/src/persistence_xml.cpp new/modules/core/src/persistence_xml.cpp
--- old/modules/core/src/persistence_xml.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/core/src/persistence_xml.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -360,9 +360,6 @@ public:
 
     char* skipSpaces( char* ptr, int mode )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         int level = 0;
 
         for(;;)
@@ -444,9 +441,6 @@ public:
 
     char* parseValue( char* ptr, FileNode& node )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         FileNode new_elem;
         bool have_space = true;
         int value_type = node.type();
@@ -462,8 +456,6 @@ public:
                 (c == '<' && ptr[1] == '!' && ptr[2] == '-') )
             {
                 ptr = skipSpaces( ptr, 0 );
-                if (!ptr)
-                    CV_PARSE_ERROR_CPP("Invalid input");
                 have_space = true;
                 c = *ptr;
             }
@@ -510,8 +502,6 @@ public:
                 {
                     ptr = fs->parseBase64( ptr, 0, new_elem);
                     ptr = skipSpaces( ptr, 0 );
-                    if (!ptr)
-                        CV_PARSE_ERROR_CPP("Invalid input");
                 }
 
                 ptr = parseTag( ptr, key2, type_name, tag_type );
@@ -627,8 +617,6 @@ public:
                                         c = '\"';
                                     else
                                     {
-                                        if (len + 2 + i >= CV_FS_MAX_LEN)
-                                            CV_PARSE_ERROR_CPP("string is too long");
                                         memcpy( strbuf + i, ptr-1, len + 2 );
                                         i += len + 2;
                                     }
@@ -637,9 +625,9 @@ public:
                                 CV_PERSISTENCE_CHECK_END_OF_BUFFER_BUG_CPP();
                             }
                         }
-                        if (i + 1 >= CV_FS_MAX_LEN)
-                            CV_PARSE_ERROR_CPP("Too long string literal");
                         strbuf[i++] = c;
+                        if( i >= CV_FS_MAX_LEN )
+                            CV_PARSE_ERROR_CPP( "Too long string literal" );
                     }
                     elem->setValue(FileNode::STRING, strbuf, i);
                 }
@@ -657,9 +645,6 @@ public:
     char* parseTag( char* ptr, std::string& tag_name,
                     std::string& type_name, int& tag_type )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid tag input");
-
         if( *ptr == '\0' )
             CV_PARSE_ERROR_CPP( "Unexpected end of the stream" );
 
@@ -717,8 +702,6 @@ public:
                 if( *ptr != '=' )
                 {
                     ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );
-                    if (!ptr)
-                        CV_PARSE_ERROR_CPP("Invalid attribute");
                     if( *ptr != '=' )
                         CV_PARSE_ERROR_CPP( "Attribute name should be followed by \'=\'" );
                 }
@@ -757,8 +740,6 @@ public:
             if( c != '>' )
             {
                 ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );
-                if (!ptr)
-                    CV_PARSE_ERROR_CPP("Invalid input");
                 c = *ptr;
             }
 
@@ -800,8 +781,6 @@ public:
 
         // CV_XML_INSIDE_TAG is used to prohibit leading comments
         ptr = skipSpaces( ptr, CV_XML_INSIDE_TAG );
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
 
         if( memcmp( ptr, "<?xml", 5 ) != 0 )  // FIXIT ptr[1..] - out of bounds read without check
             CV_PARSE_ERROR_CPP( "Valid XML should start with \'<?xml ...?>\'" );
@@ -812,8 +791,6 @@ public:
         while( ptr && *ptr != '\0' )
         {
             ptr = skipSpaces( ptr, 0 );
-            if (!ptr)
-                CV_PARSE_ERROR_CPP("Invalid input");
 
             if( *ptr != '\0' )
             {
diff -uprN old/modules/core/src/persistence_yml.cpp new/modules/core/src/persistence_yml.cpp
--- old/modules/core/src/persistence_yml.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/core/src/persistence_yml.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -330,9 +330,6 @@ public:
 
     char* skipSpaces( char* ptr, int min_indent, int max_comment_indent )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         for(;;)
         {
             while( *ptr == ' ' )
@@ -377,9 +374,6 @@ public:
 
     bool getBase64Row(char* ptr, int indent, char* &beg, char* &end)
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         beg = end = ptr = skipSpaces(ptr, 0, INT_MAX);
         if (!ptr || !*ptr)
             return false; // end of file
@@ -400,9 +394,6 @@ public:
 
     char* parseKey( char* ptr, FileNode& map_node, FileNode& value_placeholder )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         char c;
         char *endptr = ptr - 1, *saveptr;
 
@@ -431,9 +422,6 @@ public:
 
     char* parseValue( char* ptr, FileNode& node, int min_indent, bool is_parent_flow )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         char* endptr = 0;
         char c = ptr[0], d = ptr[1];
         int value_type = FileNode::NONE;
@@ -520,8 +508,6 @@ public:
 
             *endptr = d;
             ptr = skipSpaces( endptr, min_indent, INT_MAX );
-            if (!ptr)
-                CV_PARSE_ERROR_CPP("Invalid input");
 
             c = *ptr;
 
@@ -648,8 +634,6 @@ public:
                 FileNode elem;
 
                 ptr = skipSpaces( ptr, new_min_indent, INT_MAX );
-                if (!ptr)
-                    CV_PARSE_ERROR_CPP("Invalid input");
                 if( *ptr == '}' || *ptr == ']' )
                 {
                     if( *ptr != d )
@@ -663,8 +647,6 @@ public:
                     if( *ptr != ',' )
                         CV_PARSE_ERROR_CPP( "Missing , between the elements" );
                     ptr = skipSpaces( ptr + 1, new_min_indent, INT_MAX );
-                    if (!ptr)
-                        CV_PARSE_ERROR_CPP("Invalid input");
                 }
 
                 if( struct_type == FileNode::MAP )
@@ -764,9 +746,6 @@ public:
 
     bool parse( char* ptr )
     {
-        if (!ptr)
-            CV_PARSE_ERROR_CPP("Invalid input");
-
         bool first = true;
         bool ok = true;
         FileNode root_collection(fs->getFS(), 0, 0);
diff -uprN old/modules/features2d/src/fast.cpp new/modules/features2d/src/fast.cpp
--- old/modules/features2d/src/fast.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/features2d/src/fast.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -50,6 +50,10 @@ The references are:
 
 #include "opencv2/core/openvx/ovx_defs.hpp"
 
+#include "rzv2ma_drp.h"
+#include <unistd.h>
+#include <opencv2/core/utils/logger.hpp>
+
 namespace cv
 {
 
@@ -472,6 +476,155 @@ static inline int hal_FAST(cv::Mat& src,
     return CV_HAL_ERROR_OK;
 }
 
+/* function definition description (to avoid warning in build process)*/
+int FAST_drp(InputArray _img, std::vector<KeyPoint> &keypoints, int threshold, bool nonmax_suppression, FastFeatureDetector::DetectorType type);
+
+/*****************************************
+* Method Name   : drp_FAST
+* Description   : to exec drp process of OpenCV accelerator FAST
+* Arguments     : _img = src image (Mat)
+                    keypoints = detected keypoints (vector)
+                    threshold = threshold
+                    nonmax_suppression (bool)
+                    Detector type (DetectorType)
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int FAST_drp(InputArray _img, std::vector<KeyPoint> &keypoints, int threshold, bool nonmax_suppression, FastFeatureDetector::DetectorType type)
+{
+    CV_LOG_INFO(nullptr, "FAST_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if (NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "FAST_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int fast_possiblef = drp->get_drp_possiblef(PARAM_NO_FAST);
+
+    /* active status only */
+    if (fast_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert to Mat class */
+    Mat src_mat = _img.getMat();
+
+    /* to set src img spec */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t src_depth = src_mat.depth();
+    
+
+    uint16_t const img_min_width = 16;
+    uint16_t const img_min_height = 16;
+    uint16_t const img_max_width = 3840;
+    uint16_t const img_max_height = 2160;
+    uint16_t const max_threshold = 255;
+    uint16_t const min_threshold = 0;
+
+    /* check src image size */
+    if ((src_width < img_min_width) || (img_max_width < src_width) || (src_width % 2 != 0))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    if ((src_height < img_min_height) || (img_max_height < src_height) || (src_height % 2 != 0))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check channel & depth*/
+    if ((src_ch != 1) || (src_depth != CV_8U))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check threshold value */
+    if (((uint16_t)threshold < min_threshold) || (max_threshold < (uint16_t)threshold))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check non-max suppression */
+    if (nonmax_suppression != true)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check detector type */
+    if (type != FastFeatureDetector::TYPE_9_16)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if (drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "FAST_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set FAST parameter */
+    result = drp->setFastParameter(src_width, src_height, src_ch, threshold);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set FAST target image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if (DRP_NORMAL_END != result)
+    {    
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {    
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+  
+    result = drp->readCornerPoints(keypoints);
+    
+
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    CV_LOG_INFO(nullptr, "FAST_drp end.");
+
+    drp->set_drp_end();
+
+    return DRP_NORMAL_END;
+}
+
 void FAST(InputArray _img, std::vector<KeyPoint>& keypoints, int threshold, bool nonmax_suppression, FastFeatureDetector::DetectorType type)
 {
     CV_INSTRUMENT_REGION();
@@ -479,6 +632,16 @@ void FAST(InputArray _img, std::vector<K
     CV_OCL_RUN(_img.isUMat() && type == FastFeatureDetector::TYPE_9_16,
                ocl_FAST(_img, keypoints, threshold, nonmax_suppression, 10000));
 
+    CV_LOG_INFO(nullptr, "FAST method start.");
+
+    /* Call drp process */ 
+    int result = FAST_drp(_img, keypoints, threshold, nonmax_suppression, type);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    /* If could not execute drp process, then to call normal opencv method */    
     cv::Mat img = _img.getMat();
     CALL_HAL(fast_dense, hal_FAST, img, keypoints, threshold, nonmax_suppression, type);
 
diff -uprN old/modules/imgproc/include/drpopencva.h new/modules/imgproc/include/drpopencva.h
--- old/modules/imgproc/include/drpopencva.h	1970-01-01 09:00:00.000000000 +0900
+++ new/modules/imgproc/include/drpopencva.h	2023-11-07 14:01:15.000000000 +0900
@@ -0,0 +1,87 @@
+/* SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note */
+/*
+ * Driver for the Renesas RZ/V2H DRP unit
+ *
+ * Copyright (C) 2021 Renesas Electronics Corporation
+ *
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; version 2 of the License.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef _UAPI__DRP_H
+#define _UAPI__DRP_H
+
+#ifdef __KERNEL__
+#include <linux/types.h>
+#else
+#include <stdint.h>
+#endif
+#include <linux/ioctl.h>
+
+#define DRP_IO_TYPE               (46)
+#define DRP_ASSIGN                _IOW (DRP_IO_TYPE, 0, drp_data_t)
+#define DRP_START                 _IOW (DRP_IO_TYPE, 1, drp_data_t)
+#define DRP_RESET                 _IO  (DRP_IO_TYPE, 2)
+#define DRP_GET_STATUS            _IOR (DRP_IO_TYPE, 3, drp_status_t)
+#define DRP_SET_SEQ               _IOW (DRP_IO_TYPE, 6, drp_seq_t)           /* Since the sturecture size is different,            */
+#define DRP_GET_CODEC_AREA        _IOR (DRP_IO_TYPE, 11, drp_data_t)
+#define DRP_GET_OPENCVA_AREA      _IOR (DRP_IO_TYPE, 12, drp_data_t)
+#define DRP_SET_DRP_FREQ          _IOW (DRP_IO_TYPE, 13, uint32_t)
+
+#define DRP_STATUS_INIT                   (0)
+#define DRP_STATUS_IDLE                   (1)
+#define DRP_STATUS_RUN                    (2)
+#define DRP_ERRINFO_SUCCESS               (0)
+#define DRP_ERRINFO_DRP_ERR               (-1)
+#define DRP_ERRINFO_RESET                 (-3)
+#define DRP_RESERVED_NUM                  (10)
+#define DRP_SEQ_NUM                       (20)
+#define DRP_EXE_DRP_40BIT                 (3)
+#define DRP_OPMASK_FORCE_LOAD             (0x8000)
+#define PARAM_ADDRESS_NUM                 (120)
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef struct drp_data
+{
+    uint64_t        address;
+    uint32_t        size;
+} drp_data_t;
+
+typedef struct drp_status
+{
+    uint32_t        status;
+    int32_t         err;
+    uint32_t        reserved[DRP_RESERVED_NUM];
+} drp_status_t;
+
+typedef struct iodata_info
+{
+    uint64_t        address;
+    uint32_t        size;
+    uint32_t        pos;
+} iodata_info_st;
+
+typedef struct drp_seq
+{
+    uint32_t        num;
+    uint32_t        order[DRP_SEQ_NUM];
+    uint64_t        address;
+    uint32_t        iodata_num;
+    iodata_info_st  iodata[PARAM_ADDRESS_NUM];
+} drp_seq_t;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _UAPI__DRP_H */
diff -uprN old/modules/imgproc/include/opencv2/imgproc.hpp new/modules/imgproc/include/opencv2/imgproc.hpp
--- old/modules/imgproc/include/opencv2/imgproc.hpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/include/opencv2/imgproc.hpp	2023-11-07 14:01:15.000000000 +0900
@@ -671,8 +671,8 @@ enum ColorConversionCodes {
     //! YUV 4:2:2 family to RGB
     COLOR_YUV2RGB_UYVY = 107,
     COLOR_YUV2BGR_UYVY = 108,
-    //COLOR_YUV2RGB_VYUY = 109,
-    //COLOR_YUV2BGR_VYUY = 110,
+    COLOR_YUV2RGB_VYUY = 109,
+    COLOR_YUV2BGR_VYUY = 110,
     COLOR_YUV2RGB_Y422 = COLOR_YUV2RGB_UYVY,
     COLOR_YUV2BGR_Y422 = COLOR_YUV2BGR_UYVY,
     COLOR_YUV2RGB_UYNV = COLOR_YUV2RGB_UYVY,
@@ -680,8 +680,8 @@ enum ColorConversionCodes {
 
     COLOR_YUV2RGBA_UYVY = 111,
     COLOR_YUV2BGRA_UYVY = 112,
-    //COLOR_YUV2RGBA_VYUY = 113,
-    //COLOR_YUV2BGRA_VYUY = 114,
+    COLOR_YUV2RGBA_VYUY = 113,
+    COLOR_YUV2BGRA_VYUY = 114,
     COLOR_YUV2RGBA_Y422 = COLOR_YUV2RGBA_UYVY,
     COLOR_YUV2BGRA_Y422 = COLOR_YUV2BGRA_UYVY,
     COLOR_YUV2RGBA_UYNV = COLOR_YUV2RGBA_UYVY,
@@ -707,7 +707,6 @@ enum ColorConversionCodes {
 
     COLOR_YUV2GRAY_UYVY = 123,
     COLOR_YUV2GRAY_YUY2 = 124,
-    //CV_YUV2GRAY_VYUY    = CV_YUV2GRAY_UYVY,
     COLOR_YUV2GRAY_Y422 = COLOR_YUV2GRAY_UYVY,
     COLOR_YUV2GRAY_UYNV = COLOR_YUV2GRAY_UYVY,
     COLOR_YUV2GRAY_YVYU = COLOR_YUV2GRAY_YUY2,
@@ -782,7 +781,17 @@ enum ColorConversionCodes {
     COLOR_BayerRG2RGBA = COLOR_BayerBG2BGRA,
     COLOR_BayerGR2RGBA = COLOR_BayerGB2BGRA,
 
-    COLOR_COLORCVT_MAX  = 143
+    COLOR_COLORCVT_MAX  = 143,
+
+    /* opencva drp yuv -> nv */
+    COLOR_YUV_NV12_YUY2 = 0x10000,
+    COLOR_YUV_NV12_YVYU = 0x10001,
+    COLOR_YUV_NV12_UYVY = 0x10002,
+    COLOR_YUV_NV12_VYUY = 0x10003,
+    COLOR_YUV_NV21_YUY2 = 0x10004,
+    COLOR_YUV_NV21_YVYU = 0x10005,
+    COLOR_YUV_NV21_UYVY = 0x10006,
+    COLOR_YUV_NV21_VYUY = 0x10007
 };
 
 //! @addtogroup imgproc_shape
@@ -1452,6 +1461,8 @@ CV_EXPORTS_W void GaussianBlur( InputArr
                                 double sigmaX, double sigmaY = 0,
                                 int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int GaussianBlur_drp(Mat src_mat, Mat dst_mat, Size ksize, double sigma1, double sigma2, int borderType);
+
 /** @brief Applies the bilateral filter to an image.
 
 The function applies bilateral filtering to the input image, as described in
@@ -1592,6 +1603,10 @@ CV_EXPORTS_W void filter2D( InputArray s
                             InputArray kernel, Point anchor = Point(-1,-1),
                             double delta = 0, int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int filter2D_drp(InputArray _src, OutputArray _dst, int ddepth,
+              InputArray _kernel, Point anchor0,
+              double delta, int borderType);
+
 /** @brief Applies a separable linear filter to an image.
 
 The function applies a separable linear filter to the image. That is, first, every row of src is
@@ -1667,6 +1682,11 @@ CV_EXPORTS_W void Sobel( InputArray src,
                          double scale = 1, double delta = 0,
                          int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int Sobel_drp( InputArray src, OutputArray dst, int ddepth,
+                         int dx, int dy, int ksize = 3,
+                         double scale = 1, double delta = 0,
+                         int borderType = BORDER_DEFAULT );
+                         
 /** @brief Calculates the first order image derivative in both x and y using a Sobel operator
 
 Equivalent to calling:
@@ -2266,6 +2286,9 @@ CV_EXPORTS_W void resize( InputArray src
                           Size dsize, double fx = 0, double fy = 0,
                           int interpolation = INTER_LINEAR );
 
+CV_EXPORTS_W int resize_drp(InputArray _src, OutputArray _dst, Size dsize, double inv_scale_x, 
+                          double inv_scale_y, int interpolation);
+
 /** @brief Applies an affine transformation to an image.
 
 The function warpAffine transforms the source image using the specified matrix:
@@ -2296,6 +2319,12 @@ CV_EXPORTS_W void warpAffine( InputArray
                               int borderMode = BORDER_CONSTANT,
                               const Scalar& borderValue = Scalar());
 
+CV_EXPORTS_W int warpAffine_drp(InputArray src, OutputArray dst,
+                              InputArray M, Size dsize,
+                              int flags = INTER_LINEAR,
+                              int borderMode = BORDER_CONSTANT,
+                              const Scalar& borderValue = Scalar());
+
 /** @example samples/cpp/warpPerspective_demo.cpp
 An example program shows using cv::findHomography and cv::warpPerspective for image warping
 */
@@ -2328,6 +2357,12 @@ CV_EXPORTS_W void warpPerspective( Input
                                    int borderMode = BORDER_CONSTANT,
                                    const Scalar& borderValue = Scalar());
 
+CV_EXPORTS_W int warpPerspective_drp( InputArray src, OutputArray dst,
+                                   InputArray M, Size dsize,
+                                   int flags = INTER_LINEAR,
+                                   int borderMode = BORDER_CONSTANT,
+                                   const Scalar& borderValue = Scalar());                                   
+
 /** @brief Applies a generic geometrical transformation to an image.
 
 The function remap transforms the source image using the specified map:
@@ -2927,6 +2962,10 @@ CV_EXPORTS_W void adaptiveThreshold( Inp
                                      double maxValue, int adaptiveMethod,
                                      int thresholdType, int blockSize, double C );
 
+ CV_EXPORTS_W int adaptiveThreshold_drp( InputArray src, OutputArray dst,
+                                     double maxValue, int adaptiveMethod,
+                                     int thresholdType, int blockSize, double C );                                    
+
 //! @} imgproc_misc
 
 //! @addtogroup imgproc_filter
@@ -2958,6 +2997,9 @@ Then, it downsamples the image by reject
 CV_EXPORTS_W void pyrDown( InputArray src, OutputArray dst,
                            const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int pyrDown_drp( InputArray src, OutputArray dst,
+                           const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );
+
 /** @brief Upsamples an image and then blurs it.
 
 By default, size of the output image is computed as `Size(src.cols\*2, (src.rows\*2)`, but in any
@@ -2978,6 +3020,9 @@ pyrDown multiplied by 4.
 CV_EXPORTS_W void pyrUp( InputArray src, OutputArray dst,
                          const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );
 
+CV_EXPORTS_W int pyrUp_drp( InputArray src, OutputArray dst,
+                         const Size& dstsize = Size(), int borderType = BORDER_DEFAULT );
+
 /** @brief Constructs the Gaussian pyramid for an image.
 
 The function constructs a vector of images and builds the Gaussian pyramid by recursively applying
@@ -3678,6 +3723,10 @@ CV_EXPORTS_W void matchTemplate( InputAr
 
 //! @}
 
+CV_EXPORTS_W int matchTemplate_drp( InputArray image, InputArray templ,
+                                 OutputArray result, int method, InputArray mask = noArray() );
+
+
 //! @addtogroup imgproc_shape
 //! @{
 
@@ -4755,4 +4804,10 @@ Point LineIterator::pos() const
 
 } // cv
 
+/* opencva activate api */
+CV_EXPORTS_W int OCA_Activate(unsigned long* OCA_list);
+
+/* opencva conflict action setting api */
+CV_EXPORTS_W void OCA_ConflictNotification(int oca_conflict);
+
 #endif
diff -uprN old/modules/imgproc/include/rzv2ma_drp.h new/modules/imgproc/include/rzv2ma_drp.h
--- old/modules/imgproc/include/rzv2ma_drp.h	1970-01-01 09:00:00.000000000 +0900
+++ new/modules/imgproc/include/rzv2ma_drp.h	2024-01-24 20:50:59.000000000 +0900
@@ -0,0 +1,278 @@
+/***********************************************************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
+* other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
+* applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
+* EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
+* SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
+* SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
+* this software. By using this software, you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+*
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : rzv2m_drp.h
+* Version      : 1.00
+* Description  : Call RZ/V2M From OpenCV Accelerator
+***********************************************************************************************************************/
+#ifndef RZV2M_DRP_DEFINE_MACRO_H
+#define RZV2M_DRP_DEFINE_MACRO_H
+
+/* include file */
+#include <drpopencva.h>
+#include <opencv2/core/types.hpp>
+
+/* definition of compile switch flag for rzv2h */
+#define DEV_RZV2H
+
+/* device file names */
+#define DRV_DEV_NAME "/dev/opencva0"
+
+/* device file names */
+/* compile switch */
+#ifdef DEV_RZV2H
+#define DRP_DEV_NAME "/dev/drp1"
+#else
+#define DRP_DEV_NAME "/dev/drp0"
+#endif
+
+/* signature name */
+/* compile switch */
+#ifdef DEV_RZV2H
+#define OCABIN_SIGNATURE "RENESAS OCA V2H"
+#define OCABIN_MAJOR_VER "VER1"
+#else
+#define OCABIN_SIGNATURE "RENESAS OPENCVA"
+#define OCABIN_MAJOR_VER ""
+#endif
+
+/* const values for drp driver */
+#define DRPPARAM1           (1)
+#define DRPCFG_NUM          (1)
+#define DRPCFG1             (0)
+#define PARAM_NO_RESIZE     (0)         // resize circuit no
+#define PARAM_NO_YUV2RGB    (2)         // YUV2RGB circuit no
+#define PARAM_NO_YUV2NV     (3)         // YUV2NV circuit no
+#define PARAM_SIZE_RESIZE   (56)        // param size of resize
+#define PARAM_SIZE_YUV2RGB  (56)        // param size of YUV2RGB
+#define PARAM_SIZE_YUV2NV   (56)        // param size of YUV2RGB
+#define DRP_PARAM_SIZE      (256)       // max size of drp parameter
+
+#define DRP_CIRCUIT_CNT_MAX (1024)      // max circuit count
+#define DRP_EXEC_TIMEOUT_SECONDS (10)   // timeout for drp exec
+
+/* return vallues */
+const static int DRP_NOT_EXECUTE = 1;
+const static int DRP_NORMAL_END = 0;
+const static int DRP_PARAM_ERROR = -1;
+const static int DRP_SRC_IMAGE_ERROR = -2;
+const static int DRP_DST_IMAGE_ERROR = -3;
+const static int DRP_EXEC_ERROR = -4;
+const static int DRP_CONFLICT_ERROR = -5;
+
+/* OCA constant */
+#define OCA_BIN_SIZE          (3686400)   // opencva binary area(400*1024*9 Byte) 
+#define PARAM_NO_YUV2NV12     (3)         // circuit No of YUV to NV12
+#define PARAM_SIZE_YUV2NV12   (56)        // param size of YUV to NV12
+
+#define PARAM_NO_GAUSSIAN     (4)         // circuit No of gaussian
+#define PARAM_SIZE_GAUSSIAN   (56)        // param size of gaussian
+
+#define PARAM_NO_MORPH_DILATE (5)         // circuit No of Morphology dilate
+#define PARAM_NO_MORPH_ERODE  (6)         // circuit No of Morphology erode
+
+#define PARAM_NO_FILTER2D     (7)         // circuit No of Filter2d
+#define PARAM_SIZE_FILTER2D  (88)         // param size of filter2d
+
+#define PARAM_SIZE_MORPHOLOGY (56)        // param size of Morphology
+
+#define PARAM_NO_ATHRESHOLD (9)           // circuit No of AThreshold
+#define PARAM_SIZE_ATHRESHOLD (56)        // param size of AThreshold
+
+#define PARAM_NO_SOBEL (8)                // circuit No of Sobel
+#define PARAM_SIZE_SOBEL (56)             // param size of Sobel
+
+#define PARAM_NO_MATCHTEMPLATE (10)       // circuit No of MatchTemplate
+#define PARAM_SIZE_MATCHTEMPLATE (64)     // param size of MatchTemplate
+
+#define PARAM_NO_WARPAFFINE (11)       // circuit No of warpAffine
+#define PARAM_SIZE_WARPAFFINE (76)     // param size of warpAffine
+
+#define PARAM_NO_PYRDOWN (12)          // circuit No of pyrdown
+#define PARAM_SIZE_PYRDOWN (48)        // param size of pyrDown
+
+#define PARAM_NO_PYRUP (13)          // circuit No of pyrup
+#define PARAM_SIZE_PYRUP (48)        // param size of pyrup
+
+#define PARAM_NO_WARPPERSPECTIVE (14)    // circuit No of warpPerspective
+#define PARAM_SIZE_WARPPERSPECTIVE (88)  // param size of warpPerspective
+
+#define PARAM_NO_FAST (15)   // circuit No of fast
+#define PARAM_SIZE_FAST (56) // param size of fast
+
+/* OCA Circuit activate*/
+/* input param */
+#define CIRCUIT_INPARAM_INACTIVATE (0)
+#define CIRCUIT_INPARAM_ACTIVATE (1)
+
+/* possible flag status */
+#define CIRCUIT_POSSIBLEF_NOT_EXIST (0)
+#define CIRCUIT_POSSIBLEF_ACTIVE (1)
+#define CIRCUIT_POSSIBLEF_INACTIVE (2)
+
+/* drp in process set or reset */
+#define IO_CTL_DRP_START (3)
+#define IO_CTL_DRP_END (4)
+#define IO_CTL_DRP_CONFLICT (-1)
+#define IO_CTL_DRP_CONFLICT_ERR (-2)
+
+/* Unit size of read buffer in FAST */
+#define FAST_READ_BUFFER_SIZE (1000) 
+
+enum DRP_PROCESS_STATUS { 
+    READY,
+    INITIALIZE,
+    READ_HEADER, 
+    SET_PARAMETER,
+    READ_SRC_IMAGE,
+    EXEC_DRP,
+    READ_DST_IMAGE
+};
+
+struct drp_proces_thread_id {
+    uint32_t process_id;
+    uint32_t thread_id;
+};
+
+/*****************************************
+* Class Name   : rzv2m_drp
+* Description  : DRP OpenCV Accelerator class define
+******************************************/
+class rzv2m_drp
+{
+public:
+    rzv2m_drp();
+    ~rzv2m_drp();
+
+    static rzv2m_drp* get_instance();
+    
+    static rzv2m_drp* get_instance_forapi();
+
+    static enum DRP_PROCESS_STATUS process_status;
+
+    static int drp_conflict_exception;
+
+    int readBinaryHeader(void);
+
+    int setResizeParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, uint16_t dst_ch);
+
+    int setYUV2RGBParameter(uint16_t src_width, uint16_t src_height, uint32_t input_size, uint16_t input_format,
+                uint16_t dst_width, uint16_t dst_height, uint16_t output_format);
+	
+    int setYUV2NVParameter(uint16_t src_width, uint16_t src_height, uint16_t input_yuv, uint16_t output_nv);
+	
+    int setGaussianParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t kernel_size);
+
+    int setMorphologyParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t iterators,
+                uint16_t border_type, uint16_t border_value, uint16_t morph_circuit_no);
+
+    int setFilter2dParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, float* filter);
+
+    int setAdaptiveThreshold(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t max_value, 
+                uint16_t threshold_type, uint32_t block_size, uint16_t threshold_C);
+
+    int setSobelParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t delataXY);
+
+    int setMatchTemplateParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+            uint16_t tmpl_width, uint16_t tmpl_height, uint16_t tmpl_ch, uint16_t method);
+
+    int setWarpAffineParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, float* transform_matrix, uint32_t border_value);
+ 
+    int setPyrDownParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dsize_width, uint16_t dsize_height);
+
+    int setPyrUpParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dsize_width, uint16_t dsize_height);
+
+    int setWarpPerspectiveParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, float* transform_matrix, uint32_t border_value);
+
+    int setFastParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t threshold);
+
+    int setSrcImage(uint8_t *srcImgData);
+
+    int setMatchTempl(uint8_t *templData);
+
+    int execDRP(void);
+
+    int readDstImage(uint8_t *dstImgData);
+
+    int readCornerPoints(std::vector<cv::KeyPoint> &keypoints);
+    int readTemplateMatchResult(uint8_t *dstImgData);
+
+    int get_drp_possiblef(uint16_t circuit_no);
+
+    int OCA_Activate(unsigned long* OCA_list);
+
+    void OCA_ConflictNotification(int oca_conflict);
+
+    void conflict_action_exec(void);
+
+    int set_drp_start();
+
+    int set_drp_end();
+
+private:
+    void dst_adr_64aligment(void);
+
+    void tmpl_adr_64aligment(void);
+
+    uint64_t opencv_bin_addr64_phy;     // physical memory area address (64bit)
+    
+    uint8_t opencv_bin_p[OCA_BIN_SIZE];      // opencva binary area(3.6M Byte = 400*1024*9 Byte)
+
+    bool initialized = false;           
+
+    void initialize(void);
+
+    static rzv2m_drp* _singleton;       // singleton object of drp
+
+private:
+    int fd_drp;
+    int fd_drv;
+
+    char *opencv_bin_signature_p = NULL;    // pointer to signature(16byte)
+    char *opencv_bin_version_p = NULL;      // pointer to version info(8byte)
+    uint32_t opencv_bin_list_base;          // opencva list address(offset value)
+    uint32_t opencv_bin_config_base;        // opencva circuit info address(offset value)
+    uint32_t opencv_bin_descriptor_base;    // opencva descriptor info address(offset value)
+    uint32_t opencv_bin_param_base;         // opencva parameter info address(offset value)
+
+    uint32_t possiblef;                 // existence flag of circuit data 
+    uint32_t drp_position;              // address at circuit data (offset value from CONFIG_BASE)
+    uint32_t drp_size;                  // circuit data size
+
+    uint64_t src_adr;   // physical address of src
+    uint64_t dst_adr;   // physical address of dst
+    uint64_t tmpl_adr;  // physical address of match template
+    uint64_t corner_adr;// physical address of detected corners
+
+    uint32_t src_size;
+    uint32_t dst_size;
+    uint32_t tmpl_size;
+    
+    drp_data_t proc[DRP_SEQ_NUM * 2];
+
+    uint32_t process_id = 0;
+    uint32_t thread_id = 0;
+};
+
+#endif
diff -uprN old/modules/imgproc/src/color.cpp new/modules/imgproc/src/color.cpp
--- old/modules/imgproc/src/color.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/color.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -6,6 +6,8 @@
 #include "opencl_kernels_imgproc.hpp"
 #include "color.hpp"
 
+#include <rzv2ma_drp.h>
+
 namespace cv
 {
 
@@ -151,7 +153,6 @@ static bool ocl_cvtColor( InputArray _sr
 
 #endif
 
-
 // helper function for dual-plane modes
 
 void cvtColorTwoPlane( InputArray _ysrc, InputArray _uvsrc, OutputArray _dst, int code )
@@ -167,10 +168,19 @@ void cvtColorTwoPlane( InputArray _ysrc,
             return;
     }
 
+    _dst.create( _ysrc.rows(), _ysrc.cols(), CV_8UC3 );
+
+    int return_drp = 0;
+    return_drp = cvtColorTwoPlane_drp(_ysrc, _uvsrc, _dst, code);
+
+    if(DRP_NOT_EXECUTE != return_drp)
+    {
+        return;
+    }
+    
     cvtColorTwoPlaneYUV2BGRpair(_ysrc, _uvsrc, _dst, dstChannels(code), swapBlue(code), uIndex(code));
 }
 
-
 //////////////////////////////////////////////////////////////////////////////////////////
 //                                   The main function                                  //
 //////////////////////////////////////////////////////////////////////////////////////////
@@ -188,6 +198,9 @@ void cvtColor( InputArray _src, OutputAr
                 !(CV_MAT_DEPTH(_src.type()) == CV_8U && (code == COLOR_Luv2BGR || code == COLOR_Luv2RGB)),
                 ocl_cvtColor(_src, _dst, code, dcn) )
 
+    Mat mat_src = _src.getMat();
+    Mat mat_dst = _dst.getMat();
+
     switch( code )
     {
         case COLOR_BGR2BGRA: case COLOR_RGB2BGRA: case COLOR_BGRA2BGR:
@@ -307,7 +320,7 @@ void cvtColor( InputArray _src, OutputAr
         case COLOR_YUV2BGRA_NV21: case COLOR_YUV2RGBA_NV21: case COLOR_YUV2BGRA_NV12: case COLOR_YUV2RGBA_NV12:
             // http://www.fourcc.org/yuv.php#NV21 == yuv420sp -> a plane of 8 bit Y samples followed by an interleaved V/U plane containing 8 bit 2x2 subsampled chroma samples
             // http://www.fourcc.org/yuv.php#NV12 -> a plane of 8 bit Y samples followed by an interleaved U/V plane containing 8 bit 2x2 subsampled colour difference samples
-            cvtColorTwoPlaneYUV2BGR(_src, _dst, dcn, swapBlue(code), uIndex(code));
+            cvtColorTwoPlaneYUV2BGR(_src, _dst, dcn, swapBlue(code), uIndex(code), code);
             break;
 
         case COLOR_YUV2BGR_YV12: case COLOR_YUV2RGB_YV12: case COLOR_YUV2BGRA_YV12: case COLOR_YUV2RGBA_YV12:
@@ -335,7 +348,7 @@ void cvtColor( InputArray _src, OutputAr
             {
                 int ycn  = (code==COLOR_YUV2RGB_UYVY || code==COLOR_YUV2BGR_UYVY ||
                             code==COLOR_YUV2RGBA_UYVY || code==COLOR_YUV2BGRA_UYVY) ? 1 : 0;
-                cvtColorOnePlaneYUV2BGR(_src, _dst, dcn, swapBlue(code), uIndex(code), ycn);
+                cvtColorOnePlaneYUV2BGR(_src, _dst, dcn, swapBlue(code), uIndex(code), ycn, code);
                 break;
             }
 
@@ -351,8 +364,58 @@ void cvtColor( InputArray _src, OutputAr
         case COLOR_mRGBA2RGBA:
             cvtColormRGBA2RGBA(_src, _dst);
             break;
-        default:
-            CV_Error( CV_StsBadFlag, "Unknown/unsupported color conversion code" );
+
+        /* drp opencva */
+        case COLOR_YUV_NV12_YUY2:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 0, 0);
+            break;
+
+        case COLOR_YUV_NV12_YVYU:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 1, 0);
+            break;
+
+        case COLOR_YUV_NV12_UYVY:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 2, 0);
+            break;
+
+        case COLOR_YUV_NV12_VYUY:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 3, 0);
+            break;
+
+        case COLOR_YUV_NV21_YUY2:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 0, 1);
+            break;
+
+        case COLOR_YUV_NV21_YVYU:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 1, 1);
+            break;
+
+        case COLOR_YUV_NV21_UYVY:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 2, 1);
+            break;
+
+        case COLOR_YUV_NV21_VYUY:
+            _dst.create( _src.rows() * 3 / 2, _src.cols(), CV_8UC1 );
+            mat_dst = _dst.getMat();
+            cvtYUVtoNV_drp(mat_src, mat_dst, 3, 1);
+            break;
+
+    default:
+        CV_Error( CV_StsBadFlag, "Unknown/unsupported color conversion code" );
     }
 }
 } //namespace cv
diff -uprN old/modules/imgproc/src/color.hpp new/modules/imgproc/src/color.hpp
--- old/modules/imgproc/src/color.hpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/color.hpp	2023-11-07 14:01:15.000000000 +0900
@@ -528,12 +528,12 @@ void cvtColorLab2BGR( InputArray _src, O
 void cvtColorLuv2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, bool srgb );
 void cvtColorBGR2XYZ( InputArray _src, OutputArray _dst, bool swapb );
 void cvtColorXYZ2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb );
-
 void cvtColorBGR2YUV( InputArray _src, OutputArray _dst, bool swapb, bool crcb);
 void cvtColorYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, bool crcb);
 
-void cvtColorOnePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int ycn);
-void cvtColorTwoPlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx );
+void cvtColorOnePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int ycn, int color_code);
+void cvtColorTwoPlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int color_code);
+
 void cvtColorTwoPlaneYUV2BGRpair( InputArray _ysrc, InputArray _uvsrc, OutputArray _dst, int dcn, bool swapb, int uidx );
 void cvtColorThreePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx );
 void cvtColorBGR2ThreePlaneYUV( InputArray _src, OutputArray _dst, bool swapb, int uidx);
@@ -555,4 +555,8 @@ void cvtColorGray25x5( InputArray _src,
 void cvtColorRGBA2mRGBA(InputArray _src, OutputArray _dst);
 void cvtColormRGBA2RGBA(InputArray _src, OutputArray _dst);
 
+int cvtYUVtoNV_drp(Mat src_mat, Mat dst_mat, int input_yuv, int output_nv);	
+int cvtYUVtoBGR_drp(Mat src_mat, Mat dst_mat, int width, int height, int color_code);
+int cvtColorTwoPlane_drp(InputArray _ysrc, InputArray _uvsrc, OutputArray _dst, int color_code);
+
 } //namespace cv
diff -uprN old/modules/imgproc/src/color_rgb.dispatch.cpp new/modules/imgproc/src/color_rgb.dispatch.cpp
--- old/modules/imgproc/src/color_rgb.dispatch.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/color_rgb.dispatch.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -13,7 +13,6 @@
 #define IPP_DISABLE_CVTCOLOR_GRAY2BGR_8UC3 1
 
 namespace cv {
-
 //
 // IPP functions
 //
diff -uprN old/modules/imgproc/src/color_yuv.dispatch.cpp new/modules/imgproc/src/color_yuv.dispatch.cpp
--- old/modules/imgproc/src/color_yuv.dispatch.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/color_yuv.dispatch.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -4,14 +4,600 @@
 
 #include "precomp.hpp"
 #include "opencl_kernels_imgproc.hpp"
-
 #include "color.hpp"
-
 #include "color_yuv.simd.hpp"
 #include "color_yuv.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
+#include <iostream>
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
+
 namespace cv {
 
+/***********************************************************
+* Method Name   : cvtYUVtoNV_drp
+* Description   : to execute cvtYUVtoNV drp version
+* Arguments     : src_mat = input Mat object, dst_mat = output Mat object 
+*               : input_yuv = input yuv type, output_nv = output nv type 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int cvtYUVtoNV_drp(Mat src_mat, Mat dst_mat, int input_yuv, int output_nv)
+{
+    CV_LOG_INFO(nullptr, "cvtYUVtoNV_drp method start.");
+
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_YUV2NV);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    uint16_t dst_width = src_mat.cols;
+    uint16_t dst_height = src_mat.rows;
+   
+    /* dst image area */
+    uint8_t *out_image_buffer;
+
+    out_image_buffer = new uint8_t[dst_width * dst_height * 3 / 2];
+
+    int result = DRP_NORMAL_END;
+
+    /* Check src size */
+    if(3840 < src_mat.cols)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(2160 < src_mat.rows)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking input length even */
+    if(0 != src_mat.cols % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src_mat.rows % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* dst image size limit 4k */
+    if(3840*2160 < src_mat.cols*src_mat.rows)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(2 != src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setYUV2NVParameter(src_mat.cols, src_mat.rows, input_yuv, output_nv);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    result = drp->setSrcImage(src_mat.data);
+
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[dst_width * dst_height * 3 / 2];
+
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out =  Mat(dst_height * 3 / 2, dst_width, CV_8UC1, out_image_buffer);    
+    dst_mat_out.copyTo(dst_mat);
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "cvtYUVtoNV_drp method end.");
+
+    return DRP_NORMAL_END;   
+}
+
+/***********************************************************
+* Method Name   : cvtYUVtoBGR_drp
+* Description   : to exec cvtYUVtoBGR drp version
+* Arguments     : src_mat = input Mat object, dst_mat = output Mat object 
+*               : width = input width, height = input height, color_code = color convert type 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int cvtYUVtoBGR_drp(Mat src_mat, Mat dst_mat, int width, int height, int color_code)
+{
+    CV_LOG_INFO(nullptr, "cvtYUVtoBGR_drp method start.");
+
+    /* can exec drp by color_code */
+    switch(color_code)
+    {
+        case COLOR_YUV2RGBA_UYVY: case COLOR_YUV2BGRA_UYVY:
+        case COLOR_YUV2RGBA_YUY2: case COLOR_YUV2BGRA_YUY2: case COLOR_YUV2RGBA_YVYU: case COLOR_YUV2BGRA_YVYU:
+
+        case COLOR_YUV2BGRA_NV21: case COLOR_YUV2RGBA_NV21: case COLOR_YUV2BGRA_NV12: case COLOR_YUV2RGBA_NV12:
+        
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_YUV2RGB);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* continue to exec drp function */
+
+    /* dst image area */
+    uint8_t *out_image_buffer;
+
+    /* checking input length */
+    if(4 > width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(3840 < width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(6 > height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(2160 < height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src_mat.cols % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src_mat.rows % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(2 != src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* size of dst image */
+    uint16_t dst_width = width;
+    uint16_t dst_height = height;
+    uint32_t input_size = dst_width * dst_height * 2;
+    int output_size = dst_width * dst_height * 3;
+
+    int result = DRP_NORMAL_END;
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* can exec drp by color_code */
+    int output_format_rgb = 0;
+    int input_format = 0x00;
+
+    switch(color_code)
+    {
+        case COLOR_YUV2RGB_YUY2:
+            input_format = 0;
+            break;
+
+        case COLOR_YUV2RGB_YVYU:
+            input_format = 1;
+            break;
+
+        case COLOR_YUV2RGB_UYVY:
+            input_format = 2;
+            break;
+
+        case COLOR_YUV2RGB_VYUY:
+            input_format = 3;
+            break;
+        
+        case COLOR_YUV2BGR_YUY2:
+            input_format = 0;
+            output_format_rgb = 1;
+            break;
+
+        case COLOR_YUV2BGR_YVYU:
+            input_format = 1;
+            output_format_rgb = 1;
+            break;
+
+        case COLOR_YUV2BGR_UYVY:
+            input_format = 2;
+            output_format_rgb = 1;
+            break;
+
+        case COLOR_YUV2BGR_VYUY:
+            input_format = 3;
+            output_format_rgb = 1;
+            break;
+
+        case COLOR_YUV2RGB_NV21:
+            input_format = 0x1005;
+            input_size = dst_width * dst_height * 3 / 2; 
+            output_size = dst_width * dst_height * 3;
+            output_format_rgb = 0;
+            break;
+
+        case COLOR_YUV2BGR_NV21:
+            input_format = 0x1005;
+            input_size = dst_width * dst_height * 3 / 2; 
+            output_size = dst_width * dst_height * 3;
+            output_format_rgb = 1;
+            break;
+        
+        case COLOR_YUV2RGB_NV12:
+            input_format = 0x1004;
+            input_size = dst_width * dst_height * 3 / 2; 
+            output_size = dst_width * dst_height * 3;
+            output_format_rgb = 0;
+            break;
+          
+        case COLOR_YUV2BGR_NV12:
+            input_format = 0x1004;
+            input_size = dst_width * dst_height * 3 / 2; 
+            output_size = dst_width * dst_height * 3;
+            output_format_rgb = 1;
+            break;  
+    }
+
+    result = drp->setYUV2RGBParameter(width, height, input_size, input_format, dst_width, dst_height, output_format_rgb);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[output_size];
+
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_8UC3, out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    CV_LOG_INFO(nullptr, "cvtYUVtoBGR_drp method end.");
+
+    drp->set_drp_end();
+
+    return DRP_NORMAL_END;
+}
+
+/***********************************************************
+* Method Name   : cvtColorTwoPlane_drp
+* Description   : to execute cvtColorTwoPlane_drp
+* Arguments     : _ysrc = input y data, _uvsrc = input uv data
+*               : _dst = output Mat, color_code = color convert type 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int cvtColorTwoPlane_drp(InputArray _ysrc, InputArray _uvsrc, OutputArray _dst, int color_code)
+{
+    /* can exec drp by color_code */
+    switch(color_code)
+    {
+        case COLOR_YUV2BGRA_NV21: case COLOR_YUV2RGBA_NV21: case COLOR_YUV2BGRA_NV12: case COLOR_YUV2RGBA_NV12:
+
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_YUV2RGB);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    CV_LOG_INFO(nullptr, "cvtColorTwoPlane_drp method start.");
+
+    Mat ysrc = _ysrc.getMat();
+    Mat uvsrc = _uvsrc.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    uint16_t src1_width = ysrc.cols;
+    uint16_t src1_height = ysrc.rows;
+    uint16_t src2_width = uvsrc.cols;
+    uint16_t src2_height = uvsrc.rows;
+    uint16_t dst_width = src1_width;
+    uint16_t dst_height = src1_height;
+
+    uint8_t *input_image_buffer;
+    uint8_t *out_image_buffer; 
+    uint32_t input_size = 0;
+    uint32_t output_size = 0;
+    
+    input_size = src1_width * src1_height;
+    input_size += src1_width * src1_height / 2;
+    
+    input_image_buffer = new uint8_t[input_size];
+
+    /* checking input length */
+    if(4 > src1_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(3840 < src1_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(6 > src1_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(2160 < src1_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src1_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(0 != src1_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != ysrc.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 != ysrc.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking input length */
+    if(src1_width / 2 != src2_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(src1_height / 2 != src2_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(2 != uvsrc.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != ysrc.depth() || CV_8U != uvsrc.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* check continuous */
+    if(!ysrc.isContinuous())
+    {
+        ysrc = ysrc.clone();
+    }
+    if(!uvsrc.isContinuous())
+    {
+        uvsrc = uvsrc.clone();
+    }
+    
+    memcpy(input_image_buffer, ysrc.data, src1_width * src1_height);    
+    memcpy(input_image_buffer + (src1_width * src1_height), uvsrc.data, src1_width * src1_height / 2);
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* can exec drp by color_code */
+    int output_format_rgb = 0;
+    int input_format = 0x00;
+
+    output_size = dst_width * dst_height * 3;
+
+    switch(color_code)
+    {
+        case COLOR_YUV2RGB_NV21:
+            input_format = 0x1005;
+            output_format_rgb = 0;
+            break;
+
+        case COLOR_YUV2BGR_NV21:
+            input_format = 0x1005;
+            output_format_rgb = 1;
+            break;
+        
+        case COLOR_YUV2RGB_NV12:
+            input_format = 0x1004;
+            output_format_rgb = 0;
+            break;
+
+        case COLOR_YUV2BGR_NV12:
+            input_format = 0x1004;
+            output_format_rgb = 1;
+            break;
+    }
+
+    result = drp->setYUV2RGBParameter(src1_width, src1_height, input_size, input_format, dst_width, dst_height, output_format_rgb);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    result = drp->setSrcImage(input_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[output_size];
+
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_8UC3, out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    delete[] input_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "cvtColorTwoPlane_drp method end.");
+
+    return DRP_NORMAL_END;
+}
+
 //
 // HAL functions
 //
@@ -75,7 +661,6 @@ void cvtYUVtoBGR(const uchar * src_data,
 
     CALL_HAL(cvtYUVtoBGR, cv_hal_cvtYUVtoBGR, src_data, src_step, dst_data, dst_step, width, height, depth, dcn, swapBlue, isCbCr);
 
-
 #if defined(HAVE_IPP)
 #if !IPP_DISABLE_YUV_RGB
     CV_IPP_CHECK()
@@ -312,7 +897,7 @@ bool oclCvtColorBGR2ThreePlaneYUV( Input
     }
 
     return h.run();
-}
+} 
 
 #endif
 
@@ -337,8 +922,25 @@ void cvtColorYUV2BGR(InputArray _src, Ou
                      h.depth, dcn, swapb, crcb);
 }
 
-void cvtColorOnePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int ycn)
+void cvtColorOnePlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int ycn, int color_code)
 {
+    CV_LOG_INFO(nullptr, "cvtColorOnePlaneYUV2BGR start."); 
+
+    _dst.create( _src.size(), CV_8UC3 );
+    Mat src = _src.getMat();
+    Mat dst = _dst.getMat();
+
+    /* First, to call drp process */ 
+    int return_drp = 0;
+
+    return_drp = cv::cvtYUVtoBGR_drp(src, dst, src.cols, src.rows, color_code);
+    if(DRP_NOT_EXECUTE != return_drp)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "exec cvtColorOnePlaneYUV2BGR normal OpenCV."); 
+
     CvtHelper< Set<2>, Set<3, 4>, Set<CV_8U> > h(_src, _dst, dcn);
 
     hal::cvtOnePlaneYUVtoBGR(h.src.data, h.src.step, h.dst.data, h.dst.step, h.src.cols, h.src.rows,
@@ -386,8 +988,25 @@ void cvtColorThreePlaneYUV2BGR( InputArr
 // http://www.fourcc.org/yuv.php#NV21 == yuv420sp -> a plane of 8 bit Y samples followed by an interleaved V/U plane containing 8 bit 2x2 subsampled chroma samples
 // http://www.fourcc.org/yuv.php#NV12 -> a plane of 8 bit Y samples followed by an interleaved U/V plane containing 8 bit 2x2 subsampled colour difference samples
 
-void cvtColorTwoPlaneYUV2BGR( InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx )
+void cvtColorTwoPlaneYUV2BGR(InputArray _src, OutputArray _dst, int dcn, bool swapb, int uidx, int color_code)
 {
+    CV_LOG_INFO(nullptr, "cvtColorTwoPlaneYUV2BGR start."); 
+
+   _dst.create( _src.size(), CV_8UC3 );
+    Mat src = _src.getMat();
+    Mat dst = _dst.getMat();
+
+    /* First, to call drp process */ 
+    int return_drp = 0;
+
+    return_drp = cv::cvtYUVtoBGR_drp(src, dst, src.cols, src.rows, color_code);
+    if(DRP_NOT_EXECUTE != return_drp)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "exec cvtColorTwoPlaneYUV2BGR OpenCV normal."); 
+
     if(dcn <= 0) dcn = 3;
     CvtHelper< Set<1>, Set<3, 4>, Set<CV_8U>, FROM_YUV> h(_src, _dst, dcn);
 
diff -uprN old/modules/imgproc/src/deriv.cpp new/modules/imgproc/src/deriv.cpp
--- old/modules/imgproc/src/deriv.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/deriv.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -46,6 +46,9 @@
 #include "opencv2/core/openvx/ovx_defs.hpp"
 #include "filter.hpp"
 
+#include <opencv2/core/utils/logger.hpp>
+#include <rzv2ma_drp.h>
+
 /****************************************************************************************\
                              Sobel & Scharr Derivative Filters
 \****************************************************************************************/
@@ -411,11 +414,195 @@ static bool ocl_sepFilter3x3_8UC1(InputA
 }
 #endif
 
+/***********************************************************************
+* Method Name   : cv::Sobel_drp
+* Description   : to execute cv::Sobel_drp
+*               : _src = input image object, _dst = output image object
+*               : ddepth = output image depth, dx = order of the drivative x
+*               : dy = order of the drivative y, ksize = (option) kernal size
+*               : scale = (option)scale factor, delta = (option) delta value 
+*               : borderType = (option)border type,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************************/
+int cv::Sobel_drp(InputArray _src, OutputArray _dst, int ddepth, int dx, int dy,
+                int ksize, double scale, double delta, int borderType)
+{
+    /* exec drp function process */
+    CV_LOG_INFO(nullprt, "Sobel_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_SOBEL);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* convert to mat object */
+    Mat src_mat = _src.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    Mat dst_mat = _dst.getMat();
+
+    int result = DRP_NORMAL_END;
+
+    /* width */
+    if (3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* height */
+    if (2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* dx dy (dx=1 and dy=0) or (dx=0 and dy=1) */
+    if ( !(1 == dx && 0 == dy) && !(0 == dx && 1 == dy) )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* ksize = 3 */
+    if( 3 != ksize )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* scale = 1 */
+    if( 1 != scale )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* delta = 0 */
+    if( 0 != delta )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* ddepth = -1 */
+    if( -1 != ddepth )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType = BORDER_DEFAULT */
+    if(BORDER_DEFAULT != borderType)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* set dx, dy parameter */
+    uint16_t deltaXY = 99;
+    if(dx == 1 && dy == 0)
+    {
+        deltaXY = 0;
+    }
+    else if(dx == 0 && dy == 1)
+    {
+        deltaXY = 1;
+    }
+
+    result = drp->setSobelParameter(src_width, src_height, src_ch, deltaXY);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(src_mat.data);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;       
+    }
+    
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_MAKETYPE(src_mat.depth(), src_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullprt, "Sobel_drp end.");
+
+    drp->set_drp_end();
+
+    return result;
+}
+
 void cv::Sobel( InputArray _src, OutputArray _dst, int ddepth, int dx, int dy,
                 int ksize, double scale, double delta, int borderType )
 {
     CV_INSTRUMENT_REGION();
 
+    /* ddepth to drp */
+    int ddepth_drp = ddepth;
+
     int stype = _src.type(), sdepth = CV_MAT_DEPTH(stype), cn = CV_MAT_CN(stype);
     if (ddepth < 0)
         ddepth = sdepth;
@@ -446,6 +633,15 @@ void cv::Sobel( InputArray _src, OutputA
     Mat src = _src.getMat();
     Mat dst = _dst.getMat();
 
+    /* exec Sobel_drp */
+    int result = Sobel_drp(_src, _dst, ddepth_drp, dx, dy, ksize, scale, delta, borderType);
+    if(DRP_NOT_EXECUTE != result)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullprt, "continue to normal opencv.");
+
     Point ofs;
     Size wsz(src.cols, src.rows);
     if(!(borderType & BORDER_ISOLATED))
@@ -462,7 +658,6 @@ void cv::Sobel( InputArray _src, OutputA
     sepFilter2D(src, dst, ddepth, kx, ky, Point(-1, -1), delta, borderType );
 }
 
-
 void cv::Scharr( InputArray _src, OutputArray _dst, int ddepth, int dx, int dy,
                  double scale, double delta, int borderType )
 {
diff -uprN old/modules/imgproc/src/filter.dispatch.cpp new/modules/imgproc/src/filter.dispatch.cpp
--- old/modules/imgproc/src/filter.dispatch.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/filter.dispatch.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -50,7 +50,8 @@
 #include "filter.simd.hpp"
 #include "filter.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
-
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
 /****************************************************************************************\
                                     Base Image Filter
 \****************************************************************************************/
@@ -1347,11 +1348,220 @@ void sepFilter2D(int stype, int dtype, i
 //================================================================
 //   Main interface
 //================================================================
+/***********************************************************
+* Method Name   : filter2D_drp
+* Description   : to execute filter2D_drp
+*               : _src = input image object, _dst = output image object
+*               : _kernel = kernel object,  anchor0 = position of the anchor
+*               : delta(option filtered pixel), borderType = border type,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int filter2D_drp(InputArray _src, OutputArray _dst, int ddepth,
+              InputArray _kernel, Point anchor0,
+              double delta, int borderType)
+{
+    CV_LOG_INFO(nullprt, "filter2d_drp start(with ocl support check.) ");
+
+    /* exec drp function process */
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_FILTER2D);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* convert to mat object */
+    Mat src_mat = _src.getMat();
+    Mat kernel_mat = _kernel.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    /* width */
+    if (3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* height */
+    if (2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType */
+    if (borderType != BORDER_DEFAULT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* ddepth (-1) means same as src depth */
+    if (ddepth != -1)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* anchor0: default value(-1,-1) only. (from specification) */
+    /* anchor0 x */
+    if(anchor0.x != -1)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* anchor0 y */
+    if(anchor0.y != -1)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* delta */
+    if(delta != 0)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* kernel width */
+    if(kernel_mat.cols != 3)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* kernel height */
+    if(kernel_mat.rows != 3)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* kernel depth */
+    if (CV_32F != kernel_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* kernel to simple array */
+    float filterVals[9];
+    int idxfilter = 0;
+
+    for(int j = 0; j < kernel_mat.cols; j++)
+    {
+        for(int i = 0; i < kernel_mat.rows; i++)
+        {
+            filterVals[idxfilter] = kernel_mat.at<float>(j,i);
+            idxfilter++;
+        }
+    }
+
+    /* range check */
+    for(idxfilter = 0; idxfilter < 9; idxfilter++)
+    {
+        if(filterVals[idxfilter] <= -128 || filterVals[idxfilter] > 127)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    Mat dst_mat = _dst.getMat();
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setFilter2dParameter(src_width, src_height, src_ch, filterVals);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(src_mat.data);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;       
+    }
+    
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_MAKETYPE(src_mat.depth(), src_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullprt, "Filter2d_drp end.");
+
+    drp->set_drp_end();
+
+    return result;
+}
 
 void filter2D(InputArray _src, OutputArray _dst, int ddepth,
               InputArray _kernel, Point anchor0,
               double delta, int borderType)
 {
+    int ddeptharg = ddepth;  //ddepth to drp function
+
     CV_INSTRUMENT_REGION();
 
     CV_OCL_RUN(_dst.isUMat() && _src.dims() <= 2,
@@ -1371,6 +1581,17 @@ void filter2D(InputArray _src, OutputArr
     if( (borderType & BORDER_ISOLATED) == 0 )
         src.locateROI( wsz, ofs );
 
+    /* next, exec drp function */
+    int ret = filter2D_drp(_src, _dst, ddeptharg, _kernel, anchor0, delta, borderType);
+    if(ret != DRP_NOT_EXECUTE)
+    {
+        CV_LOG_INFO(nullprt, "Filter2d_drp nornal end.");
+        return;
+    }
+
+    /* if drp function not executed, contine to normal opencv function */
+    CV_LOG_INFO(nullprt, "continue to nornal opencv procedure.");
+
     hal::filter2D(src.type(), dst.type(), kernel.type(),
                   src.data, src.step, dst.data, dst.step,
                   dst.cols, dst.rows, wsz.width, wsz.height, ofs.x, ofs.y,
diff -uprN old/modules/imgproc/src/imgwarp.cpp new/modules/imgproc/src/imgwarp.cpp
--- old/modules/imgproc/src/imgwarp.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/imgwarp.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -56,6 +56,9 @@
 #include "opencv2/core/softfloat.hpp"
 #include "imgwarp.hpp"
 
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
+
 using namespace cv;
 
 namespace cv
@@ -1488,9 +1491,6 @@ static bool ocl_logPolar(InputArray _src
 
     if (!(flags & CV_WARP_INVERSE_MAP))
     {
-
-
-
         ocl::Kernel computeAngleRadius_Kernel("computeAngleRadius", p);
         float PI2_height = (float) CV_2PI / dsize.height;
 
@@ -1508,11 +1508,7 @@ static bool ocl_logPolar(InputArray _src
         Size ssize = src_with_border.size();
         ssize.height -= 2 * ANGLE_BORDER;
         float ascale =  ssize.height / ((float)CV_2PI);
-
-
         k.args(ocl_mapx, ocl_mapy, ascale, (float)M, center.x, center.y, ANGLE_BORDER, (unsigned)dsize.width, (unsigned)dsize.height);
-
-
     }
     size_t globalThreads[2] = { (size_t)dsize.width , (size_t)dsize.height };
     size_t localThreads[2] = { mem_size , mem_size };
@@ -2585,6 +2581,201 @@ void warpAffine(int src_type,
 } // hal::
 } // cv::
 
+/*****************************************
+* Method Name   : warpAffline_drp
+* Description   : to exec drp process of OpenCV accelerator warpAffine.
+* Arguments     : _src = src image(Mat), _dst = dst image(Mat), _M0 = tranceformation,
+                dsize = output size, flags = combination of interpolation,
+                borderType = pixel extrapolation method, borderValue = in case of a constant border
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int cv::warpAffine_drp(InputArray _src, OutputArray _dst,
+                     InputArray _M0, Size dsize,
+                     int flags, int borderMode, const Scalar& borderValue)
+{
+    CV_LOG_INFO(nullptr, "warpAffine_drp start.");
+  
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "warpAffine_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* get possible flag */
+    int affine_possiblef = drp->get_drp_possiblef(PARAM_NO_WARPAFFINE);
+    
+    /* active status only */
+    if(affine_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat src_mat = _src.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    /* set width height ch */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+    uint16_t dst_width = dst_mat.size().width;
+    uint16_t dst_height = dst_mat.size().height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t dst_ch = dst_mat.channels();
+
+    /* src width */
+    if(3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src height */
+    if(2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output width */
+    if(3840 < dsize.width || 16 > dsize.width || 0 != dsize.width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output height */
+    if(2160 < dsize.height || 16 > dsize.height || 0 != dsize.height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat M0_mat = _M0.getMat();
+    if(M0_mat.depth() != CV_32F)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* transform matrix */
+    if(M0_mat.cols != 3 || M0_mat.rows != 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* flags */
+    if(flags != INTER_LINEAR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderMode */
+    if(borderMode != BORDER_CONSTANT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* border value */
+    uint32_t border_value_32t = 0;
+    uint8_t bgra_8t[4];
+
+    bgra_8t[0] = borderValue(0); //B
+    bgra_8t[1] = borderValue(1); //G
+    bgra_8t[2] = borderValue(2); //R
+    bgra_8t[3] = borderValue(3); //A
+    
+    memcpy(&border_value_32t, bgra_8t, 4);
+
+    /* set transformation matrix */
+    float f_M0[6];
+    f_M0[0] = M0_mat.at<float>(0,0);
+    f_M0[1] = M0_mat.at<float>(0,1);
+    f_M0[2] = M0_mat.at<float>(0,2);
+    f_M0[3] = M0_mat.at<float>(1,0);
+    f_M0[4] = M0_mat.at<float>(1,1);
+    f_M0[5] = M0_mat.at<float>(1,2);
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+    
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "warpAffine_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* to set warpAffine parameter */
+    result = drp->setWarpAffineParameter(src_width, src_height, src_ch, dst_width, dst_height, f_M0, border_value_32t);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set warpAffine src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read warpAffine dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "warpAffine_drp end.");
+
+    return DRP_NORMAL_END;
+}
 
 void cv::warpAffine( InputArray _src, OutputArray _dst,
                      InputArray _M0, Size dsize,
@@ -2696,11 +2887,18 @@ void cv::warpAffine( InputArray _src, Ou
     }
 #endif
 
+    int result = cv::warpAffine_drp(_src, _dst, _M0, dsize, flags, borderType, borderValue);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "warpAffine_drp continue to normal opencv.");
+
     hal::warpAffine(src.type(), src.data, src.step, src.cols, src.rows, dst.data, dst.step, dst.cols, dst.rows,
                     M, interpolation, borderType, borderValue.val);
 }
 
-
 namespace cv
 {
 
@@ -2895,6 +3093,205 @@ void warpPerspective(int src_type,
 } // hal::
 } // cv::
 
+/*****************************************
+* Method Name   : warpPerspective_drp
+* Description   : to exec drp process of OpenCV accelerator warpPerspective.
+* Arguments     : _src = src image(Mat), _dst = dst image(Mat), _M0 = tranceformation,
+                dsize = output size, flags = combination of interpolation,
+                borderMode = pixel extrapolation method, borderValue = in case of a constant border
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int cv::warpPerspective_drp( InputArray _src, OutputArray _dst, InputArray _M0,
+                          Size dsize, int flags, int borderMode, const Scalar& borderValue )
+{
+    CV_LOG_INFO(nullptr, "warpPerspective_drp start.");
+  
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "warpPerspective_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* get possible flag */
+    int perspective_possiblef = drp->get_drp_possiblef(PARAM_NO_WARPPERSPECTIVE);
+    
+    /* active status only */
+    if(perspective_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat src_mat = _src.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    /* set width height ch */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+    uint16_t dst_width = dst_mat.size().width;
+    uint16_t dst_height = dst_mat.size().height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t dst_ch = dst_mat.channels();
+
+    /* src width */
+    if(3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src height */
+    if(2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output width */
+    if(3840 < dsize.width || 16 > dsize.width || 0 != dsize.width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output height */
+    if(2160 < dsize.height || 16 > dsize.height || 0 != dsize.height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat M0_mat = _M0.getMat();
+    if(M0_mat.depth() != CV_32F)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* transform matrix */
+    if(M0_mat.cols != 3 || M0_mat.rows != 3)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* flags */
+    if(flags != INTER_LINEAR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderMode */
+    if(borderMode != BORDER_CONSTANT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* border value */
+    uint32_t border_value_32t = 0;
+    uint8_t bgra_8t[4];
+
+    bgra_8t[0] = borderValue(0); //B
+    bgra_8t[1] = borderValue(1); //G
+    bgra_8t[2] = borderValue(2); //R
+    bgra_8t[3] = borderValue(3); //A
+    
+    memcpy(&border_value_32t, bgra_8t, 4);
+
+    /* set transformation matrix */
+    float f_M0[9];
+    f_M0[0] = M0_mat.at<float>(0,0);
+    f_M0[1] = M0_mat.at<float>(0,1);
+    f_M0[2] = M0_mat.at<float>(0,2);
+    f_M0[3] = M0_mat.at<float>(1,0);
+    f_M0[4] = M0_mat.at<float>(1,1);
+    f_M0[5] = M0_mat.at<float>(1,2);
+    f_M0[6] = M0_mat.at<float>(2,0);
+    f_M0[7] = M0_mat.at<float>(2,1);
+    f_M0[8] = M0_mat.at<float>(2,2);
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "warpPerspective_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* to set warpPerspective parameter */
+    result = drp->setWarpPerspectiveParameter(src_width, src_height, src_ch, dst_width, dst_height, f_M0, border_value_32t);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set warpPerspective src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read warpPerspective dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "warpPerspective_drp end.");
+
+    return DRP_NORMAL_END;
+}
+
+
 void cv::warpPerspective( InputArray _src, OutputArray _dst, InputArray _M0,
                           Size dsize, int flags, int borderType, const Scalar& borderValue )
 {
@@ -2989,6 +3386,14 @@ void cv::warpPerspective( InputArray _sr
     if( !(flags & WARP_INVERSE_MAP) )
         invert(matM, matM);
 
+    int result = cv::warpPerspective_drp(_src, _dst, _M0, dsize, flags, borderType, borderValue);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "warpPerspective_drp continue to normal opencv.");
+
     hal::warpPerspective(src.type(), src.data, src.step, src.cols, src.rows, dst.data, dst.step, dst.cols, dst.rows,
                         matM.ptr<double>(), interpolation, borderType, borderValue.val);
 }
diff -uprN old/modules/imgproc/src/morph.dispatch.cpp new/modules/imgproc/src/morph.dispatch.cpp
--- old/modules/imgproc/src/morph.dispatch.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/morph.dispatch.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -50,7 +50,8 @@
 
 #include "morph.simd.hpp"
 #include "morph.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
-
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
 
 /****************************************************************************************\
                      Basic Morphological Operations: Erosion & Dilation
@@ -999,23 +1000,251 @@ static void morphOp( int op, InputArray
                (src.isSubmatrix() && !isolated));
 }
 
+/***********************************************************
+* Method Name   : morphOp_drp
+* Description   : to execute morphOp_drp
+* Arguments     : op = operation(MORPH_DILATE or MORPH_ERODE)
+*               : _src = input image object, _dst = output image object
+*               : _kernel = kernel object,  anchor = position of the anchor
+*               : iterations = nuber of times applied, borderType = border type,
+*               : borderValue = border value
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+static int morphOp_drp(int op, InputArray _src, OutputArray _dst,
+                        InputArray _kernel,
+                        Point anchor, int iterations,
+                        int borderType, const Scalar &borderValue)
+{
+    CV_LOG_INFO(nullprt, "morphOp_drp start.");
+
+    /* in this version it can support dilate or erode */
+    if (MORPH_DILATE != op && MORPH_ERODE != op)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set morphology parameter */
+    uint16_t circuilt_no = 0;
+
+    switch (op)
+    {
+    case MORPH_DILATE:
+        circuilt_no = PARAM_NO_MORPH_DILATE;
+        break;
+
+    case MORPH_ERODE:
+        circuilt_no = PARAM_NO_MORPH_ERODE;
+        break;
+
+    default:
+        break;
+    }
+ 
+    /* exec drp function process */
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(circuilt_no);
+
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* convert to mat object */
+    Mat src_mat = _src.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    /* width */
+    if (3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* height */
+    if (2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src image size */
+    if (3840 * 2160 < src_width * src_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType */
+    if (borderType != BORDER_CONSTANT && borderType != BORDER_REPLICATE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* kernel */
+    Mat kernel = _kernel.getMat();
+    Size ksize = !kernel.empty() ? kernel.size() : Size(3, 3);
+
+    if (ksize != Size(3, 3))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* Anchor */
+    if (anchor != Point(-1, -1))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* Iterations */
+    if (1 > iterations || 3840 < iterations)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* border value */
+    const Scalar defaultBorderValue = morphologyDefaultBorderValue();
+    if (defaultBorderValue != borderValue)
+    {
+        return DRP_NOT_EXECUTE; 
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* it is nesessary to create dst mat object. */
+    int type = _src.type();
+    Size size = _src.size();
+    _dst.create(size, type);
+
+    Mat dst_mat = _dst.getMat();
+
+    int result = DRP_NORMAL_END;
+
+    /* set in process flag */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* set morphology parameter */
+    result = drp->setMorphologyParameter(src_width, src_height, src_ch, iterations, borderType, borderValue[0], circuilt_no);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(src_mat.data);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, src_mat.type(), out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullprt, "morphOp_drp end.");
+
+    /* reset in process flag */
+    drp->set_drp_end();
+
+    return result;
+}
+
 void erode( InputArray src, OutputArray dst, InputArray kernel,
                 Point anchor, int iterations,
                 int borderType, const Scalar& borderValue )
 {
     CV_INSTRUMENT_REGION();
+    CV_LOG_INFO(nullptr, "start erode filter.");
 
-    morphOp( MORPH_ERODE, src, dst, kernel, anchor, iterations, borderType, borderValue );
-}
+    int ret_drp = DRP_NORMAL_END;
+    ret_drp = morphOp_drp(MORPH_ERODE, src, dst, kernel, anchor, iterations, borderType, borderValue);
+
+    if (DRP_NOT_EXECUTE == ret_drp)
+    {
+        CV_LOG_INFO(nullptr, "exec normal erode.");
+        morphOp(MORPH_ERODE, src, dst, kernel, anchor, iterations, borderType, borderValue);
+    }
 
+    CV_LOG_INFO(nullptr, "erode filter end.");
+}
 
 void dilate( InputArray src, OutputArray dst, InputArray kernel,
                  Point anchor, int iterations,
                  int borderType, const Scalar& borderValue )
 {
     CV_INSTRUMENT_REGION();
+    CV_LOG_INFO(nullptr, "dilate method start.");
+
+    int ret_drp = DRP_NORMAL_END;
+    ret_drp = morphOp_drp(MORPH_DILATE, src, dst, kernel, anchor, iterations, borderType, borderValue);
+
+    if (DRP_NOT_EXECUTE == ret_drp)
+    {
+        CV_LOG_INFO(nullptr, "exec normal dilate.");
+        morphOp(MORPH_DILATE, src, dst, kernel, anchor, iterations, borderType, borderValue);
+    }
 
-    morphOp( MORPH_DILATE, src, dst, kernel, anchor, iterations, borderType, borderValue );
+    CV_LOG_INFO(nullptr, "dilate filter end.");
 }
 
 #ifdef HAVE_OPENCL
diff -uprN old/modules/imgproc/src/pyramids.cpp new/modules/imgproc/src/pyramids.cpp
--- old/modules/imgproc/src/pyramids.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/pyramids.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -46,6 +46,9 @@
 #include "opencv2/core/hal/intrin.hpp"
 
 #include "opencv2/core/openvx/ovx_defs.hpp"
+#include <opencv2/core/utils/logger.hpp>
+
+#include <rzv2ma_drp.h>
 
 namespace cv
 {
@@ -1219,6 +1222,165 @@ static bool openvx_pyrDown( InputArray _
 }
 #endif
 
+/**************************************************************************************************************
+* Method Name   : cv::pyrDown_drp()
+* Description   : exec pyrDown drp version
+* Arguments     : _src = src image, _dst = src image height, src_ch = src image channels,
+                  dsize_width = output image width, dsize_height = output image height,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+***************************************************************************************************************/
+int cv::pyrDown_drp(InputArray _src, OutputArray _dst, const Size& _dsz, int borderType)
+{
+    CV_LOG_INFO(nullptr, "pyrDown_drp start.");
+    
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "pyrDown_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_PYRDOWN);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        CV_LOG_INFO(nullptr, "pyrDown_drp inactive.");
+        return DRP_NOT_EXECUTE;
+    }
+
+    CV_LOG_INFO(nullptr, "pyrDown_drp active.");
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* to convert to Mat class */ 
+    Mat src_mat = _src.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    /* set width height ch */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+
+    uint16_t dst_width = _dsz.width;
+    uint16_t dst_height = _dsz.height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t dst_ch = src_mat.channels();
+
+    if(_dsz.empty())
+    {
+        dst_height = src_height / 2;
+        dst_width = src_width / 2;
+    }
+  
+    /* src width */
+    if(3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src height */
+    if(2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+   
+    /* check output size rate */
+    if(src_width / 2 != dst_width || src_height / 2 != dst_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType */
+    if(borderType != BORDER_DEFAULT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "pyrUp_down read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* to set pyrDown parameter */
+    result = drp->setPyrDownParameter(src_width, src_height, src_ch, dst_width, dst_height);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set pryDown src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read pryDown dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+    CV_LOG_INFO(nullptr, "pyrDown_drp end.");
+
+    return DRP_NORMAL_END;
+}
+
 void cv::pyrDown( InputArray _src, OutputArray _dst, const Size& _dsz, int borderType )
 {
     CV_INSTRUMENT_REGION();
@@ -1246,6 +1408,14 @@ void cv::pyrDown( InputArray _src, Outpu
     CV_IPP_RUN(borderTypeNI == BORDER_DEFAULT && (!_src.isSubmatrix() || isolated) && dsz == Size((_src.cols() + 1)/2, (_src.rows() + 1)/2),
         ipp_pyrdown( _src,  _dst,  _dsz,  borderType));
 
+    /* exec drp function */
+    int result = cv::pyrDown_drp(_src, _dst, _dsz, borderType);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "pyrDown_drp continue to normal opencv.");
 
     PyrFunc func = 0;
     if( depth == CV_8U )
@@ -1264,7 +1434,6 @@ void cv::pyrDown( InputArray _src, Outpu
     func( src, dst, borderType );
 }
 
-
 #if defined(HAVE_IPP)
 namespace cv
 {
@@ -1326,6 +1495,163 @@ static bool ipp_pyrup( InputArray _src,
 }
 #endif
 
+/**************************************************************************************************************
+* Method Name   : cv::pyrUp_drp()
+* Description   : exec pyrUp drp version
+* Arguments     : _src = src image, _dst = src image height, src_ch = src image channels,
+                  dsize_width = output image width, dsize_height = output image height,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+***************************************************************************************************************/
+int cv::pyrUp_drp(InputArray _src, OutputArray _dst, const Size& _dsz, int borderType)
+{
+    CV_LOG_INFO(nullptr, "pyrUp_drp start.");
+    
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "pyrUp_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_PYRUP);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        CV_LOG_INFO(nullptr, "pyrUp_drp inactive.");
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* to convert to Mat class */ 
+    Mat src_mat = _src.getMat();
+    Mat dst_mat = _dst.getMat();
+
+    /* set width height ch */
+    uint16_t src_width = src_mat.size().width;
+    uint16_t src_height = src_mat.size().height;
+
+    uint16_t dst_width = _dsz.width;
+    uint16_t dst_height = _dsz.height;
+    uint16_t src_ch = src_mat.channels();
+    uint16_t dst_ch = src_mat.channels();
+
+    if(_dsz.empty())
+    {
+        dst_height = src_height * 2;
+        dst_width = src_width * 2;
+    }
+  
+    /* src width */
+    if(1920 < src_width || 8 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* src height */
+    if(1080 < src_height || 8 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+   
+    /* check output size rate */
+    if(src_width*2 != dst_width || src_height*2 != dst_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* borderType */
+    if(borderType != BORDER_DEFAULT)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "pyrUp_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* to set pyrUp parameter */
+    result = drp->setPyrUpParameter(src_width, src_height, src_ch, dst_width, dst_height);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set pyrUp src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read pyrUp dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+    CV_LOG_INFO(nullptr, "pyrUp_drp end.");
+
+    return DRP_NORMAL_END;
+}
+
 void cv::pyrUp( InputArray _src, OutputArray _dst, const Size& _dsz, int borderType )
 {
     CV_INSTRUMENT_REGION();
@@ -1335,7 +1661,6 @@ void cv::pyrUp( InputArray _src, OutputA
     CV_OCL_RUN(_src.dims() <= 2 && _dst.isUMat(),
                ocl_pyrUp(_src, _dst, _dsz, borderType))
 
-
     Mat src = _src.getMat();
     Size dsz = _dsz.empty() ? Size(src.cols*2, src.rows*2) : _dsz;
     _dst.create( dsz, src.type() );
@@ -1349,6 +1674,13 @@ void cv::pyrUp( InputArray _src, OutputA
     CV_IPP_RUN(borderTypeNI == BORDER_DEFAULT && (!_src.isSubmatrix() || isolated) && dsz == Size(_src.cols()*2, _src.rows()*2),
         ipp_pyrup( _src,  _dst,  _dsz,  borderType));
 
+    int result = cv::pyrUp_drp(_src, _dst, _dsz, borderType);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullptr, "pyrUp_drp continue to normal opencv.");
 
     PyrFunc func = 0;
     if( depth == CV_8U )
diff -uprN old/modules/imgproc/src/resize.cpp new/modules/imgproc/src/resize.cpp
--- old/modules/imgproc/src/resize.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/resize.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -58,6 +58,9 @@
 #include "opencv2/core/softfloat.hpp"
 #include "fixedpoint.inl.hpp"
 
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
+
 using namespace cv;
 
 namespace
@@ -3704,6 +3707,192 @@ void resize(int src_type,
 }
 
 } // cv::hal::
+
+/*****************************************
+* Method Name   : resize_drp
+* Description   : to exec drp process of OpenCV accelerator resize.
+* Arguments     : _src = src image(Mat), _dst = dst image(Mat), dsize = src image size,
+                  inv_scale_x = resize scale for x, inv_scale_y = resize scale for y, interpolation) = dst image channels,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int resize_drp(InputArray _src, OutputArray _dst, Size dsize, double inv_scale_x, double inv_scale_y, int interpolation)
+{
+    CV_LOG_INFO(nullptr, "resize_drp start.");
+    
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        CV_LOG_INFO(nullptr, "resize_drp get instance");
+        return DRP_NOT_EXECUTE;
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_RESIZE);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert to Mat class */
+    Mat src_mat = _src.getMat(); 
+
+    /* to set resize spec */
+    uint32_t src_width = src_mat.size().width;
+    uint32_t src_height = src_mat.size().height;
+    uint32_t src_ch = src_mat.channels();
+    int src_depth = src_mat.depth();
+
+    static const uint32_t img_max_width = 3840, img_max_height = 2160;
+
+    /* checking src image size */
+    if (2 > src_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    if (2 > src_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    if(img_max_width < src_width)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    if(img_max_height < src_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking channel size */ 
+    if((1 > src_ch) || (4 < src_ch))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* Check depth */
+    if(CV_8U != src_depth)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* dst src size */
+    uint32_t dst_width = 0;
+    uint32_t dst_height = 0;
+    uint16_t dst_ch = src_ch;
+
+    /* output image buffer */
+    uint8_t *out_image_buffer;
+
+    /* check input size */
+    if(0 < dsize.area())
+    {    
+        dst_width = dsize.width;
+        dst_height = dsize.height;
+    }
+    else
+    {
+        // need to cast integer to double for small scale
+        dst_width = round( (double)src_width * inv_scale_x );
+        dst_height = round( (double)src_height * inv_scale_y );
+    }
+
+    if(2 > dst_width)
+    {
+            return DRP_NOT_EXECUTE;
+    }
+    if(2 > dst_height)
+    {
+            return DRP_NOT_EXECUTE;
+    }
+
+    if(img_max_width < dst_width) // cast opencv type to unsigned
+    {
+         return DRP_NOT_EXECUTE;
+    }
+    if(img_max_height < dst_height) // cast opencv type to unsigned
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* checking algorizm */
+    if(INTER_LINEAR != interpolation) 
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[dst_width*dst_height*dst_ch];
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+ 
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        CV_LOG_INFO(nullptr, "resize_drp read header error.");
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set resize parameter */
+    result = drp->setResizeParameter(src_width, src_height, src_ch, dst_width, dst_height, dst_ch);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to set resize src image to drp input area */
+    result = drp->setSrcImage(src_mat.data);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* executing drp process */
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to read resize dst image from drp output area */
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* to convert mat object */
+    Mat dst_mat_out =  Mat(dst_height, dst_width, CV_8UC(dst_ch), out_image_buffer);
+    dst_mat_out.copyTo(_dst);
+
+    delete[] out_image_buffer;
+
+    drp->set_drp_end();
+
+    CV_LOG_INFO(nullptr, "resize_drp end.");
+
+    return DRP_NORMAL_END;
+}
+
 } // cv::
 
 //==================================================================================================
@@ -3712,6 +3901,17 @@ void cv::resize( InputArray _src, Output
                  double inv_scale_x, double inv_scale_y, int interpolation )
 {
     CV_INSTRUMENT_REGION();
+    CV_LOG_INFO(nullptr, "resize method start.");
+
+    /* First, to call drp process */ 
+    int result = cv::resize_drp(_src, _dst, dsize, inv_scale_x, inv_scale_y, interpolation);
+    if(result == DRP_NORMAL_END)
+    {
+        return;
+    }
+
+    /* If could not execute drp process, then to call normal opencv method */    
+    CV_LOG_INFO(nullptr, "exec normal resize method.");
 
     Size ssize = _src.size();
 
diff -uprN old/modules/imgproc/src/rzv2ma_drp.cpp new/modules/imgproc/src/rzv2ma_drp.cpp
--- old/modules/imgproc/src/rzv2ma_drp.cpp	1970-01-01 09:00:00.000000000 +0900
+++ new/modules/imgproc/src/rzv2ma_drp.cpp	2024-01-24 20:51:40.000000000 +0900
@@ -0,0 +1,2265 @@
+/***********************************************************************************************************************
+* DISCLAIMER
+* This software is supplied by Renesas Electronics Corporation and is only intended for use with Renesas products. No
+* other uses are authorized. This software is owned by Renesas Electronics Corporation and is protected under all
+* applicable laws, including copyright laws.
+* THIS SOFTWARE IS PROVIDED "AS IS" AND RENESAS MAKES NO WARRANTIES REGARDING
+* THIS SOFTWARE, WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING BUT NOT LIMITED TO WARRANTIES OF MERCHANTABILITY,
+* FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. ALL SUCH WARRANTIES ARE EXPRESSLY DISCLAIMED. TO THE MAXIMUM
+* EXTENT PERMITTED NOT PROHIBITED BY LAW, NEITHER RENESAS ELECTRONICS CORPORATION NOR ANY OF ITS AFFILIATED COMPANIES
+* SHALL BE LIABLE FOR ANY DIRECT, INDIRECT, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES FOR ANY REASON RELATED TO THIS
+* SOFTWARE, EVEN IF RENESAS OR ITS AFFILIATES HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
+* Renesas reserves the right, without notice, to make changes to this software and to discontinue the availability of
+* this software. By using this software, you agree to the additional terms and conditions found by accessing the
+* following link:
+* http://www.renesas.com/disclaimer
+*
+* Copyright (C) 2022 Renesas Electronics Corporation. All rights reserved.
+***********************************************************************************************************************/
+/***********************************************************************************************************************
+* File Name    : rzv2m_drp.cpp
+* Version      : 1.00
+* Description  : Call RZ/V2M From OpenCV Accelerator POC
+***********************************************************************************************************************/
+/*****************************************
+* Includes
+******************************************/
+#include <iostream>
+#include <stdlib.h>
+#include <stdio.h>
+#include <memory.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/ioctl.h>
+#include <sys/mman.h>
+#include <sys/stat.h>
+#include <errno.h>
+#include <mutex>
+
+#include <thread>
+#include <sstream>
+#include <rzv2ma_drp.h>
+#include <opencv2/core/base.hpp>
+#include <opencv2/core/utils/logger.hpp>
+
+/* single instance of rzv2m drp */
+rzv2m_drp* rzv2m_drp::_singleton = NULL;
+
+/* conflict notification action */
+int rzv2m_drp::drp_conflict_exception = 0;
+
+/* mutex for oca_activate */
+std::mutex drp_mutex;
+
+/* mutex for oca_conflict_notification */
+std::mutex drp_conflict_mutex;
+
+/* mutex for initialize sequence */
+std::mutex drp_initialize_mutex;
+
+/* mutex for initialize for api sequence */
+std::mutex drp_init_for_api_mutex;
+
+/*****************************************
+* Method Name   : rzv2m_drp
+* Description   : Constructor
+******************************************/
+rzv2m_drp::rzv2m_drp()
+{
+}
+
+/*****************************************
+* Method Name   : get_instance
+* Description   : initializing and return single instance
+* Arguments     : void
+* Return value  : rzv2m_drp single instance
+******************************************/
+rzv2m_drp* rzv2m_drp::get_instance()
+{
+    drp_initialize_mutex.lock();
+
+    /* check initialize if not exec initialize */
+    if(_singleton == NULL) 
+    {
+        _singleton = new rzv2m_drp();
+        _singleton->initialize();
+    }
+
+    drp_initialize_mutex.unlock();
+
+    return _singleton;
+}
+
+/**********************************************************************
+* Method Name   : get_instance_forapi
+* Description   : initializing and return single instance for api
+* Arguments     : void
+* Return value  : rzv2m_drp single instance
+***********************************************************************/
+rzv2m_drp* rzv2m_drp::get_instance_forapi()
+{
+    drp_init_for_api_mutex.lock();
+
+    /* check initialize if not exec initialize */
+    if(_singleton == NULL) 
+    {
+        _singleton = new rzv2m_drp();
+        _singleton->initialize();
+    }
+
+    drp_init_for_api_mutex.unlock();
+
+    return _singleton;
+}
+
+/*************************************************************************************
+* Method Name   : OCA_Activate
+* Description   : activate or inactivate
+* Arguments     : unsigned long* OCA_list: input param to activate or to inactivate
+* Return value  : int DRP_NORMAL_END(0) or DRP_PARAM_ERROR(-1)
+**************************************************************************************/
+int rzv2m_drp::OCA_Activate(unsigned long* OCA_list)
+{
+    if(OCA_list == NULL)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    drp_mutex.lock();
+
+    /* get circuit count (already read opencv_bin address info) */
+    int circuit_cnt = (opencv_bin_config_base - opencv_bin_list_base) / 32;
+    if( circuit_cnt >= DRP_CIRCUIT_CNT_MAX)
+    {
+       circuit_cnt = DRP_CIRCUIT_CNT_MAX; 
+    }
+
+    /* set to each input param to each possible flag */
+    uint32_t api_possiblef = 0;
+    uint32_t* p_api_possiblef = 0;
+
+    opencv_bin_list_base = *(uint32_t *)(&opencv_bin_p[24]);
+
+    for(int i=0; i<circuit_cnt; i++)
+    {
+        api_possiblef = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*i]);    // existence flag of circuit data 
+        p_api_possiblef = (uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*i]);    // existence flag of circuit data 
+
+        /* check input param value is valid */
+        if( (OCA_list[i] != CIRCUIT_INPARAM_INACTIVATE) && (OCA_list[i] != CIRCUIT_INPARAM_ACTIVATE) )
+        {
+            continue;
+        }
+
+        /* check if circuit exists */
+        if(api_possiblef == CIRCUIT_POSSIBLEF_NOT_EXIST)
+        {
+            /* can do nothing */
+            continue;    
+        }
+
+        /* set to active or inactive */
+        if(OCA_list[i] == CIRCUIT_INPARAM_ACTIVATE)
+        {
+            /* activate (to active) */
+            *p_api_possiblef = CIRCUIT_POSSIBLEF_ACTIVE;
+        }
+        else if(OCA_list[i] == CIRCUIT_INPARAM_INACTIVATE)
+        {
+            /* inactivate (to inactivate) */
+            *p_api_possiblef = CIRCUIT_POSSIBLEF_INACTIVE;
+        }
+    }
+
+    drp_mutex.unlock();
+
+    return DRP_NORMAL_END;
+}
+
+/*************************************************************************************
+* Method Name   : OCA_ConflictNotification
+* Description   : set conflict ation flag
+* Arguments     : int oca_conflict
+* Return value  : void
+**************************************************************************************/
+void rzv2m_drp::OCA_ConflictNotification(int oca_conflict)
+{
+    drp_conflict_mutex.lock();
+    
+    rzv2m_drp::drp_conflict_exception = oca_conflict;
+
+    drp_conflict_mutex.unlock();
+    
+    return;
+}
+
+/*************************************************************************************
+* Method Name   : conflict_action_exec
+* Description   : execute conflict atcion (CV_Error or normal opencv method)
+* Arguments     : void
+* Return value  : void
+**************************************************************************************/
+ void rzv2m_drp::conflict_action_exec(void)
+ {
+    /* default action */
+    if(rzv2m_drp::drp_conflict_exception == 0)
+    {
+        CV_Error(cv::Error::OpenCVADRPConflict, "OpenCVA DRP resource conflict.");
+    }
+
+    /* if rzv2m_drp::drp_conflict_exception is not 0 */
+    /* then exec normal opencv method */
+     
+    return;
+ }
+
+/*************************************************************************************
+* Method Name   : get_drp_possiblef
+* Description   : get circuite possible flag
+* Arguments     : uint16_t circuit_no:circuite function no
+* Return value  : drp_possible_flag
+**************************************************************************************/
+int rzv2m_drp::get_drp_possiblef(uint16_t circuit_no)
+{
+    uint32_t drp_possible_flag = -1;
+
+    char* signature_p = (char *)(&opencv_bin_p[0]);           // pointer to signature(16byte)
+    uint32_t list_base = *(uint32_t *)(&opencv_bin_p[24]);     // opencva list address(offset value)
+
+    if(!initialized || signature_p == NULL)
+    {
+        return drp_possible_flag;
+    }
+
+    drp_possible_flag = *(uint32_t *)(&opencv_bin_p[list_base + 32*circuit_no]);
+
+    return (int)drp_possible_flag;
+}
+
+/*********************************************************
+* Method Name   : readBinaryHeader
+* Description   : reading opencv binary header information
+* Arguments     : void
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+**********************************************************/
+int rzv2m_drp::readBinaryHeader(void)
+{
+    if(!initialized)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(strcmp(opencv_bin_signature_p, OCABIN_SIGNATURE) != 0)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setResizeParameter
+* Description   : to set resize parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dst_width = dst image width, dst_height = dst image height, dst_ch = dst image channels,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setResizeParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, uint16_t dst_ch)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_RESIZE; // resize circuit index
+    uint8_t drp_resize_param[PARAM_SIZE_RESIZE]; 
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    
+    dst_adr_64aligment();
+                            
+    /* set resize drp rapameter to local variables */
+    *((uint32_t *)(&drp_resize_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_resize_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_resize_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_resize_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_resize_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_resize_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_resize_param[16])) = dst_width; //output width(pixel)
+    *((uint16_t *)(&drp_resize_param[18])) = dst_height;//output width(pixel)
+    *((uint16_t *)(&drp_resize_param[20])) = dst_ch;    //output channels
+    *((uint16_t *)(&drp_resize_param[22])) = 0;         //reserved(0)
+    memset( &drp_resize_param[24],0,16);                //Not used(0)
+    *((uint16_t *)(&drp_resize_param[40])) = 0;         //CPU ionterupt on (0 fixed)
+    memset( &drp_resize_param[42],0,6);                 //reserved(0 fixed)
+    *((uint16_t *)(&drp_resize_param[48])) = 1;         //bylinear
+    *((uint16_t *)(&drp_resize_param[50])) = 0;         //U8
+    *((uint16_t *)(&drp_resize_param[52])) = 0;         //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_RESIZE;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_resize_param, PARAM_SIZE_RESIZE);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ( ret != PARAM_SIZE_RESIZE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************************
+* Method Name   : setYUV2RGBParameter
+* Description   : to set YUV2RGB parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, input_size = src image size,
+                  input_format = input format, src_width = dst image width, dst_height = dst image height, 
+                  output_format = output format(rgb or gbr)
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************************/
+int rzv2m_drp::setYUV2RGBParameter(uint16_t src_width, uint16_t src_height, uint32_t input_size, uint16_t input_format,
+                uint16_t dst_width, uint16_t dst_height, uint16_t output_format)
+{
+    int ret = 0;
+
+    src_size = input_size;
+
+    int circuit_no = PARAM_NO_YUV2RGB; 
+    uint8_t drp_yuv2rgb_param[PARAM_SIZE_YUV2RGB]; 
+
+    dst_size = dst_width * dst_height * 3;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+
+    dst_adr_64aligment();
+
+    /* set yuv2rgb drp rapameter to local variables */
+    *((uint32_t *)(&drp_yuv2rgb_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_yuv2rgb_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_yuv2rgb_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_yuv2rgb_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_yuv2rgb_param[12])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2rgb_param[14])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2rgb_param[16])) = dst_width; //output width(pixel)
+    *((uint16_t *)(&drp_yuv2rgb_param[18])) = dst_height;//output width(pixel)
+    *((uint16_t *)(&drp_yuv2rgb_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_yuv2rgb_param[22])) = 0;         //reserved(0)
+    memset( &drp_yuv2rgb_param[24],0,16);                //Not used(0)
+    *((uint16_t *)(&drp_yuv2rgb_param[40])) = 0;         //CPU ionterupt on (0 fixed)
+    memset( &drp_yuv2rgb_param[42],0,6);                 //reserved(0)
+    *((uint16_t *)(&drp_yuv2rgb_param[48])) = input_format;//input format
+    *((uint16_t *)(&drp_yuv2rgb_param[50])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_yuv2rgb_param[52])) = output_format;//output format
+    *((uint16_t *)(&drp_yuv2rgb_param[54])) = 0;         //reserved(0)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_YUV2RGB;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_yuv2rgb_param, PARAM_SIZE_RESIZE); // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    if ( ret != PARAM_SIZE_RESIZE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+    
+    return DRP_NORMAL_END;
+}
+
+/****************************************************************************
+* Method Name   : setYUV2NVParameter
+* Description   : to set YUV2nv parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  input_yuv = input yuv format, 
+                  output_nv = output nv
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+*****************************************************************************/
+int rzv2m_drp::setYUV2NVParameter(uint16_t src_width, uint16_t src_height, uint16_t input_yuv, uint16_t output_nv)
+{	
+    int ret = 0;
+
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+
+    src_size = src_width * src_height * 2;
+    dst_size = dst_width * dst_height * 3 / 2;
+
+    int circuit_no = PARAM_NO_YUV2NV; 
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    uint8_t drp_yuv2nv_param[PARAM_SIZE_YUV2NV12];   // define parameter area
+        
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+
+    dst_adr_64aligment();
+
+    /* set YUV2NV drp rapameter to local variables */
+    *((uint32_t *)(&drp_yuv2nv_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_yuv2nv_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_yuv2nv_param[8]))  = src_width; //src image width(pixel)
+    *((uint16_t *)(&drp_yuv2nv_param[10])) = src_height;//src image height(pixel)
+    *((uint16_t *)(&drp_yuv2nv_param[12])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[14])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[16])) = dst_width; //dst image width(pixel)
+    *((uint16_t *)(&drp_yuv2nv_param[18])) = dst_height;//dst image height(pixel)
+    *((uint16_t *)(&drp_yuv2nv_param[20])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[22])) = 0;         //reserved(0 fixed)
+    memset( &drp_yuv2nv_param[24],0,16);                //Not used
+    *((uint16_t *)(&drp_yuv2nv_param[40])) = 0;         //CPU interrupt enable(0 fixed)
+    memset( &drp_yuv2nv_param[42],0,6);                 //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[48])) = input_yuv; //input yuv format
+    *((uint16_t *)(&drp_yuv2nv_param[50])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_yuv2nv_param[52])) = output_nv; //output nv format
+    *((uint16_t *)(&drp_yuv2nv_param[54])) = 0;         //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_YUV2NV12;                          // 56byte
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);  // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        {
+            return DRP_PARAM_ERROR;
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_yuv2nv_param, PARAM_SIZE_YUV2NV12); // to write parameter to assigned address
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if ( ret != PARAM_SIZE_YUV2NV12)
+        {
+            return DRP_PARAM_ERROR; 
+        }
+
+    return DRP_NORMAL_END;	
+}
+
+/***************************************************************************
+* Method Name   : setGaussianParameter
+* Description   : to set Gaussian filter parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, kernel_size = kernel size 
+                  output_nv = output nv
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setGaussianParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t kernel_size)
+{
+    int ret = 0;
+
+    /* set dst image size same as src size */
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+    uint16_t dst_ch = src_ch;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    int circuit_no = PARAM_NO_GAUSSIAN; 
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    uint8_t drp_gaussian_param[PARAM_SIZE_GAUSSIAN];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+
+    dst_adr_64aligment();
+
+    /* set gaussian drp rapameter to local variables */
+    *((uint32_t *)(&drp_gaussian_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_gaussian_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_gaussian_param[8]))  = src_width; //src width(pixel)
+    *((uint16_t *)(&drp_gaussian_param[10])) = src_height;//src height(pixel)
+    *((uint16_t *)(&drp_gaussian_param[12])) = src_ch;    //src channel
+    *((uint16_t *)(&drp_gaussian_param[14])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[16])) = dst_width; //dst width(pixel)
+    *((uint16_t *)(&drp_gaussian_param[18])) = dst_height;//dst width(pixel)
+    *((uint16_t *)(&drp_gaussian_param[20])) = dst_ch;    //dst channel
+    *((uint16_t *)(&drp_gaussian_param[22])) = 0;         //reserved(0 fixed)
+    memset( &drp_gaussian_param[24],0,16);                //Not used(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[40])) = 0;         //CPU interrupt enable(0 fixed)
+    memset( &drp_gaussian_param[42],0,6);                 //reserved(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[48])) = kernel_size; //kernel size         
+    *((uint16_t *)(&drp_gaussian_param[50])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[52])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_gaussian_param[54])) = 0;         //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_GAUSSIAN;    // gaussian parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        { 
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_gaussian_param, PARAM_SIZE_GAUSSIAN); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (ret != PARAM_SIZE_GAUSSIAN)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+    
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setMorphologyParameter
+* Description   : to set Morphology(dilate,erode) filter parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, iterators = iterators size 
+                  border_type = border type, morph_circuit_no = dilate:5 erode:6
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setMorphologyParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t iterators,
+                uint16_t border_type, uint16_t border_value, uint16_t morph_circuit_no)
+{
+    int ret = 0;
+
+    /* set dst image size same as src size */
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+    uint16_t dst_ch = src_ch;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*morph_circuit_no]);     // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*morph_circuit_no + 4]);       // address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*morph_circuit_no + 8]);       // size of resize circuit
+    
+    uint8_t drp_morphology_param[PARAM_SIZE_MORPHOLOGY];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+
+    dst_adr_64aligment();
+
+    /* set morphology drp rapameter to local variables */
+    *((uint32_t *)(&drp_morphology_param[0]))  = src_adr;       //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_morphology_param[4]))  = dst_adr;       //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_morphology_param[8]))  = src_width;     //src width(pixel)
+    *((uint16_t *)(&drp_morphology_param[10])) = src_height;    //src height(pixel)
+    *((uint16_t *)(&drp_morphology_param[12])) = src_ch;        //reserved(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[14])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[16])) = dst_width;     //dst width(pixel)
+    *((uint16_t *)(&drp_morphology_param[18])) = dst_height;    //dst width(pixel)
+    *((uint16_t *)(&drp_morphology_param[20])) = dst_ch;        //reserved(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[22])) = 0;             //reserved(0 fixed)
+    memset( &drp_morphology_param[24],0,16);                    //Not used(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[40])) = 0;             //CPU interrupt enable(0 fixed)
+    memset( &drp_morphology_param[42],0,6);                     //reserved(0 fixed)
+    *((uint16_t *)(&drp_morphology_param[48])) = iterators;     //iterators count         
+    *((uint16_t *)(&drp_morphology_param[50])) = border_type;   //bordertype
+    *((uint16_t *)(&drp_morphology_param[52])) = border_value;  //bordervalue
+    *((uint16_t *)(&drp_morphology_param[54])) = 0;             //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_MORPHOLOGY;                          // gaussian parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        {
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_morphology_param, PARAM_SIZE_MORPHOLOGY); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if ( ret != PARAM_SIZE_MORPHOLOGY)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+    
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setSobelParameter
+* Description   : to set Sobel parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                : src_ch = src channels number, deltaXY = deltax, deltay value type 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setSobelParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t delataXY)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_SOBEL; // sobel circuit index
+    uint8_t drp_sobel_param[PARAM_SIZE_SOBEL]; 
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = src_size;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+
+    dst_adr_64aligment();
+                                       
+    /* set sobel drp rapameter to local variables */
+    *((uint32_t *)(&drp_sobel_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_sobel_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_sobel_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_sobel_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_sobel_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_sobel_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_sobel_param[16])) = src_width; //output width(pixel)
+    *((uint16_t *)(&drp_sobel_param[18])) = src_height;//output width(pixel)
+    *((uint16_t *)(&drp_sobel_param[20])) = src_ch;    //output channels
+    *((uint16_t *)(&drp_sobel_param[22])) = 0;         //reserved(0)
+    memset( &drp_sobel_param[24],0,16);                //Not used(0)
+    *((uint16_t *)(&drp_sobel_param[40])) = 0;         //CPU ionterupt on (0 fixed)
+    memset( &drp_sobel_param[42],0,6);                 //reserved(0 fixed)
+    *((uint16_t *)(&drp_sobel_param[48])) = delataXY;         //dx, dy
+    *((uint16_t *)(&drp_sobel_param[50])) = 0;         //reserved(0 fixed)
+    *((uint16_t *)(&drp_sobel_param[52])) = 0;         //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_SOBEL;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_sobel_param, PARAM_SIZE_SOBEL);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ( ret != PARAM_SIZE_RESIZE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setFilter2dParameter
+* Description   : to set Filter2d parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, filter = filter values
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setFilter2dParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, float* filter)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_FILTER2D; 
+
+    /* set dst image size same as src */
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+    uint16_t dst_ch = src_ch;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);     // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);       // address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);       // size of resize circuit
+    
+    uint8_t drp_filter2d_param[PARAM_SIZE_FILTER2D];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+
+    dst_adr_64aligment();
+
+    /* set filter2d drp rapameter to local variables */
+    *((uint32_t *)(&drp_filter2d_param[0]))  = src_adr;       //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_filter2d_param[4]))  = dst_adr;       //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_filter2d_param[8]))  = src_width;     //src width(pixel)
+    *((uint16_t *)(&drp_filter2d_param[10])) = src_height;    //src height(pixel)
+    *((uint16_t *)(&drp_filter2d_param[12])) = src_ch;        //src channel
+    *((uint16_t *)(&drp_filter2d_param[14])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_filter2d_param[16])) = dst_width;     //dst width(pixel)
+    *((uint16_t *)(&drp_filter2d_param[18])) = dst_height;    //dst width(pixel)
+    *((uint16_t *)(&drp_filter2d_param[20])) = dst_ch;        //dst channel
+    *((uint16_t *)(&drp_filter2d_param[22])) = 0;             //reserved(0 fixed)
+    memset( &drp_filter2d_param[24],0,16);                    //Not used(0 fixed)
+    *((uint16_t *)(&drp_filter2d_param[40])) = 0;             //CPU interrupt enable(0 fixed)
+    memset( &drp_filter2d_param[42],0,6);                     //reserved(0 fixed)
+
+    int param_idx = 48;
+
+    /* 3x3 kernel float value */
+    for(int cnt = 0; cnt < 9; cnt++)
+    {
+        *((float *)(&drp_filter2d_param[param_idx + (cnt * 4)])) = filter[cnt];
+    }
+
+    *((uint16_t *)(&drp_filter2d_param[84])) = 0;  //reserved(0 fixed)
+    *((uint16_t *)(&drp_filter2d_param[86])) = 0;  //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_FILTER2D;                          // filter2d parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        { 
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_filter2d_param, PARAM_SIZE_FILTER2D); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if ( ret != PARAM_SIZE_FILTER2D)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setAdaptiveThreshold
+* Description   : to set AdaptiveThreshold parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, max_value = max value condition is satisfied
+                  threshold_type = thresholding type, block_size = size of block size of pixel
+                  threshold_C = Constant substracted
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setAdaptiveThreshold(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t max_value, 
+                uint16_t threshold_type, uint32_t block_size, uint16_t threshold_C)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_ATHRESHOLD; 
+
+    /* set dst image size same as src size */
+    uint16_t dst_width = src_width;
+    uint16_t dst_height = src_height;
+    uint16_t dst_ch = src_ch;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);     // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);       // address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);       // size of resize circuit
+    
+    uint8_t drp_athreshold_param[PARAM_SIZE_ATHRESHOLD];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    dst_adr = src_adr + src_size; // next address to input image
+    tmpl_adr = NULL;    //for 40bit addr
+
+    dst_adr_64aligment();
+
+    /* set adaptive threshold drp rapameter to local variables */
+    *((uint32_t *)(&drp_athreshold_param[0]))  = src_adr;       //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_athreshold_param[4]))  = dst_adr;       //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_athreshold_param[8]))  = src_width;     //src width(pixel)
+    *((uint16_t *)(&drp_athreshold_param[10])) = src_height;    //src height(pixel)
+    *((uint16_t *)(&drp_athreshold_param[12])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[14])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[16])) = dst_width;     //dst width(pixel)
+    *((uint16_t *)(&drp_athreshold_param[18])) = dst_height;    //dst width(pixel)
+    *((uint16_t *)(&drp_athreshold_param[20])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[22])) = 0;             //reserved(0 fixed)
+    memset( &drp_athreshold_param[24],0,16);                    //Not used(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[40])) = 0;             //CPU interrupt enable(0 fixed)
+    memset( &drp_athreshold_param[42],0,6);                     //reserved(0 fixed)
+    *((uint16_t *)(&drp_athreshold_param[48])) = block_size;    //block size     
+    *((uint16_t *)(&drp_athreshold_param[50])) = max_value;     //max_value
+    *((uint16_t *)(&drp_athreshold_param[52])) = threshold_type;//threshold_type
+    *((uint16_t *)(&drp_athreshold_param[54])) = threshold_C;   //C
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_ATHRESHOLD;                          // athreshold parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        {
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_athreshold_param, PARAM_SIZE_ATHRESHOLD); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (ret != PARAM_SIZE_ATHRESHOLD)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+        
+    return DRP_NORMAL_END;
+}
+
+/***************************************************************************
+* Method Name   : setMatchTemplateParameter
+* Description   : to set MatchTemplate parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, 
+                  src_ch = src channels number, templ_addr = template data address
+                  templ_width = template width, templ_height = template height
+                  method = matching method 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int rzv2m_drp::setMatchTemplateParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                    uint16_t tmpl_width, uint16_t tmpl_height, uint16_t tmpl_ch, uint16_t method)
+{
+    int ret = 0;
+
+    int circuit_no = PARAM_NO_MATCHTEMPLATE; 
+
+    /* set dst image for result */
+    uint16_t dst_width = src_width - tmpl_width + 1;
+    uint16_t dst_height = src_height - tmpl_height + 1;
+    uint16_t dst_ch = 1;
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * dst_ch * 4; // 4 means 32 / 8 (depth)
+
+    tmpl_size = tmpl_width * tmpl_height * tmpl_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);     // existence flag of circuit data
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);       // address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);       // size of resize circuit
+    
+    uint8_t drp_matchTempl_param[PARAM_SIZE_MATCHTEMPLATE];
+        
+    /* to write drp parameters to memory area */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next address to drp parameter
+    tmpl_adr = src_adr + src_size; // next address to template
+
+    tmpl_adr_64aligment();
+	
+    dst_adr = tmpl_adr + tmpl_size; // next address to input image
+
+    dst_adr_64aligment();
+
+    /* set match template drp rapameter to local variables */
+    *((uint32_t *)(&drp_matchTempl_param[0]))  = src_adr;       //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_matchTempl_param[4]))  = dst_adr;       //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_matchTempl_param[8]))  = src_width;     //src width(pixel)
+    *((uint16_t *)(&drp_matchTempl_param[10])) = src_height;    //src height(pixel)
+    *((uint16_t *)(&drp_matchTempl_param[12])) = src_ch;        //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[14])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[16])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[18])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[20])) = 0;             //reserved(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[22])) = 0;             //reserved(0 fixed)
+    memset( &drp_matchTempl_param[24],0,16);                    //Not used(0 fixed)
+    *((uint16_t *)(&drp_matchTempl_param[40])) = 0;             //CPU interrupt enable(0 fixed)
+    memset( &drp_matchTempl_param[42],0,6);                     //reserved(0 fixed)
+    *((uint32_t *)(&drp_matchTempl_param[48])) = tmpl_adr;    //template data address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_matchTempl_param[52])) = tmpl_width;   //template image width
+    *((uint16_t *)(&drp_matchTempl_param[54])) = tmpl_height;  //template image height
+    *((uint16_t *)(&drp_matchTempl_param[56])) = method;        //matching medthod
+    memset(&drp_matchTempl_param[58],0,6);                     //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // assign pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_MATCHTEMPLATE;                          // match template parameter size
+    do
+        {
+            errno= 0;
+            ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to access memory area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((0 != ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (!((0 == ret) && (0 == errno)))
+        {
+            return DRP_PARAM_ERROR; 
+        }
+    do
+        {
+            errno= 0;
+            ret = write(fd_drp, drp_matchTempl_param, PARAM_SIZE_MATCHTEMPLATE); // to write parameter to assigned area
+        } while((-1 == ret) && (ERESTART == errno));
+
+        if ((-1 == ret) && (EACCES == errno))
+        {
+            conflict_action_exec();
+            return DRP_NOT_EXECUTE;
+        }
+
+        if (ret != PARAM_SIZE_MATCHTEMPLATE)
+        {
+            return DRP_PARAM_ERROR;   
+        }
+    
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : setMatchTempl
+* Description   : to set match template image to drp input area
+* Arguments     : templData = template image data area
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_SRC_IMAGE_ERROR otherwise
+******************************************/
+ int rzv2m_drp::setMatchTempl(uint8_t *templData)
+ {
+    int ret = 0;
+
+    drp_data_t tmpl_img;
+    tmpl_img.address = tmpl_adr;          // physical memory address of input image area
+    tmpl_img.size = tmpl_size;            // input image size
+    
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &tmpl_img);
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+
+    do
+    {
+         errno= 0;
+        ret = write(fd_drp, templData, tmpl_size);
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ((uint32_t)ret != tmpl_size)
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+    
+    return DRP_NORMAL_END;
+ }
+
+/**************************************************************************************************************
+* Method Name   : setWarpAffineParameter
+* Description   : to set resize parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dst_width = dst image width, dst_height = dst image height, toransform_matrix = toransformation matrix,
+                  border_value = border line color value
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setWarpAffineParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, float* transform_matrix, uint32_t border_value)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_WARPAFFINE; // resize circuit index
+    uint8_t drp_warpaffine_param[PARAM_SIZE_WARPAFFINE];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * src_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    
+    dst_adr_64aligment();
+                            
+    /* set affine drp rapameter to local variables */
+    *((uint32_t *)(&drp_warpaffine_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_warpaffine_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_warpaffine_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_warpaffine_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_warpaffine_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_warpaffine_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_warpaffine_param[16])) = dst_width; //output width(pixel)
+    *((uint16_t *)(&drp_warpaffine_param[18])) = dst_height;//output width(pixel)
+    *((uint16_t *)(&drp_warpaffine_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_warpaffine_param[22])) = 0;         //reserved(0)
+    memset(&drp_warpaffine_param[24],0,16);                 //Not used(0)
+    *((uint16_t *)(&drp_warpaffine_param[40])) = 0;         //CPU interupt on (0 fixed)   
+    memset(&drp_warpaffine_param[42],0,6);                  //reserved(0 fixed)
+    *((uint32_t *)(&drp_warpaffine_param[48])) = border_value;        //border_value is default o
+   
+    *((float *)(&drp_warpaffine_param[52])) = transform_matrix[0];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[56])) = transform_matrix[1];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[60])) = transform_matrix[2];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[64])) = transform_matrix[3];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[68])) = transform_matrix[4];    //transformation matrix
+    *((float *)(&drp_warpaffine_param[72])) = transform_matrix[5];    //transformation matrix
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_WARPAFFINE;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_warpaffine_param, PARAM_SIZE_WARPAFFINE);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_WARPAFFINE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setPyrDownParameter
+* Description   : to set pyrDown() parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dsize_width = output image width, dsize_height = output image height,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setPyrDownParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dsize_width, uint16_t dsize_height)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_PYRDOWN; // resize circuit index
+    uint8_t drp_pyrdown_param[PARAM_SIZE_PYRDOWN];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dsize_width * dsize_height * src_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    
+    dst_adr_64aligment();
+                            
+    /* set pyrdown drp rapameter to local variables */
+    *((uint32_t *)(&drp_pyrdown_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_pyrdown_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_pyrdown_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_pyrdown_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_pyrdown_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_pyrdown_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_pyrdown_param[16])) = dsize_width; //output width(pixel)
+    *((uint16_t *)(&drp_pyrdown_param[18])) = dsize_height;//output width(pixel)
+    *((uint16_t *)(&drp_pyrdown_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_pyrdown_param[22])) = 0;         //reserved(0)
+    memset(&drp_pyrdown_param[24],0,16);                 //Not used(0)
+    *((uint16_t *)(&drp_pyrdown_param[40])) = 0;         //CPU interupt on (0 fixed)   
+    memset(&drp_pyrdown_param[42],0,6);                  //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_PYRDOWN;// size of param (48 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_pyrdown_param, PARAM_SIZE_PYRDOWN);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_PYRDOWN)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setPyrUpParameter
+* Description   : to set pyrUp() parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dsize_width = output image width, dsize_height = output image height
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setPyrUpParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dsize_width, uint16_t dsize_height)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_PYRUP; // resize circuit index
+    uint8_t drp_pyrup_param[PARAM_SIZE_PYRUP];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dsize_width * dsize_height * src_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    
+    dst_adr_64aligment();
+                            
+    /* set pyrup drp rapameter to local variables */
+    *((uint32_t *)(&drp_pyrup_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_pyrup_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_pyrup_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_pyrup_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_pyrup_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_pyrup_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_pyrup_param[16])) = dsize_width; //output width(pixel)
+    *((uint16_t *)(&drp_pyrup_param[18])) = dsize_height;//output width(pixel)
+    *((uint16_t *)(&drp_pyrup_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_pyrup_param[22])) = 0;         //reserved(0)
+    memset(&drp_pyrup_param[24],0,16);                 //Not used(0)
+    *((uint16_t *)(&drp_pyrup_param[40])) = 0;         //CPU interupt on (0 fixed)   
+    memset(&drp_pyrup_param[42],0,6);                  //reserved(0 fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_PYRUP;// size of param (48 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_pyrup_param, PARAM_SIZE_PYRUP);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_PYRUP)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setWarpPerspectiveParameter
+* Description   : to set warpPerspective() parameter to drp
+* Arguments     : src_width = src image width, src_height = src image height, src_ch = src image channels,
+                  dst_width = output image width, dst_height = output image height,
+                  toransform_matrix = toransformation matrix(3x3), border_value = border line color value
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setWarpPerspectiveParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch,
+                uint16_t dst_width, uint16_t dst_height, float* transform_matrix, uint32_t border_value)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_WARPPERSPECTIVE; // resize circuit index
+    uint8_t drp_perspective_param[PARAM_SIZE_WARPPERSPECTIVE];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = dst_width * dst_height * src_ch;
+
+    possiblef     = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no]);    // existence flag of circuit data 
+    drp_position  = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 4]);// address at circuit data (offset value from CONFIG_BASE)
+    drp_size      = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32*circuit_no + 8]);// size of resize circuit
+    
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE;  // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+    
+    dst_adr_64aligment();
+                            
+    /* set perspective drp rapameter to local variables */
+    *((uint32_t *)(&drp_perspective_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_perspective_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_perspective_param[8]))  = src_width; //input width(pixel)
+    *((uint16_t *)(&drp_perspective_param[10])) = src_height;//input height(pixel)
+    *((uint16_t *)(&drp_perspective_param[12])) = src_ch;    //input channels
+    *((uint16_t *)(&drp_perspective_param[14])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_perspective_param[16])) = dst_width; //output width(pixel)
+    *((uint16_t *)(&drp_perspective_param[18])) = dst_height;//output width(pixel)
+    *((uint16_t *)(&drp_perspective_param[20])) = 0;         //reserved(0)
+    *((uint16_t *)(&drp_perspective_param[22])) = 0;         //reserved(0)
+    memset(&drp_perspective_param[24],0,16);                 //Not used(0)
+    *((uint16_t *)(&drp_perspective_param[40])) = 0;         //CPU interupt on (0 fixed)   
+    memset(&drp_perspective_param[42],0,6);                  //reserved(0 fixed)
+    *((uint32_t *)(&drp_perspective_param[48])) = border_value;        //border_value
+   
+    int param_idx = 52;
+    for(int idx = 0; idx<9; idx++) // 9 elements
+    {
+        *((float *)(&drp_perspective_param[param_idx])) = transform_matrix[idx]; //transformation matrix
+        param_idx += 4;
+    }
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy  + opencv_bin_param_base;   // pysical address 
+    proc[DRPPARAM1].size = PARAM_SIZE_WARPPERSPECTIVE;// size of param (56 byte)
+                               
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]);   // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, drp_perspective_param, PARAM_SIZE_WARPPERSPECTIVE);  // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_WARPPERSPECTIVE)
+    {
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/**************************************************************************************************************
+* Method Name   : setFastParameter
+* Description   : to set FAST parameter to drp
+* Arguments     : src_width = src image width,
+                  src_height = src image height,
+                  src_ch = src image channels,
+                  threshold = threshold
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+***************************************************************************************************************/
+int rzv2m_drp::setFastParameter(uint16_t src_width, uint16_t src_height, uint16_t src_ch, uint16_t threshold)
+{
+    int ret = 0;
+    int circuit_no = PARAM_NO_FAST; // FAST circuit index
+    uint8_t drp_fast_param[PARAM_SIZE_FAST];
+
+    src_size = src_width * src_height * src_ch;
+    dst_size = (src_width + 2) * (src_height + 2) / 9 * 64;   //MAX dst size:(3842x2162*64)/9 = about 56.3MByte
+
+    possiblef = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no]);        // existence flag of circuit data
+    drp_position = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no + 4]); // address at circuit data (offset value from CONFIG_BASE)
+    drp_size = *(uint32_t *)(&opencv_bin_p[opencv_bin_list_base + 32 * circuit_no + 8]);     // size of FAST circuit
+
+    /*  calculate address value of input image and output image */
+    src_adr = opencv_bin_addr64_phy + opencv_bin_param_base + DRP_PARAM_SIZE; // next to DRP parameter area
+    dst_adr = src_adr + src_size;
+    tmpl_adr = NULL;    //for 40bit addr
+ 
+    dst_adr_64aligment();
+
+    /* set FAST drp rapameter to local variables */
+    *((uint32_t *)(&drp_fast_param[0]))  = src_adr;   //src image address   (for 40bit addr, irrelevant to V2H)
+    *((uint32_t *)(&drp_fast_param[4]))  = dst_adr;   //dst image address   (for 40bit addr, irrelevant to V2H)
+    *((uint16_t *)(&drp_fast_param[8])) = src_width;   // input width (pixel)
+    *((uint16_t *)(&drp_fast_param[10])) = src_height; // input height (pixel)
+    *((uint16_t *)(&drp_fast_param[12])) = 1;          // input channels (1 fixed)
+    *((uint16_t *)(&drp_fast_param[14])) = 0;          // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[16])) = 0;          // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[18])) = 0;          // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[20])) = 0;          // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[22])) = 0;          // reserved (0 fixed)
+    memset(&drp_fast_param[24], 0, 16);                // Not used (0 fixed)
+    *((uint16_t *)(&drp_fast_param[40])) = 0;          // CPU ionterupt on (0 fixed)
+    memset(&drp_fast_param[42], 0, 6);                 // reserved (0 fixed)
+    *((uint16_t *)(&drp_fast_param[48])) = threshold;  // threshold
+    *((uint16_t *)(&drp_fast_param[50])) = 0x00FF;     // reserved (0x00FF fixed)
+
+    /* to write drp parameters to memory area */
+    proc[DRPPARAM1].address = opencv_bin_addr64_phy + opencv_bin_param_base; // pysical address
+    proc[DRPPARAM1].size = PARAM_SIZE_FAST;                                  // size of param (56 byte)
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &proc[DRPPARAM1]); // to assign to drp area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        fprintf(stderr, "[ERROR] Failed to assign DRP parameter11111\n");
+
+        return DRP_PARAM_ERROR;
+    }
+
+    do
+    {
+        errno = 0;
+        ret = write(fd_drp, drp_fast_param, PARAM_SIZE_FAST); // to write parameter to specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (ret != PARAM_SIZE_FAST)
+    {
+        fprintf(stderr, "[ERROR] Failed to write DRP parameter\n");
+        return DRP_PARAM_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : setSrcImage
+* Description   : to set src image to drp input area
+* Arguments     : img-_buffer = src image data area
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_SRC_IMAGE_ERROR otherwise
+******************************************/
+int rzv2m_drp::setSrcImage(uint8_t *img_buffer)
+{
+    int ret = 0;
+
+    drp_data_t src_img;
+    src_img.address = src_adr;          // physical memory address of input image area
+    src_img.size = src_size;            // input image size
+    
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &src_img);
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+
+    do
+    {
+        errno= 0;
+        ret = write(fd_drp, img_buffer, src_size);
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if ((uint32_t)ret != src_size)
+    {
+        return DRP_SRC_IMAGE_ERROR;
+    }
+    
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : execDRP
+* Description   : executing drp process
+* Arguments     : void
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_EXEC_ERROR otherwise
+******************************************/
+int rzv2m_drp::execDRP(void)
+{
+    int ret = 0;
+    drp_seq_t seq;
+  
+    /* to write drp parameters to memory area */
+    proc[DRPCFG1].address = opencv_bin_addr64_phy + opencv_bin_config_base + drp_position;  // pysical address
+    proc[DRPCFG1].size    = drp_size;                                               // data size
+
+    seq.num         = DRPCFG_NUM;
+
+#ifdef DEV_RZV2H   // for 40bit addr
+    seq.order[0]    = DRP_EXE_DRP_40BIT;
+#else
+    seq.order[0]    = DRP_EXE_DRP;
+#endif
+    seq.address     = opencv_bin_addr64_phy + opencv_bin_descriptor_base;           // descriptor base
+
+#ifdef DEV_RZV2H  // for 40bit addr
+    seq.iodata[0].address = src_adr;
+    seq.iodata[0].size    = src_size;
+    seq.iodata[0].pos     = 0;
+    seq.iodata[1].address = dst_adr;
+    seq.iodata[1].size    = dst_size;
+    seq.iodata[1].pos     = 4;
+    
+    if( tmpl_adr == NULL )
+    {
+        seq.iodata_num          = 2;
+    }
+    else
+    {
+        seq.iodata_num          = 3;    //Template matching
+        seq.iodata[2].address   = tmpl_adr;
+        seq.iodata[2].size      = tmpl_size;
+        seq.iodata[2].pos       = 48;
+    }
+    
+#endif
+    
+    ret = ioctl(fd_drp, DRP_SET_SEQ, &seq);                                         // to set seq data
+
+    if ((0 != ret) && (EBUSY == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (0 != ret || (0 != errno) )
+    {
+        return DRP_EXEC_ERROR;
+    }
+
+    /* to start drp process */  
+    ret = ioctl(fd_drp, DRP_START, proc);
+
+    if ((0 != ret) && (EBUSY == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (0 != ret || (0 != errno) )
+    {
+        return DRP_EXEC_ERROR;
+    }
+    
+    /* waiting finish */
+    
+    fd_set rfds;
+    FD_ZERO(&rfds);
+    FD_SET(fd_drp, &rfds);
+    struct timeval tv;
+    tv.tv_sec = DRP_EXEC_TIMEOUT_SECONDS;
+    tv.tv_usec = 0;
+
+    ret = select(fd_drp + 1, &rfds, NULL, NULL, &tv);
+
+    if (0 == ret)
+    {
+        return DRP_EXEC_ERROR;
+    }
+    else if (-1 == ret)
+    {
+        return DRP_EXEC_ERROR;
+    }
+
+    /* to check result */
+    
+    drp_status_t drp_status;
+    ret = ioctl(fd_drp, DRP_GET_STATUS, &drp_status);
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!(((0 == ret) || (EBUSY == errno)) && (0 == drp_status.err)))
+    {
+        return DRP_EXEC_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : readTemplaeMatchResult
+* Description   : to read dst image from drp output area
+* Arguments     : dst_img_buffer = dst image buffer 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_DST_IMAGE_ERROR otherwise
+******************************************/
+int rzv2m_drp::readTemplateMatchResult(uint8_t *dst_image_buffer)
+{
+    int ret = 0;
+
+    drp_data_t dst_img;
+    dst_img.address = dst_adr;    // pysical address to dst image data
+    dst_img.size = dst_size;      // dst image size
+
+    do
+    {
+        errno= 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &dst_img); // assign to DRP memory area
+    } while ((-1 == ret) && (ERESTART == errno));
+        
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    {
+        errno= 0;
+        ret = read(fd_drp, dst_image_buffer, dst_size);   // to read dst image from specified address
+    } while ((-1 == ret) && (ERESTART == errno));
+    
+    if ((-1 == ret) && (EACCES == errno))
+    {
+         conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (dst_size != (uint32_t)ret)
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : dst_adr_64aligment()
+* Description   : calc 64 bit aligment address
+* Arguments     : none
+* Return value  : void
+******************************************/
+void rzv2m_drp::dst_adr_64aligment()
+{
+    /* 64bit aligment */
+    uint32_t align = 0;
+
+    align = 64 - (dst_adr % 64);
+    dst_adr = dst_adr + align; 
+
+    return;
+}
+
+/*****************************************
+* Method Name   : tmpl_adr_64aligment()
+* Description   : calc 64 bit aligment address
+* Arguments     : none
+* Return value  : void
+******************************************/
+void rzv2m_drp::tmpl_adr_64aligment()
+{
+    /* 64bit aligment */
+    uint32_t align = 0;
+
+    align = 64 - (tmpl_adr % 64);
+    tmpl_adr = tmpl_adr + align; 
+
+    return;
+}
+
+/*****************************************
+* Method Name   : readDstImage
+* Description   : to read dst image from drp output area
+* Arguments     : img_buffer = dst image buffer 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_DST_IMAGE_ERROR otherwise
+******************************************/
+int rzv2m_drp::readDstImage(uint8_t *dst_image_buffer)
+{
+    int ret = 0;
+    drp_data_t dst_img;
+
+    dst_img.address = dst_adr;    // pysical address to dst image data
+    dst_img.size = dst_size;      // dst image size
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &dst_img); // assign to DRP memory area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    {
+        errno = 0;
+        ret = read(fd_drp, dst_image_buffer, dst_size); // to read dst image from specified address
+    }
+    while ((-1 == ret) && (ERESTART == errno))
+        ;
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (dst_size != (uint32_t)ret)
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+ * Method Name   : readCornerPoints
+ * Description   : Read corner points and their scores from drp output area
+ * Arguments     : std::vector<cv::KeyPoint> &keypoints
+ * Return value  : DRP_NORMAL_END if succeeded
+ *                 DRP_DST_IMAGE_ERROR otherwise
+ ******************************************/
+int rzv2m_drp::readCornerPoints(std::vector<cv::KeyPoint> &keypoints)
+{
+    /*
+    This function sends the FAST result on DRP to CPU.
+    To do that, we first obtain the number of corners, which deterimines the buffer size for FAST corners, from DRP memory.
+    Then we copy FAST corners and their scores into the buffer whose size is given by,
+    64 bit + 64 bit * number of corners,
+    the 1st conponent stands for the baffer size of the number of corners and 0-padding region, and the 2nd does for that of corners and their scores.
+    In other words, we copy both number of corners and each FAST corner information into the buffer.
+    Finally, we send FAST corners and their scores in the buffer to Keypoints list on CPU with rearrangement.
+    */
+    // 1. Number of corners
+    int ret = 0;
+    drp_data_t dst_corner;
+
+    dst_corner.address = dst_adr; // pysical address to dst corner data
+    dst_corner.size = 8;          // buffer size for number of corners (64 bit = number of corners and 0-padding region)
+
+    uint32_t out_count_buffer[2]; // 0-th component is corner number (32 bit) and  1st one is 0-padding region (32 bit)
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &dst_corner); // assign to DRP memory area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    {
+        errno = 0;
+        ret = read(fd_drp, out_count_buffer, dst_corner.size); // read number of corners from specified address
+    } 
+    while((-1 == ret) && (ERESTART == errno));
+        
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (dst_corner.size != (uint32_t)ret)
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    int count = out_count_buffer[0]; // Number of corners
+
+    if (count == 0)
+    {
+        return DRP_NORMAL_END;
+    }
+
+    // 2. Keypoints and their scores
+    ret = 0;
+
+    dst_corner.size = 8 * (count + 1); // 64 bit (coner number + zero-padding) + 64 bit * nubmer of corners
+
+    do
+    {
+        errno = 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &dst_corner); // assign to DRP memory area
+    } while ((-1 == ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    if (!((0 == ret) && (0 == errno)))
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+    /*
+    Buffer for corners
+    0th component: X coordinate (16 bit)
+    1st component: Y coordinate (16 bit)
+    2nd conponent: Score  (16 bit)
+    3rd component: 0-padding (16 bit)
+    */
+    uint16_t out_corner_buffer[4 * FAST_READ_BUFFER_SIZE];
+
+    int read_size;
+    int read_residual = count;
+
+    // Copy into Keypoint list
+    keypoints.clear();                  // Initialization
+    cv::KeyPoint kpt(0, 0, 7.f, -1, 0); // Define the same format as cv::KeyPoint in CPU case (see definition in hal_FAST)
+
+    for (int idx = 0; read_residual > 0; idx++)
+    {
+        if (read_residual >= FAST_READ_BUFFER_SIZE)
+        {
+            read_size = FAST_READ_BUFFER_SIZE;
+        }
+        else
+        {
+            read_size = read_residual;
+            if (idx == 0)
+            {
+                read_size = read_size + 1;
+            }
+        }
+
+    {
+        errno= 0;
+            ret = read(fd_drp, &out_corner_buffer[0], sizeof(uint16_t) * 4 * read_size); // read corners from specified address
+    }
+    while((-1 == ret) && (ERESTART == errno));
+
+    if ((-1 == ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+        if (sizeof(uint16_t) * 4 * read_size != (uint32_t)ret)
+    {
+        return DRP_DST_IMAGE_ERROR;
+    }
+
+        // Add result to kypoint from buffer
+        // 0th component of count corresponds to corner number and 0-padding region and
+        // i-th component (i = 1, 2, 3, ...) does to i-th corner and score.
+        int i_kpt = 0;
+        if (idx == 0)
+        {
+            i_kpt = 1;
+        }
+
+        for (i_kpt; i_kpt < read_size; i_kpt++)
+        {
+            // X coordinate
+            kpt.pt.x = (float)out_corner_buffer[0 + (i_kpt * 4)];
+
+            // Y coordinate
+            kpt.pt.y = (float)out_corner_buffer[1 + (i_kpt * 4)];
+
+            // Score
+            kpt.response = (float)out_corner_buffer[2 + (i_kpt * 4)];
+
+            // add result (corner position and its score) to keypoints list
+            keypoints.push_back(kpt);
+        }
+
+        read_residual = read_residual - read_size;
+
+        if ((idx == 0) && (read_residual > 0))
+        {
+            read_residual = read_residual + 1;
+        }
+    }
+
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : set_drp_end()
+* Description   : reset to OpenCVA inprocess
+* Arguments     :  
+* Return value  : =0:reset ok, <0: reset error 
+******************************************/
+int rzv2m_drp::set_drp_end()
+{
+#if 0
+    struct drp_proces_thread_id drp_proc_info;
+    int ret_ioctl = 0;
+    
+    drp_proc_info.process_id = process_id;
+    drp_proc_info.thread_id = thread_id;
+
+    ret_ioctl = ioctl(fd_drv, IO_CTL_DRP_END, &drp_proc_info);
+
+    if (ret_ioctl < 0)
+    {
+        return DRP_CONFLICT_ERROR;
+    }
+
+    if (ret_ioctl == 0)
+    {
+        CV_LOG_INFO(nullptr, "drp in process reset.");
+    }
+#endif
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : set_drp_start()
+* Description   : set to OpenCVA inprocess
+* Arguments     :  
+* Return value  : =0:set ok, <0: set error 
+******************************************/
+int rzv2m_drp::set_drp_start()
+{
+#if 0
+    struct drp_proces_thread_id drp_proc_info;
+    pid_t pid;
+	std::stringstream str_strm;
+    int ret_ioctl = 0;
+
+	pid = getpid(); 
+	process_id = (uint32_t)pid;
+
+    str_strm << std::this_thread::get_id();
+    thread_id = std::stoul(str_strm.str());
+    
+    drp_proc_info.process_id = process_id;
+    drp_proc_info.thread_id = thread_id;
+
+    ret_ioctl = ioctl(fd_drv, IO_CTL_DRP_START, &drp_proc_info);
+
+    if (ret_ioctl == IO_CTL_DRP_CONFLICT)
+    {
+        conflict_action_exec();
+        return DRP_CONFLICT_ERROR;
+    }
+
+    if (ret_ioctl == 0)
+    {
+        CV_LOG_INFO(nullptr, "drp in process set.");
+    }
+#endif
+    return DRP_NORMAL_END;
+}
+
+/*****************************************
+* Method Name   : initialize
+* Description   : initializing device driver 
+* Arguments     : void  
+* Return value  : void
+******************************************/
+void rzv2m_drp::initialize(void)
+{
+    fd_drv = 0;
+    int ret = 0;
+    drp_data_t local_drp_data;
+
+#if 0
+    /* opencva driver open */
+    if ((fd_drv = open(DRV_DEV_NAME, O_RDWR)) < 0) 
+    {
+        return;
+    }
+#endif
+
+#if 0
+    /* to read 32bit physical address */
+    if (ioctl(fd_drv, 0, &opencv_bin_addr32_phy) < 0)
+    {
+        return;
+    } 
+#endif
+
+    /* to open DRP(B) driver */
+    fd_drp = open(DRP_DEV_NAME, O_RDWR);
+    if (0 > fd_drp)
+    {
+        return;
+    }
+
+    /* to read 64bit physical address from DRP driver */
+    if (ioctl(fd_drp, DRP_GET_OPENCVA_AREA, &local_drp_data) < 0)
+    {
+        return;
+    } 
+    opencv_bin_addr64_phy = local_drp_data.address;
+
+    /* read opencva binary data */
+    drp_data_t opencvbin;
+    uint32_t bin_size = OCA_BIN_SIZE;
+
+    opencvbin.address = opencv_bin_addr64_phy;           
+    opencvbin.size = bin_size;                            
+    
+    do
+    {
+        /* assign */
+        errno= 0;
+        ret = ioctl(fd_drp, DRP_ASSIGN, &opencvbin);
+    } while((-1 == (int)ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return;
+    }
+
+    if (!((0 == (int)ret) && (0 == errno)))
+    {
+        return;
+    }
+
+    do
+    {
+        errno= 0;
+        /* exec read */
+        ret = read(fd_drp, opencv_bin_p, bin_size);      
+    } while((-1 == (int)ret) && (ERESTART == errno));
+
+    if ((0 != ret) && (EACCES == errno))
+    {
+        conflict_action_exec();
+        return;
+    }
+
+    if (ret != (int)bin_size)
+    {
+        return ;
+    }
+ 
+    /* reading opencv binary haeader part */
+    opencv_bin_signature_p      = (char *)(&opencv_bin_p[0]);           // pointer to signature(16byte)
+    opencv_bin_version_p        = (char *)(&opencv_bin_p[16]);          // pointer to version info(8byte)
+    opencv_bin_list_base        = *(uint32_t *)(&opencv_bin_p[24]);     // opencva list address(offset value)
+    opencv_bin_config_base      = *(uint32_t *)(&opencv_bin_p[28]);     // opencva circuit info address(offset value)
+    opencv_bin_descriptor_base  = *(uint32_t *)(&opencv_bin_p[32]);     // opencva descriptor info address(offset value)
+    opencv_bin_param_base       = *(uint32_t *)(&opencv_bin_p[36]);     // opencva parameter info address(offset value)
+
+    if(strcmp(opencv_bin_signature_p, OCABIN_SIGNATURE) != 0)
+    {
+        return;
+    }
+
+    if(memcmp(opencv_bin_version_p, OCABIN_MAJOR_VER, strlen(OCABIN_MAJOR_VER) ) != 0)
+    {
+        return;
+    }
+
+    /* set initialized complete */
+    initialized = true;
+
+    return;
+}
+
+/*****************************************
+* Method Name   : ~rzv2m_drp
+* Description   : Destructor
+******************************************/
+rzv2m_drp::~rzv2m_drp()
+{
+    close(fd_drp);
+}
\ 
diff -uprN old/modules/imgproc/src/smooth.dispatch.cpp new/modules/imgproc/src/smooth.dispatch.cpp
--- old/modules/imgproc/src/smooth.dispatch.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/smooth.dispatch.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -53,6 +53,7 @@
 #include "filter.hpp"
 
 #include "opencv2/core/softfloat.hpp"
+#include "opencv2/core/utils/logger.hpp"
 
 namespace cv {
 #include "fixedpoint.inl.hpp"
@@ -61,6 +62,17 @@ namespace cv {
 #include "smooth.simd.hpp"
 #include "smooth.simd_declarations.hpp" // defines CV_CPU_DISPATCH_MODES_ALL=AVX2,...,BASELINE based on CMakeLists.txt content
 
+#include <iostream>
+#include <rzv2ma_drp.h>
+
+
+#include <unistd.h>
+
+
+
+
+
+
 namespace cv {
 
 /****************************************************************************************\
@@ -477,16 +489,296 @@ static bool ipp_GaussianBlur(InputArray
 }
 #endif
 
+/***********************************************************
+* Method Name   : GaussianBlur_drp
+* Description   : to execute GaussianBlur_drp
+* Arguments     : src_mat = input Mat object, dst_mat = output Mat object
+*               : ksize = kernel size 
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+************************************************************/
+int GaussianBlur_drp(Mat src_mat, Mat dst_mat, Size ksize, double sigma1, double sigma2, int borderType)
+{
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+
+     /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_GAUSSIAN);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    CV_LOG_INFO(nullprt, "GaussianBlur_drp start.");
+
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    /* to check can exec condition */
+    /* If channel = 1, src width >= 16 and src width < 3840 */
+    if(1 == src_mat.channels())
+    {
+        if(3840 < src_width || 16 > src_width)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+    /* If channel != 1, src width >= 16, src width < 3840, and src width = Even */
+    else
+    {
+        if(3840 < src_width || 16 > src_width || 1 == src_width % 2)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    /* If channel = 1, src height >= 16 and src height < 2160 */
+    if(1 == src_mat.channels())
+    {
+        if(2160 < src_height || 16 > src_height)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+    /* If channel != 1, src height >= 16, src height < 2160, and src height = Even */
+    else
+    {
+        if(2160 < src_height || 16 > src_height || 1 == src_height % 2)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+
+    /* src image size */
+    if(3840*2160 < src_width*src_height)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* when dst cols != 0 */
+    if(0 != dst_mat.cols)
+    {
+        /* If channel = 1, dst width >= 16 */ 
+        if(1 == src_mat.channels())
+        {
+           if(16 > dst_mat.cols)
+            {
+                return DRP_NOT_EXECUTE;
+            } 
+        }
+        /* If channel != 1, dst width >= 16 and dst width = Even */ 
+        else
+        {
+            if(16 > dst_mat.cols || 1 == dst_mat.cols % 2)
+            {
+                return DRP_NOT_EXECUTE;
+            }
+        }
+          
+        /* src width = dst width*/
+        if(src_width != (uint32_t)dst_mat.cols)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    /* when dst rows != 0 */
+    if(0 != dst_mat.rows)
+    {
+        /* If channel = 1, dst width >= 16 */ 
+        if(1 == src_mat.channels())
+        {
+            if(16 > dst_mat.rows)
+            {
+                return DRP_NOT_EXECUTE;
+            } 
+        }
+        /* If channel != 1, dst width >= 16 and dst width = Even*/ 
+        else
+        {
+            if(16 > dst_mat.rows || 1 == dst_mat.rows % 2)
+            {
+                return DRP_NOT_EXECUTE;
+            }
+        }
+
+        /* src height = dst height */
+        if(src_width != (uint32_t)dst_mat.cols)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    /* dst image size */
+    if(3840*2160 < dst_mat.cols*dst_mat.rows)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if(1 > src_mat.channels() || 4 < src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(src_mat.channels() != dst_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if(CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;   
+    }
+
+    /* check kernel size */
+    if( !((3 == ksize.width && 3 == ksize.height) ||
+           (5 == ksize.width && 5 == ksize.height) ||
+           (7 == ksize.width && 7 == ksize.height)) ) 
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* check sigma-x sigma-y */
+    /* If channel = 1 and (ksize.width, ksize.height) = (7,7), (sigma-x, sigma-y) = (0, 0) or (2, 2) */ 
+    if((1 == src_mat.channels()) && (7 == ksize.width && 7 == ksize.height))
+    {
+        if(!(( 0.0 == sigma1 && 0.0 == sigma2) || ( 2.0 == sigma1 && 2.0 == sigma2)))
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+    /* Otherwise, (sigma-x, sigma-y) = (0, 0) */
+    else
+    {
+        if( 0.0 != sigma1 || 0.0 != sigma2)
+        {
+            return DRP_NOT_EXECUTE;
+        }
+    }
+
+    /* bordertype */
+    if((BORDER_DEFAULT != borderType) || (BORDER_REFLECT_101 != borderType))
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* start drp process */
+    int result = DRP_NORMAL_END;
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    /* set in process flag */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        drp->conflict_action_exec();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    uint16_t kernel_size;
+    kernel_size = ksize.width;
+
+    /* to set resize parameter */
+    result = drp->setGaussianParameter(src_width, src_height, src_ch, kernel_size);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+    
+    result = drp->setSrcImage(src_mat.data);
+
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if(DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(dst_height, dst_width, src_mat.type(), out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullprt, "GaussianBlur_drp end.");
+
+    drp->set_drp_end();
+  
+    /* return normal end */
+    return result;
+}
+
 void GaussianBlur(InputArray _src, OutputArray _dst, Size ksize,
                   double sigma1, double sigma2,
                   int borderType)
 {
     CV_INSTRUMENT_REGION();
+    
+    /* exec drp function */
+    int ret_drp = DRP_NORMAL_END;
 
+    /* it is nesessary to create dst mat object. */
     int type = _src.type();
     Size size = _src.size();
     _dst.create( size, type );
 
+    /* convert to mat object (it needs to do after dst created.)*/
+    Mat src_mat_drp = _src.getMat();
+    Mat dst_mat_drp = _dst.getMat();
+
+    ret_drp = GaussianBlur_drp(src_mat_drp, dst_mat_drp, ksize, sigma1, sigma2, borderType);    
+    Mat dst_mat_out =  Mat(src_mat_drp.rows, src_mat_drp.cols, src_mat_drp.type(), dst_mat_drp.data);
+    dst_mat_out.copyTo(_dst);
+
+    if(DRP_NORMAL_END == ret_drp)
+    {
+        return;
+    }
+
+    /* following to exec normal OpenCV function */
+    /* it needs created dst mat object. */
+    CV_LOG_INFO(nullprt, "GaussianBlur opencv normal process.");
+
     if( (borderType & ~BORDER_ISOLATED) != BORDER_CONSTANT &&
         ((borderType & BORDER_ISOLATED) != 0 || !_src.getMat().isSubmatrix()) )
     {
@@ -579,4 +871,4 @@ cvSmooth( const void* srcarr, void* dsta
         CV_Error( CV_StsUnmatchedFormats, "The destination image does not have the proper type" );
 }
 
-/* End of file. */
+/* End of file. */
\ 
diff -uprN old/modules/imgproc/src/templmatch.cpp new/modules/imgproc/src/templmatch.cpp
--- old/modules/imgproc/src/templmatch.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/templmatch.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -42,6 +42,9 @@
 #include "precomp.hpp"
 #include "opencl_kernels_imgproc.hpp"
 
+#include <rzv2ma_drp.h>
+#include <opencv2/core/utils/logger.hpp>
+
 ////////////////////////////////////////////////// matchTemplate //////////////////////////////////////////////////////////
 
 namespace cv
@@ -1092,6 +1095,177 @@ static bool ipp_matchTemplate( Mat& img,
 
 ////////////////////////////////////////////////////////////////////////////////////////////////////////
 
+/*****************************************
+* Method Name   : matchTemplate_drp
+* Description   : to exec drp process of OpenCV accelerator matchTemplate.
+* Arguments     : _img = src image, _templ = template image, _result = result image,
+                  method = match method, _mask = mask,
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+******************************************/
+int cv::matchTemplate_drp(InputArray _img, InputArray _templ, OutputArray _result, int method, InputArray _mask)
+{
+    CV_LOG_INFO(nullprt, "matchTemplate_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if (NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_MATCHTEMPLATE);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        CV_LOG_INFO(nullprt, "matchTemplate disable.");
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* exec drp function process */
+    Mat img = _img.getMat(), templ = _templ.getMat();
+
+    /* first, check can exec drp circuit */
+    uint32_t image_width = img.cols;
+    uint32_t image_height = img.rows;
+    uint32_t tmpl_width = templ.cols;
+    uint32_t tmpl_height = templ.rows;
+    uint32_t tmpl_ch = templ.channels();
+
+    uint16_t image_ch = img.channels();
+    uint8_t *out_image_buffer;
+
+    /* image width */
+    if (1920 < image_width || 16 > image_width || 0 != image_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* image height */
+    if (1080 < image_height || 16 > image_height || 0 != image_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 > image_ch || 4 < image_ch)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != img.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* templ width */
+    if (image_width < tmpl_width || 8 > tmpl_width || 0 != tmpl_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* templ height */
+    if (image_height < tmpl_height || 8 > tmpl_height || 0 != tmpl_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* method */
+    if(method != CV_TM_SQDIFF && method != CV_TM_SQDIFF_NORMED
+        && method != CV_TM_CCORR && method != CV_TM_CCORR_NORMED)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* mask */
+    if (&_mask != &noArray())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat result_mat = _result.getMat();
+    int result = DRP_NORMAL_END;
+
+    /* check continuous */
+    if(!img.isContinuous())
+    {
+        img = img.clone();
+    }
+
+    if(!templ.isContinuous())
+    {
+        templ = templ.clone();
+    }
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setMatchTemplateParameter(image_width, image_height, image_ch,
+                tmpl_width, tmpl_height, tmpl_ch, method);
+
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(img.data);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setMatchTempl(templ.data);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    uint32_t result_size = result_mat.cols * result_mat.rows * result_mat.channels();
+    out_image_buffer = (uint8_t *)(new uint32_t[result_size]);
+    
+    result = drp->readTemplateMatchResult(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    Mat dst_mat_out = Mat(result_mat.rows, result_mat.cols, result_mat.type(), out_image_buffer);
+    dst_mat_out.copyTo(_result);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullprt, "matchTemplate_drp end.");
+
+    drp->set_drp_end();
+
+    return result;
+}
+
 void cv::matchTemplate( InputArray _img, InputArray _templ, OutputArray _result, int method, InputArray _mask )
 {
     CV_INSTRUMENT_REGION();
@@ -1125,6 +1299,15 @@ void cv::matchTemplate( InputArray _img,
 
     CV_IPP_RUN_FAST(ipp_matchTemplate(img, templ, result, method))
 
+    int ret = matchTemplate_drp(_img, _templ, _result, method, _mask);
+
+    if(ret != DRP_NOT_EXECUTE)
+    {
+        return;
+    }
+
+    CV_LOG_INFO(nullprt, "continue to normal opencv.");
+
     crossCorr( img, templ, result, result.size(), result.type(), Point(0,0), 0, 0);
 
     common_matchTemplate(img, templ, result, method, cn);
diff -uprN old/modules/imgproc/src/thresh.cpp new/modules/imgproc/src/thresh.cpp
--- old/modules/imgproc/src/thresh.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/thresh.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -46,6 +46,9 @@
 
 #include "opencv2/core/openvx/ovx_defs.hpp"
 
+#include <opencv2/core/utils/logger.hpp>
+#include <rzv2ma_drp.h>
+
 namespace cv
 {
 
@@ -1617,12 +1620,189 @@ double cv::threshold( InputArray _src, O
     return thresh;
 }
 
+/***************************************************************************
+* Method Name   : cv::adaptiveThreshold_drp
+* Description   : to execute adaptiveThreshold_drp
+* Arguments     : _src = input Mat object, _dst = output Mat object,
+                  max_value = max value condition is satisfiled,
+                  threshold_type = thresholding type, block_size = size of block size of pixel
+                  threshold_C = Constant substracted
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_PARAM_ERROR otherwise
+****************************************************************************/
+int cv::adaptiveThreshold_drp( InputArray _src, OutputArray _dst, double max_value,
+    int adaptive_method, int threshold_type, int block_size, double threshold_c )
+{
+    CV_LOG_INFO(nullprt, "adaptiveThreshold_drp start.");
+
+    /* get single instance */
+    rzv2m_drp *drp = rzv2m_drp::get_instance();
+    if(NULL == drp)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* get possible flag */
+    int resize_possiblef = drp->get_drp_possiblef(PARAM_NO_ATHRESHOLD);
+    
+    /* active status only */
+    if(resize_possiblef != CIRCUIT_POSSIBLEF_ACTIVE)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* exec drp function process */
+    /* convert to mat object */
+    Mat src_mat = _src.getMat();
+   
+    /* first, check can exec drp circuit */
+    uint32_t src_width = src_mat.cols;
+    uint32_t src_height = src_mat.rows;
+    uint32_t dst_width = src_width;
+    uint32_t dst_height = src_height;
+    uint16_t src_ch = src_mat.channels();
+    uint8_t *out_image_buffer;
+
+    /* width */
+    if (3840 < src_width || 16 > src_width || 0 != src_width % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* height */
+    if (2160 < src_height || 16 > src_height || 0 != src_height % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* channels */
+    if (1 != src_mat.channels())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* bit depth */
+    if (CV_8U != src_mat.depth())
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* maxValue */
+    if (0 > max_value || 255 < max_value)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* adaptiveMethod */
+    if(adaptive_method != ADAPTIVE_THRESH_MEAN_C)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* thesholdType */
+    if( (threshold_type != THRESH_BINARY) && (threshold_type != THRESH_BINARY_INV) )
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    
+    if (3 > block_size || 255 < block_size || (int)src_width <= block_size || (int)src_height <= block_size || 1 != block_size % 2)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    if(threshold_c < 0.0 || threshold_c > 255.0)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    /* get 8bit of decimal point, truncate rest */
+    uint16_t threshold_c_16 = static_cast<uint16_t>(std::round(threshold_c * (1 << 8)));
+
+    CV_LOG_INFO(nullprt, "adaptiveThreshold_drp exec.");
+   
+    /* it is nesessary to create dst mat object. */
+    _dst.create(src_mat.size(), CV_MAKETYPE(src_mat.depth(), src_ch));
+    Mat dst_mat = _dst.getMat();
+
+    /* check continuous */
+    if(!src_mat.isContinuous())
+    {
+        src_mat = src_mat.clone();
+    }
+
+    int result = DRP_NORMAL_END;
+
+    /* set in process to driver */
+    if(drp->set_drp_start() == DRP_CONFLICT_ERROR)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* reading opencva binary header info */
+    result = drp->readBinaryHeader();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    /* set parameter to drp */
+    drp->setAdaptiveThreshold(src_width, src_height, src_ch, max_value, threshold_type, block_size, threshold_c_16);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->setSrcImage(src_mat.data);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    result = drp->execDRP();
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;
+    }
+
+    out_image_buffer = new uint8_t[src_width * src_height * src_ch];
+
+    result = drp->readDstImage(out_image_buffer);
+    if (DRP_NORMAL_END != result)
+    {
+        drp->set_drp_end();
+        return DRP_NOT_EXECUTE;       
+    }
+    
+    Mat dst_mat_out = Mat(dst_height, dst_width, CV_MAKETYPE(src_mat.depth(), src_ch), out_image_buffer);
+    dst_mat_out.copyTo(dst_mat);
+
+    delete[] out_image_buffer;
+
+    CV_LOG_INFO(nullprt, "adaptiveThreshold_drp end.");
+
+    drp->set_drp_end();
+
+    return result;
+}
 
 void cv::adaptiveThreshold( InputArray _src, OutputArray _dst, double maxValue,
                             int method, int type, int blockSize, double delta )
 {
     CV_INSTRUMENT_REGION();
 
+    /* first, exec drp function */
+    int ret = cv::adaptiveThreshold_drp(_src, _dst, maxValue, method, type, blockSize, delta);
+    if(ret != DRP_NOT_EXECUTE)
+    {
+        CV_LOG_INFO(nullprt, "adaptiveThreshold_drp nornal end.");
+        return;
+    }
+
+    CV_LOG_INFO(nullprt, "adaptiveThreshold exec nornal opencv.");
+
     Mat src = _src.getMat();
     CV_Assert( src.type() == CV_8UC1 );
     CV_Assert( blockSize % 2 == 1 && blockSize > 1 );
diff -uprN old/modules/imgproc/src/utils.cpp new/modules/imgproc/src/utils.cpp
--- old/modules/imgproc/src/utils.cpp	2019-04-08 02:09:10.000000000 +0900
+++ new/modules/imgproc/src/utils.cpp	2023-11-07 14:01:15.000000000 +0900
@@ -40,6 +40,7 @@
 //M*/
 
 #include "precomp.hpp"
+#include <rzv2ma_drp.h>
 
 CV_IMPL CvSeq* cvPointSeqFromMat( int seq_kind, const CvArr* arr,
                                   CvContour* contour_header, CvSeqBlock* block )
@@ -87,4 +88,61 @@ cvCopyMakeBorder( const CvArr* srcarr, C
     cv::copyMakeBorder( src, dst, top, bottom, left, right, borderType, value );
 }
 
+/*****************************************************************
+* Method Name   : OCA_Activate
+* Description   : activate or inactivate opencva circuit function
+* Arguments     : unsigned long* OCA_list
+* Return value  : DRP_NORMAL_END if succeeded
+*                 DRP_NOT_EXECUTE otherwise
+******************************************************************/
+CV_EXPORTS_W int OCA_Activate(unsigned long* OCA_list)
+{
+    /* get instance for exec api */
+    rzv2m_drp *drp = rzv2m_drp::get_instance_forapi();
+    if(drp == NULL)
+    {
+        return -1;
+    }
+
+    /* reading opencva binary header info */
+    int result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        return DRP_NOT_EXECUTE;
+    }
+    
+    /* call method */
+    drp->OCA_Activate(OCA_list);
+    
+    return 0;
+}
+
+/*****************************************************************
+* Method Name   : OCA_ConflictNotification
+* Description   : set conflict ation setting(CV_Error or normal opencv exec)
+* Arguments     : int OCA_list
+* Return value  : void
+******************************************************************/
+CV_EXPORTS_W void OCA_ConflictNotification(int oca_conflict)
+{
+    /* get instance for exec api */
+    rzv2m_drp *drp = rzv2m_drp::get_instance_forapi();
+    if(drp == NULL)
+    {
+        return;
+    }
+
+    /* reading opencva binary header info */
+    int result = drp->readBinaryHeader();
+    if(DRP_NORMAL_END != result)
+    {
+        return;
+    }
+
+    /* call method */
+    drp->OCA_ConflictNotification(oca_conflict);
+
+    return;
+}
+
 /* End of file. */
 old/modules/python/src2/__pycache__/hdr_parser.cpython-38.pyc new/modules/python/src2/__pycache__/hdr_parser.cpython-38.pyc 
